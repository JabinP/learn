{"version":3,"sources":["webpack:///path---apis-and-microservices-basic-node-and-express-use-body-parser-to-parse-post-requests-eaf9a0c4023fa88fd721.js","webpack:///./.cache/json/apis-and-microservices-basic-node-and-express-use-body-parser-to-parse-post-requests.json"],"names":["webpackJsonp","2775","module","exports","data","challengeNode","title","guideUrl","description","challengeType","fields","blockName","slug","tests","text","testString","pathContext","challengeMeta","introPath","template","required","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,yCAAAC,SAAA,KAAAC,aAAA,uiCAAu9BC,cAAA,EAAAC,QAAgMC,UAAA,yBAAAC,KAAA,wFAAAC,QAA8IC,KAAA,yBAAAC,WAAA,yMAAqPC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,KAAAC,YAAAC,kBAAA,6EAAAC,GAAA,4BAA8KV,KAAA","file":"path---apis-and-microservices-basic-node-and-express-use-body-parser-to-parse-post-requests-eaf9a0c4023fa88fd721.js","sourcesContent":["webpackJsonp([104771457525219],{\n\n/***/ 2775:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Use body-parser to Parse POST Requests\",\"guideUrl\":null,\"description\":[\"除了 GET 还有另一个常见的 http 动词，它是 POST。POST 是使用 HTML 表单发送客户端数据的默认方法。在 REST 规范中，POST 常用于发送数据，以便在数据库中创建新项目（新用户或新博客文章）。我们在这个项目中没有使用数据库，我们将学习如何处理 POST 请求。\",\"在这些类型的请求中，数据不会出现在 URL 中，而是隐藏在请求正文中。这也是 HTML 请求的一部分，被称为负载。因为 HTML 是基于文本的，你看不到数据，这并不意味着它们是加密的。HTTP POST 请求的原始内容如下所示：\",\"<blockquote>POST /path/subpath HTTP/1.0<br>From: john@example.com<br>User-Agent: someBrowser/1.0<br>Content-Type: application/x-www-form-urlencoded<br>Content-Length: 20<br>name=John+Doe&age=25</blockquote>\",\"正如你所看到的，正文被编码成了查询字符串。这是 HTML 表单使用的默认格式。使用 Ajax，我们还可以使用 JSON 来处理具有更复杂结构的数据。还有另一种类型的编码：multipart/form-data。它用来上传二进制文件。\",\"在本练习中，我们将使用网址编码 body。\",\"要解析来自 POST 请求的数据，你必须安装一个包：body-parser。这个包允许你使用一套可以解码不同格式数据的中间件，在<a href=\\\"https://github.com/expressjs/body-parser\\\" target=\\\"_blank\\\" >这里</a>查看文档。\",\"在 package.json 中安装 body-parser 模块，然后在文件顶部 require 进来，用变量 bodyParser 保存它。\",\"处理 URL 编码数据通过中间件的<code>bodyParser.urlencoded({extended: false})</code>方法。<code>extended=false</code>是一个配置选项，告诉解析器使用经典编码。当你使用它时，值只能是字符串或者数组。继承版使用起来数据更加灵活，它比 JSON 更好。传递给<code>app.use()</code>上一次方法调用返回的函数。通常中间件必须挂载在所有需要它的路由之前。\"],\"challengeType\":2,\"fields\":{\"blockName\":\"Basic Node and Express\",\"slug\":\"/apis-and-microservices/basic-node-and-express/use-body-parser-to-parse-post-requests\",\"tests\":[{\"text\":\"'body-parser' 中间件应该被挂载\",\"testString\":\"getUserInput => $.get(getUserInput('url') + '/_api/add-body-parser').then(data => { assert.isAbove(data.mountedAt, 0, '\\\"body-parser\\\" 没有正确挂载') }, xhr => { throw new Error(xhr.responseText); })\"}]}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/apis-and-microservices/basic-node-and-express/get-data-from-post-requests\",\"id\":\"587d7fb2367417b2b2512bf7\"},\"slug\":\"/apis-and-microservices/basic-node-and-express/use-body-parser-to-parse-post-requests\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---apis-and-microservices-basic-node-and-express-use-body-parser-to-parse-post-requests-eaf9a0c4023fa88fd721.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Use body-parser to Parse POST Requests\",\"guideUrl\":null,\"description\":[\"除了 GET 还有另一个常见的 http 动词，它是 POST。POST 是使用 HTML 表单发送客户端数据的默认方法。在 REST 规范中，POST 常用于发送数据，以便在数据库中创建新项目（新用户或新博客文章）。我们在这个项目中没有使用数据库，我们将学习如何处理 POST 请求。\",\"在这些类型的请求中，数据不会出现在 URL 中，而是隐藏在请求正文中。这也是 HTML 请求的一部分，被称为负载。因为 HTML 是基于文本的，你看不到数据，这并不意味着它们是加密的。HTTP POST 请求的原始内容如下所示：\",\"<blockquote>POST /path/subpath HTTP/1.0<br>From: john@example.com<br>User-Agent: someBrowser/1.0<br>Content-Type: application/x-www-form-urlencoded<br>Content-Length: 20<br>name=John+Doe&age=25</blockquote>\",\"正如你所看到的，正文被编码成了查询字符串。这是 HTML 表单使用的默认格式。使用 Ajax，我们还可以使用 JSON 来处理具有更复杂结构的数据。还有另一种类型的编码：multipart/form-data。它用来上传二进制文件。\",\"在本练习中，我们将使用网址编码 body。\",\"要解析来自 POST 请求的数据，你必须安装一个包：body-parser。这个包允许你使用一套可以解码不同格式数据的中间件，在<a href=\\\"https://github.com/expressjs/body-parser\\\" target=\\\"_blank\\\" >这里</a>查看文档。\",\"在 package.json 中安装 body-parser 模块，然后在文件顶部 require 进来，用变量 bodyParser 保存它。\",\"处理 URL 编码数据通过中间件的<code>bodyParser.urlencoded({extended: false})</code>方法。<code>extended=false</code>是一个配置选项，告诉解析器使用经典编码。当你使用它时，值只能是字符串或者数组。继承版使用起来数据更加灵活，它比 JSON 更好。传递给<code>app.use()</code>上一次方法调用返回的函数。通常中间件必须挂载在所有需要它的路由之前。\"],\"challengeType\":2,\"fields\":{\"blockName\":\"Basic Node and Express\",\"slug\":\"/apis-and-microservices/basic-node-and-express/use-body-parser-to-parse-post-requests\",\"tests\":[{\"text\":\"'body-parser' 中间件应该被挂载\",\"testString\":\"getUserInput => $.get(getUserInput('url') + '/_api/add-body-parser').then(data => { assert.isAbove(data.mountedAt, 0, '\\\"body-parser\\\" 没有正确挂载') }, xhr => { throw new Error(xhr.responseText); })\"}]}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/apis-and-microservices/basic-node-and-express/get-data-from-post-requests\",\"id\":\"587d7fb2367417b2b2512bf7\"},\"slug\":\"/apis-and-microservices/basic-node-and-express/use-body-parser-to-parse-post-requests\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/apis-and-microservices-basic-node-and-express-use-body-parser-to-parse-post-requests.json\n// module id = 2775\n// module chunks = 104771457525219"],"sourceRoot":""}
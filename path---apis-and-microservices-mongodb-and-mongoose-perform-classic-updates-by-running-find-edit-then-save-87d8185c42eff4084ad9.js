webpackJsonp([70140468036293],{2796:function(e,o){e.exports={data:{challengeNode:{title:"Perform Classic Updates by Running Find, Edit, then Save",guideUrl:null,description:["在过去，如果你想要编辑 document，并且使用它。例如：将其发送回服务器响应中。那么你就需要这样做：Mongoose 有一个专用的更新方法：<code>Model.update() </code>, 它绑定到低级 mongo 驱动程序，它可以批量编辑符合特定条件的多个 document，但它不会发送更新后的 document，只返回'状态'消息。此外，它使模型验证变得困难，因为它只是直接调用 mongo 驱动程序。","使用参数 personId 作为搜索关键字，通过 _id 找到一个人（使用上述任何一种方法）. 将 “hamburger” 添加到她的 favoriteFoods 列中去 (你可以使用 <code>Array.push()</code>)。然后在 <code>.find()</code> 的回调里使用 <code>.save()</code> 方法已更新的人物信息。","[*] 提示: 如果你在 Schema 中将 favoriteFoods 声明为一个 Array(数组), 没有指定它的类型(如：[String])，这可能很棘手。 在这种情况下， favoriteFoods 默认为 #Mixed 类型， 允许任意类型的值，你就必须手动执行 <code>document.markModified（'edited-field'）</code> 将其设为已编辑。(http://mongoosejs.com/docs/schematypes.html - #Mixed)"],challengeType:2,fields:{blockName:"MongoDB and Mongoose",slug:"/apis-and-microservices/mongodb-and-mongoose/perform-classic-updates-by-running-find-edit-then-save",tests:[{text:"对一个 item（项目）的 Find-edit-update 操作成功",testString:"getUserInput => $.post(getUserInput('url') +'/_api/find-edit-save', {name:'Poldo', age: 40, favoriteFoods:['spaghetti']}).then(data => { assert.equal(data.name,'Poldo','item.name is not what expected'); assert.equal(data.age, 40,'item.age is not what expected'); assert.deepEqual(data.favoriteFoods, ['spaghetti','hamburger'],'item.favoriteFoods is not what expected'); assert.equal(data.__v, 1,'The item should be previously edited'); }, xhr => { throw new Error(xhr.responseText); })"}]}}},pathContext:{challengeMeta:{introPath:"",template:null,required:[],nextChallengePath:"/apis-and-microservices/mongodb-and-mongoose/perform-new-updates-on-a-document-using-model-findoneandupdate",id:"587d7fb8367417b2b2512c0e"},slug:"/apis-and-microservices/mongodb-and-mongoose/perform-classic-updates-by-running-find-edit-then-save"}}}});
//# sourceMappingURL=path---apis-and-microservices-mongodb-and-mongoose-perform-classic-updates-by-running-find-edit-then-save-87d8185c42eff4084ad9.js.map
webpackJsonp([49223873087007],{2833:function(e,t){e.exports={data:{challengeNode:{title:"Delete a Node with Two Children in a Binary Search Tree",description:["移除拥有两个子节点的节点是最难处理的情况，因为移除这种节点会让它的两个子树独立。我们该如何重连这两个子树呢？一种方法是找到需要删除节点的右子树中的最小值，并把这个最小值复制到被删除的那个节点。以这种方式选择的新节点，它的值一定会大于它左子树中所有节点的值；同时这个新节点的值也一定会小于它右子树中所有节点的值。","在复制操作之后，我们还需要把它从右子树移除。需要注意的是，我们现在要删除的这个节点可能是右子树的叶子节点，也可能是这个节点本身还存在子树。如果这个节点是叶子结点，那我们就只须移除其父节点和它的连接。否则，我们就需要让这个节点的父节点指向这个节点的右子树。如果你不明白这个逻辑，请自己尝试画一个图。","挑战说明：现在我们要处理第三种情况以完善<code>remove</code>方法。我们已经为你写好了之前两种情况的代码，现在请你来编写删除拥有两个子节点的节点的代码。同时，别忘了考虑极端情况，比如树结构中只有三个节点的情况。解决了这种情况也就意味着我们彻底完成了二叉查找树中的删除操作。这是一个很难的问题，解决它是一个不小的成就。"],challengeType:1,fields:{slug:"/coding-interview-prep/data-structures/delete-a-node-with-two-children-in-a-binary-search-tree",blockName:"Data Structures",tests:[{text:"<code>BinarySearchTree</code>数据结构应该存在。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');"},{text:"<code>BinarySearchTree</code>应该有<code>remove</code>方法。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.remove == 'function')})(), '<code>BinarySearchTree</code>应该有<code>remove</code>方法。');"},{text:"试图移除一个不存在的元素，方法应返回<code>null</code>。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.remove == 'function') ? (test.remove(100) == null) : false})(), '试图移除一个不存在的元素，方法应返回<code>null</code>。');"},{text:"如果根节点是树中唯一的节点，则删除时应将其设置为<code>null</code>。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; test.add(500); test.remove(500); return (typeof test.remove == 'function') ? (test.inorder() == null) : false})(), '如果根节点是树中唯一的节点，则删除时应将其设置为<code>null</code>。');"},{text:"<code>remove</code>方法应可以从树中移除叶子节点。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; test.add(5); test.add(3); test.add(7); test.add(6); test.add(10); test.add(12); test.remove(3); test.remove(12); test.remove(10); return (typeof test.remove == 'function') ? (test.inorder().join('') == '567') : false})(), '<code>remove</code>方法应可以从树中移除叶子节点。');"},{text:"<code>remove</code>方法应可以移除有一个子节点的节点。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(-1); test.add(3); test.add(7); test.add(16); test.remove(16); test.remove(7); test.remove(3); return (test.inorder().join('') == '-1'); })(), '<code>remove</code>方法应可以移除有一个子节点的节点。');"},{text:"移除根节点应会让另一个节点成为根节点。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(15); test.add(27); test.remove(15); return (test.inorder().join('') == '27'); })(), '移除根节点应会让另一个节点成为根节点。');"},{text:"<code>remove</code>方法应可以在不破坏二叉查找树结构的前提下，移除拥有两个子节点的节点。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(1); test.add(4); test.add(3); test.add(7); test.add(9); test.add(11); test.add(14); test.add(15); test.add(19); test.add(50); test.remove(9); if (!test.isBinarySearchTree()) { return false; }; test.remove(11); if (!test.isBinarySearchTree()) { return false; }; test.remove(14); if (!test.isBinarySearchTree()) { return false; }; test.remove(19); if (!test.isBinarySearchTree()) { return false; }; test.remove(3); if (!test.isBinarySearchTree()) { return false; }; test.remove(50); if (!test.isBinarySearchTree()) { return false; }; test.remove(15); if (!test.isBinarySearchTree()) { return false; }; return (test.inorder().join('') == '147'); })(), '<code>remove</code>方法应可以在不破坏二叉查找树结构的前提下，移除拥有两个子节点的节点。');"},{text:"只有三个节点的树结构的根节点也应可以被移除。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(100); test.add(50); test.add(300); test.remove(100); return (test.inorder().join('') == 50300); })(), '只有三个节点的树结构的根节点也应可以被移除。');"}]},required:[],files:{indexhtml:null,indexjs:{key:"indexjs",ext:"js",name:"index",contents:"var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\n\nfunction BinarySearchTree() {\n  this.root = null;\n  this.remove = function(value) {\n    if (this.root === null) {\n      return null;\n    }\n    var target;\n    var parent = null;\n    // 找出要删除的节点及其父节点\n    (function findValue(node = this.root) {\n      if (value == node.value) {\n        target = node;\n      } else if (value < node.value && node.left !== null) {\n        parent = node;\n        return findValue(node.left);\n      } else if (value < node.value && node.left === null) {\n        return null;\n      } else if (value > node.value && node.right !== null) {\n        parent = node;\n        return findValue(node.right);\n      } else {\n        return null;\n      }\n    }).bind(this)();\n    if (target === null) {\n      return null;\n    }\n    // 获取要删除节点的子节点数量\n    var children = (target.left !== null ? 1 : 0) + (target.right !== null ? 1 : 0);\n    // 情况 1：要删除的节点没有子节点\n    if (children === 0) {\n      if (target == this.root) {\n        this.root = null;\n      }\n      else {\n        if (parent.left == target) {\n          parent.left = null;\n        } else {\n          parent.right = null;\n        }\n      }\n    }\n    // 情况 2：要删除的节点只有一个子节点\n    else if (children == 1) {\n      var newChild = (target.left !== null) ? target.left : target.right;\n      if (parent === null) {\n        target.value = newChild.value;\n        target.left = null;\n        target.right = null;\n      } else if (newChild.value < parent.value) {\n        parent.left = newChild;\n      } else {\n        parent.right = newChild;\n      }\n      target = null;\n    }\n    // 情况 3：要删除的节点有两个子节点，请把你的代码写在这条注释以下\n  };\n}",head:"",tail:"BinarySearchTree.prototype = {\n    add: function(value) {\n        var node = this.root;\n        if (node == null) {\n          this.root = new Node(value);\n          return;\n        } else {\n            function searchTree(node) {\n                if (value < node.value) {\n                    if (node.left == null) {\n                        node.left = new Node(value);\n                        return;\n                    } else if (node.left != null) {\n                        return searchTree(node.left)\n                    };\n                } else if (value > node.value) {\n                    if (node.right == null) {\n                        node.right = new Node(value);\n                        return;\n                    } else if (node.right != null) {\n                        return searchTree(node.right);\n                    };\n                } else {\n                    return null;\n                };\n            };\n            return searchTree(node);\n        };\n    },\n    inorder: function() {\n        if (this.root == null) {\n          return null;\n        } else {\n          var result = new Array();\n          function traverseInOrder(node) {\n              if (node.left != null) {\n                  traverseInOrder(node.left);\n              };\n              result.push(node.value);\n              if (node.right != null) {\n                  traverseInOrder(node.right);\n              };\n          }\n          traverseInOrder(this.root);\n          return result;\n        };\n    },    \n    isBinarySearchTree() {\n        if (this.root == null) {\n            return null;\n        } else {\n            var check = true;\n            function checkTree(node) {\n                if (node.left != null) {\n                    var left = node.left;\n                    if (left.value > node.value) {\n                        check = false;\n                    } else {\n                        checkTree(left);\n                    }\n                }\n                if (node.right != null) {\n                    var right = node.right;\n                    if (right.value < node.value) {\n                        check = false;\n                    } else {\n                        checkTree(right);\n                    };\n                };\n            };\n            checkTree(this.root);\n            return check;\n        }\n    }\n};"},indexjsx:null}}},pathContext:{challengeMeta:{introPath:"",template:null,required:[],nextChallengePath:"/coding-interview-prep/data-structures/invert-a-binary-tree",id:"587d8258367417b2b2512c82"},slug:"/coding-interview-prep/data-structures/delete-a-node-with-two-children-in-a-binary-search-tree"}}}});
//# sourceMappingURL=path---coding-interview-prep-data-structures-delete-a-node-with-two-children-in-a-binary-search-tree-8c4dabfb236ed3bf06b6.js.map
{"version":3,"sources":["webpack:///path---apis-and-microservices-basic-node-and-express-serve-an-html-file-3ab65e9be102f2ee9136.js","webpack:///./.cache/json/apis-and-microservices-basic-node-and-express-serve-an-html-file.json"],"names":["webpackJsonp","2771","module","exports","data","challengeNode","title","guideUrl","description","challengeType","fields","blockName","slug","tests","text","testString","pathContext","challengeMeta","introPath","template","required","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,qBAAAC,SAAA,KAAAC,aAAA,0hBAAAC,cAAA,EAAAC,QAAonBC,UAAA,yBAAAC,KAAA,oEAAAC,QAA0HC,KAAA,+BAAAC,WAAA,4KAA8NC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,KAAAC,YAAAC,kBAAA,qEAAAC,GAAA,4BAAsKV,KAAA","file":"path---apis-and-microservices-basic-node-and-express-serve-an-html-file-3ab65e9be102f2ee9136.js","sourcesContent":["webpackJsonp([103248269254677],{\n\n/***/ 2771:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Serve an HTML File\",\"guideUrl\":null,\"description\":[\"我们可以使用<code>res.sendFile(path)</code>方法来响应一个文件。\",\"你可以把响应一个文件的方法放到路由处理程序中：<code>app.get('/', ...)</code>。在后台，这个方法会根据你想发送的文件的类型，设置适当的 headers 头信息来告诉浏览器如何处理它。然后它会读取并发送文件。此方法需要文件的绝对路径。我们建议你使用 Node.js 的全局变量<code>__dirname</code>来计算出这个文件的绝对路径。\",\"例子：<code>absolutePath = __dirname + relativePath/file.ext</code>.\",\"要发送的文件是<code>/views/index.html</code>。在 app 中点击 \\\"Show Live\\\" 按钮，你会看到一个大的 HTML 标题（以及我们稍后将使用的表单…），目前它们还没有任何样式。\",\"注意: 你可以编辑上一个挑战的解题代码，或者创建一个新的挑战。如果你重写了之前的代码，请注意 Express 会从上到下重新解析对应的路由方法。它执行第一个匹配的路由处理方法。你必须注释掉前面的代码，否则服务器还是响应之前的字符串。\"],\"challengeType\":2,\"fields\":{\"blockName\":\"Basic Node and Express\",\"slug\":\"/apis-and-microservices/basic-node-and-express/serve-an-html-file\",\"tests\":[{\"text\":\"app 应该响应 views/index.html 文件\",\"testString\":\"getUserInput => $.get(getUserInput('url')).then(data => { assert.match(data, /<h1>.*<\\\\/h1>/, 'app 没有输出预期的 HTML'); }, xhr => { throw new Error(xhr.responseText); })\"}]}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/apis-and-microservices/basic-node-and-express/serve-static-assets\",\"id\":\"587d7fb0367417b2b2512bef\"},\"slug\":\"/apis-and-microservices/basic-node-and-express/serve-an-html-file\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---apis-and-microservices-basic-node-and-express-serve-an-html-file-3ab65e9be102f2ee9136.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Serve an HTML File\",\"guideUrl\":null,\"description\":[\"我们可以使用<code>res.sendFile(path)</code>方法来响应一个文件。\",\"你可以把响应一个文件的方法放到路由处理程序中：<code>app.get('/', ...)</code>。在后台，这个方法会根据你想发送的文件的类型，设置适当的 headers 头信息来告诉浏览器如何处理它。然后它会读取并发送文件。此方法需要文件的绝对路径。我们建议你使用 Node.js 的全局变量<code>__dirname</code>来计算出这个文件的绝对路径。\",\"例子：<code>absolutePath = __dirname + relativePath/file.ext</code>.\",\"要发送的文件是<code>/views/index.html</code>。在 app 中点击 \\\"Show Live\\\" 按钮，你会看到一个大的 HTML 标题（以及我们稍后将使用的表单…），目前它们还没有任何样式。\",\"注意: 你可以编辑上一个挑战的解题代码，或者创建一个新的挑战。如果你重写了之前的代码，请注意 Express 会从上到下重新解析对应的路由方法。它执行第一个匹配的路由处理方法。你必须注释掉前面的代码，否则服务器还是响应之前的字符串。\"],\"challengeType\":2,\"fields\":{\"blockName\":\"Basic Node and Express\",\"slug\":\"/apis-and-microservices/basic-node-and-express/serve-an-html-file\",\"tests\":[{\"text\":\"app 应该响应 views/index.html 文件\",\"testString\":\"getUserInput => $.get(getUserInput('url')).then(data => { assert.match(data, /<h1>.*<\\\\/h1>/, 'app 没有输出预期的 HTML'); }, xhr => { throw new Error(xhr.responseText); })\"}]}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/apis-and-microservices/basic-node-and-express/serve-static-assets\",\"id\":\"587d7fb0367417b2b2512bef\"},\"slug\":\"/apis-and-microservices/basic-node-and-express/serve-an-html-file\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/apis-and-microservices-basic-node-and-express-serve-an-html-file.json\n// module id = 2771\n// module chunks = 103248269254677"],"sourceRoot":""}
{"version":3,"sources":["webpack:///path---coding-interview-prep-data-structures-remove-elements-from-a-linked-list-3eb43418a1c34eb82913.js","webpack:///./.cache/json/coding-interview-prep-data-structures-remove-elements-from-a-linked-list.json"],"names":["webpackJsonp","2848","module","exports","data","challengeNode","title","description","challengeType","fields","slug","blockName","tests","text","testString","required","files","indexhtml","indexjs","key","ext","name","contents","head","tail","indexjsx","pathContext","challengeMeta","introPath","template","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,qCAAAC,aAAA,6fAAAC,cAAA,EAAAC,QAAqlBC,KAAA,4EAAAC,UAAA,kBAAAC,QAA2HC,KAAA,mDAAAC,WAAA,yJAAgOD,KAAA,qEAAAC,WAAA,2NAAoTD,KAAA,2DAAAC,WAAA,qMAAoRD,KAAA,gFAAAC,WAAA,kQAAqWC,YAAAC,OAAwBC,UAAA,KAAAC,SAA4BC,IAAA,UAAAC,IAAA,KAAAC,KAAA,QAAAC,SAAA,+qBAAkuBC,KAAA,GAAAC,KAAA,IAAsBC,SAAA,QAAmBC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,KAAAd,YAAAe,kBAAA,qEAAAC,GAAA,4BAAsKrB,KAAA","file":"path---coding-interview-prep-data-structures-remove-elements-from-a-linked-list-3eb43418a1c34eb82913.js","sourcesContent":["webpackJsonp([161569600882588],{\n\n/***/ 2848:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Remove Elements from a Linked List\",\"description\":[\"链表中一个重要的方法是<code>remove</code>。该方法接收一个元素作为参数，然后在链表中找到并移除该元素。\",\"在链表中移除节点并不只是从仅仅删除掉一个元素那么简单。在链表中，每个节点的<code>next</code>指针都会指向表中的下一个节点。因此，在移除节点时，我们需要确保这个被移除节点的前一个节点的<code>next</code>指针指向被移除节点的下一个节点。\",\"这样解释可能比较抽象，因此我们再来回想一下上面提到的老鹰捉小鸡。想象一下，在扮演鸡仔的队伍中，你正前方的人离开了队伍。这个离队的人也就不再会把手搭在他前一个人的肩上，同时你的手也不可能继续搭在离队的那个人肩上。接下来你需要向前走一步，把你的手搭在他前面的那个人肩上。\",\"如果我们移除的是头部元素，那么我们需要让<code>head</code>指针指向链表中的下一个元素（即移除前的第二个元素）。\",\"<hr>\",\"请编写<code>remove</code>方法，该方法接收一个元素作为参数并从链表中移除该元素。\",\"注意：\",\"每当有元素从链表中移除，<code>length</code>的数值都应该减一。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/coding-interview-prep/data-structures/remove-elements-from-a-linked-list\",\"blockName\":\"Data Structures\",\"tests\":[{\"text\":\"<code>LinkedList</code>应该有<code>remove</code>方法。\",\"testString\":\"assert((function(){var test = new LinkedList(); return (typeof test.remove === 'function')}()), '<code>LinkedList</code>应该有<code>remove</code>方法。');\"},{\"text\":\"当链表头部元素被移除时，<code>remove</code>方法应该让<code>head</code>指针指向表中的第二个元素。\",\"testString\":\"assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.remove('cat'); return test.head().element === 'dog'}()), '当链表头部元素被移除时，<code>remove</code>方法应该让<code>head</code>指针指向表中的第二个元素。');\"},{\"text\":\"当元素被移除时，<code>remove</code>方法应该让<code>length</code>减 1 。\",\"testString\":\"assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.remove('cat'); return test.size() === 1})(), '当元素被移除时，<code>remove</code>方法应该让<code>length</code>减 1 。');\"},{\"text\":\"当元素被移除时，<code>remove</code>方法应该让被移除元素的前一个元素的<code>next</code>指针指向被移除元素的下一个元素。\",\"testString\":\"assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog');test.add('kitten'); test.remove('dog'); return test.head().next.element === 'kitten'})(), '当元素被移除时，<code>remove</code>方法应该让被移除元素的前一个元素的<code>next</code>指针指向被移除元素的下一个元素。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"function LinkedList() { \\n  var length = 0; \\n  var head = null; \\n\\n  var Node = function(element){ \\n    this.element = element; \\n    this.next = null; \\n  }; \\n\\n  this.size = function(){\\n    return length;\\n  };\\n\\n  this.head = function(){\\n    return head;\\n  };\\n\\n  this.add = function(element){\\n    var node = new Node(element);\\n    if(head === null){\\n        head = node;\\n    } else {\\n        currentNode = head;\\n\\n        while(currentNode.next){\\n            currentNode  = currentNode.next;\\n        }\\n\\n        currentNode.next = node;\\n    }\\n\\n    length++;\\n  }; \\n\\n  this.remove = function(element){\\n    // 请把你的代码写在这条注释以下\\n\\n    // 请把你的代码写在这条注释以上\\n  };\\n}\",\"head\":\"\",\"tail\":\"\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/coding-interview-prep/data-structures/search-within-a-linked-list\",\"id\":\"587d8251367417b2b2512c63\"},\"slug\":\"/coding-interview-prep/data-structures/remove-elements-from-a-linked-list\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---coding-interview-prep-data-structures-remove-elements-from-a-linked-list-3eb43418a1c34eb82913.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Remove Elements from a Linked List\",\"description\":[\"链表中一个重要的方法是<code>remove</code>。该方法接收一个元素作为参数，然后在链表中找到并移除该元素。\",\"在链表中移除节点并不只是从仅仅删除掉一个元素那么简单。在链表中，每个节点的<code>next</code>指针都会指向表中的下一个节点。因此，在移除节点时，我们需要确保这个被移除节点的前一个节点的<code>next</code>指针指向被移除节点的下一个节点。\",\"这样解释可能比较抽象，因此我们再来回想一下上面提到的老鹰捉小鸡。想象一下，在扮演鸡仔的队伍中，你正前方的人离开了队伍。这个离队的人也就不再会把手搭在他前一个人的肩上，同时你的手也不可能继续搭在离队的那个人肩上。接下来你需要向前走一步，把你的手搭在他前面的那个人肩上。\",\"如果我们移除的是头部元素，那么我们需要让<code>head</code>指针指向链表中的下一个元素（即移除前的第二个元素）。\",\"<hr>\",\"请编写<code>remove</code>方法，该方法接收一个元素作为参数并从链表中移除该元素。\",\"注意：\",\"每当有元素从链表中移除，<code>length</code>的数值都应该减一。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/coding-interview-prep/data-structures/remove-elements-from-a-linked-list\",\"blockName\":\"Data Structures\",\"tests\":[{\"text\":\"<code>LinkedList</code>应该有<code>remove</code>方法。\",\"testString\":\"assert((function(){var test = new LinkedList(); return (typeof test.remove === 'function')}()), '<code>LinkedList</code>应该有<code>remove</code>方法。');\"},{\"text\":\"当链表头部元素被移除时，<code>remove</code>方法应该让<code>head</code>指针指向表中的第二个元素。\",\"testString\":\"assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.remove('cat'); return test.head().element === 'dog'}()), '当链表头部元素被移除时，<code>remove</code>方法应该让<code>head</code>指针指向表中的第二个元素。');\"},{\"text\":\"当元素被移除时，<code>remove</code>方法应该让<code>length</code>减 1 。\",\"testString\":\"assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.remove('cat'); return test.size() === 1})(), '当元素被移除时，<code>remove</code>方法应该让<code>length</code>减 1 。');\"},{\"text\":\"当元素被移除时，<code>remove</code>方法应该让被移除元素的前一个元素的<code>next</code>指针指向被移除元素的下一个元素。\",\"testString\":\"assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog');test.add('kitten'); test.remove('dog'); return test.head().next.element === 'kitten'})(), '当元素被移除时，<code>remove</code>方法应该让被移除元素的前一个元素的<code>next</code>指针指向被移除元素的下一个元素。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"function LinkedList() { \\n  var length = 0; \\n  var head = null; \\n\\n  var Node = function(element){ \\n    this.element = element; \\n    this.next = null; \\n  }; \\n\\n  this.size = function(){\\n    return length;\\n  };\\n\\n  this.head = function(){\\n    return head;\\n  };\\n\\n  this.add = function(element){\\n    var node = new Node(element);\\n    if(head === null){\\n        head = node;\\n    } else {\\n        currentNode = head;\\n\\n        while(currentNode.next){\\n            currentNode  = currentNode.next;\\n        }\\n\\n        currentNode.next = node;\\n    }\\n\\n    length++;\\n  }; \\n\\n  this.remove = function(element){\\n    // 请把你的代码写在这条注释以下\\n\\n    // 请把你的代码写在这条注释以上\\n  };\\n}\",\"head\":\"\",\"tail\":\"\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/coding-interview-prep/data-structures/search-within-a-linked-list\",\"id\":\"587d8251367417b2b2512c63\"},\"slug\":\"/coding-interview-prep/data-structures/remove-elements-from-a-linked-list\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/coding-interview-prep-data-structures-remove-elements-from-a-linked-list.json\n// module id = 2848\n// module chunks = 161569600882588"],"sourceRoot":""}
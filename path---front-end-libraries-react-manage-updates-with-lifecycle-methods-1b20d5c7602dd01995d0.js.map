{"version":3,"sources":["webpack:///path---front-end-libraries-react-manage-updates-with-lifecycle-methods-1b20d5c7602dd01995d0.js","webpack:///./.cache/json/front-end-libraries-react-manage-updates-with-lifecycle-methods.json"],"names":["webpackJsonp","3585","module","exports","data","challengeNode","title","description","challengeType","fields","slug","blockName","tests","text","testString","required","link","raw","src","files","indexhtml","indexjs","indexjsx","key","ext","name","contents","head","tail","pathContext","challengeMeta","introPath","template","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,wCAAAC,aAAA,s9BAA49BC,cAAA,EAAAC,QAAqFC,KAAA,mEAAAC,UAAA,QAAAC,QAAwGC,KAAA,2DAAAC,WAAA,0QAAyVD,KAAA,kGAAAC,WAAA,mVAAycD,KAAA,iGAAAC,WAAA,2kBAAgsBD,KAAA,uEAAAC,WAAA,mTAA6YC,WAAcC,KAAA,KAAAC,IAAA,KAAAC,IAAA,+DAA4FF,KAAA,KAAAC,IAAA,KAAAC,IAAA,uEAAkGC,OAAWC,UAAA,KAAAC,QAAA,KAAAC,UAA4CC,IAAA,WAAAC,IAAA,MAAAC,KAAA,QAAAC,SAAA,uxBAA40BC,KAAA,GAAAC,KAAA,uEAAyFC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,qFAAsGjB,WAAsBC,KAAA,KAAAC,IAAA,KAAAC,IAAA,+DAA4FF,KAAA,KAAAC,IAAA,KAAAC,IAAA,uEAAkGe,kBAAA,4EAAAC,GAAA,4BAAkIxB,KAAA","file":"path---front-end-libraries-react-manage-updates-with-lifecycle-methods-1b20d5c7602dd01995d0.js","sourcesContent":["webpackJsonp([196098996097771],{\n\n/***/ 3585:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Manage Updates with Lifecycle Methods\",\"description\":[\"另一个生命周期方法是<code>componentWillReceiveProps()</code>，只要组件将要接收新的 props 就会调用它。此方法接收新的 props（通常写为<code>nextProps</code>）作为参数。你可以使用此参数并与<code>this.props</code>进行比较，并在组件更新之前执行操作。例如，你可以在处理更新之前在本地调用<code>setState()</code>。\",\"还有一个方法是<code>componentDidUpdate()</code>，它在组件重新渲染后立即调用。请注意，渲染和装载在组件生命周期中是不同的。当页面第一次加载时，所有组件都被装载，这就是调用<code>componentWillMount()</code>和<code>componentDidMount()</code>等方法的地方。此后，随着 state 的变化，组件会重新渲染自己。下一个挑战将更详细地讨论这一点。\",\"<hr>\",\"子组件<code>Dialog</code>从其父组件<code>Controller</code>接收<code>message</code>props。在<code>Dialog</code>组件中编写<code>componentWillReceiveProps()</code>方法，并将<code>this.props</code>和<code>nextProps</code>记录到控制台。你需要将<code>nextProps</code>作为参数传递给此方法，虽然可以将其命名为任何名称，但请将其命名为<code>nextProps</code>。\",\"接下来，在<code>Dialog</code>组件中添加<code>componentDidUpdate()</code>，并记录一条说明组件已更新的语句。此方法的工作方式类似于为你提供的<code>componentWillUpdate()</code>。现在单击按钮更改消息并观察浏览器控制台。控制台语句的顺序显示了调用方法的顺序。\",\"<strong>注意：/strong>&nbsp;为了通过测试，你需要将生命周期方法编写为普通函数，而不是箭头函数（将生命周期方法编写为箭头函数也没有好处）。\"],\"challengeType\":6,\"fields\":{\"slug\":\"/front-end-libraries/react/manage-updates-with-lifecycle-methods\",\"blockName\":\"React\",\"tests\":[{\"text\":\"<code>Controller</code>组件应该将<code>Dialog</code>组件渲染为子组件。\",\"testString\":\"assert((function() { const mockedComponent = Enzyme.mount(React.createElement(Controller)); return mockedComponent.find('Controller').length === 1 && mockedComponent.find('Dialog').length === 1; })(), '<code>Controller</code>组件应该将<code>Dialog</code>组件渲染为子组件。');\"},{\"text\":\"<code>Dialog</code>组件中的<code>componentWillReceiveProps</code>方法应将<code>this.props</code>记录到控制台。\",\"testString\":\"assert((function() { const lifecycleChild = React.createElement(Dialog).type.prototype.componentWillReceiveProps.toString().replace(/ /g,''); return lifecycleChild.includes('console.log') && lifecycleChild.includes('this.props') })(), '<code>Dialog</code>组件中的<code>componentWillReceiveProps</code>方法应将<code>this.props</code>记录到控制台。');\"},{\"text\":\"<code>Dialog</code>组件中的<code>componentWillReceiveProps</code>方法应将<code>nextProps</code>记录到控制台。\",\"testString\":\"assert((function() { const lifecycleChild = React.createElement(Dialog).type.prototype.componentWillReceiveProps.toString().replace(/ /g,''); const nextPropsAsParameterTest = /componentWillReceiveProps(| *?= *?)(\\\\(|)nextProps(\\\\)|)( *?=> *?{| *?{|{)/; const nextPropsInConsoleLogTest = /console\\\\.log\\\\(.*?nextProps\\\\b.*?\\\\)/; return ( lifecycleChild.includes('console.log') && nextPropsInConsoleLogTest.test(lifecycleChild) && nextPropsAsParameterTest.test(lifecycleChild) ); })(), '<code>Dialog</code>组件中的<code>componentWillReceiveProps</code>方法应将<code>nextProps</code>记录到控制台。');\"},{\"text\":\"<code>Dialog</code>组件应调用<code>componentDidUpdate</code>方法并将消息记录到控制台。\",\"testString\":\"assert((function() { const lifecycleChild = React.createElement(Dialog).type.prototype.componentDidUpdate.toString().replace(/ /g,''); return lifecycleChild.length !== 'undefined' && lifecycleChild.includes('console.log'); })(), '<code>Dialog</code>组件应调用<code>componentDidUpdate</code>方法并将消息记录到控制台。');\"}]},\"required\":[{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react@16.4.0/umd/react.production.min.js\"},{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react-dom@16.4.0/umd/react-dom.production.min.js\"}],\"files\":{\"indexhtml\":null,\"indexjs\":null,\"indexjsx\":{\"key\":\"indexjsx\",\"ext\":\"jsx\",\"name\":\"index\",\"contents\":\"class Dialog extends React.Component {\\n  constructor(props) {\\n    super(props);\\n  }\\n  componentWillUpdate() {\\n    console.log('Component is about to update...');\\n  }\\n  // change code below this line\\n\\n  // change code above this line\\n  render() {\\n    return <h1>{this.props.message}</h1>\\n  }\\n};\\n\\nclass Controller extends React.Component {\\n  constructor(props) {\\n    super(props);\\n    this.state = {\\n      message: 'First Message'\\n    };\\n    this.changeMessage = this.changeMessage.bind(this);\\n  }\\n  changeMessage() {\\n    this.setState({\\n      message: 'Second Message'\\n    });\\n  }\\n  render() {\\n    return (\\n      <div>\\n        <button onClick={this.changeMessage}>Update</button>\\n        <Dialog message={this.state.message}/>\\n      </div>\\n    );\\n  }\\n};\",\"head\":\"\",\"tail\":\"ReactDOM.render(<Controller />, document.getElementById('root'))\"}}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":\"<body><div id='root'></div><div id='challenge-node'></div>${ source || '' }</body>\",\"required\":[{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react@16.4.0/umd/react.production.min.js\"},{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react-dom@16.4.0/umd/react-dom.production.min.js\"}],\"nextChallengePath\":\"/front-end-libraries/react/optimize-re-renders-with-shouldcomponentupdate\",\"id\":\"5a24c314108439a4d403617f\"},\"slug\":\"/front-end-libraries/react/manage-updates-with-lifecycle-methods\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---front-end-libraries-react-manage-updates-with-lifecycle-methods-1b20d5c7602dd01995d0.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Manage Updates with Lifecycle Methods\",\"description\":[\"另一个生命周期方法是<code>componentWillReceiveProps()</code>，只要组件将要接收新的 props 就会调用它。此方法接收新的 props（通常写为<code>nextProps</code>）作为参数。你可以使用此参数并与<code>this.props</code>进行比较，并在组件更新之前执行操作。例如，你可以在处理更新之前在本地调用<code>setState()</code>。\",\"还有一个方法是<code>componentDidUpdate()</code>，它在组件重新渲染后立即调用。请注意，渲染和装载在组件生命周期中是不同的。当页面第一次加载时，所有组件都被装载，这就是调用<code>componentWillMount()</code>和<code>componentDidMount()</code>等方法的地方。此后，随着 state 的变化，组件会重新渲染自己。下一个挑战将更详细地讨论这一点。\",\"<hr>\",\"子组件<code>Dialog</code>从其父组件<code>Controller</code>接收<code>message</code>props。在<code>Dialog</code>组件中编写<code>componentWillReceiveProps()</code>方法，并将<code>this.props</code>和<code>nextProps</code>记录到控制台。你需要将<code>nextProps</code>作为参数传递给此方法，虽然可以将其命名为任何名称，但请将其命名为<code>nextProps</code>。\",\"接下来，在<code>Dialog</code>组件中添加<code>componentDidUpdate()</code>，并记录一条说明组件已更新的语句。此方法的工作方式类似于为你提供的<code>componentWillUpdate()</code>。现在单击按钮更改消息并观察浏览器控制台。控制台语句的顺序显示了调用方法的顺序。\",\"<strong>注意：/strong>&nbsp;为了通过测试，你需要将生命周期方法编写为普通函数，而不是箭头函数（将生命周期方法编写为箭头函数也没有好处）。\"],\"challengeType\":6,\"fields\":{\"slug\":\"/front-end-libraries/react/manage-updates-with-lifecycle-methods\",\"blockName\":\"React\",\"tests\":[{\"text\":\"<code>Controller</code>组件应该将<code>Dialog</code>组件渲染为子组件。\",\"testString\":\"assert((function() { const mockedComponent = Enzyme.mount(React.createElement(Controller)); return mockedComponent.find('Controller').length === 1 && mockedComponent.find('Dialog').length === 1; })(), '<code>Controller</code>组件应该将<code>Dialog</code>组件渲染为子组件。');\"},{\"text\":\"<code>Dialog</code>组件中的<code>componentWillReceiveProps</code>方法应将<code>this.props</code>记录到控制台。\",\"testString\":\"assert((function() { const lifecycleChild = React.createElement(Dialog).type.prototype.componentWillReceiveProps.toString().replace(/ /g,''); return lifecycleChild.includes('console.log') && lifecycleChild.includes('this.props') })(), '<code>Dialog</code>组件中的<code>componentWillReceiveProps</code>方法应将<code>this.props</code>记录到控制台。');\"},{\"text\":\"<code>Dialog</code>组件中的<code>componentWillReceiveProps</code>方法应将<code>nextProps</code>记录到控制台。\",\"testString\":\"assert((function() { const lifecycleChild = React.createElement(Dialog).type.prototype.componentWillReceiveProps.toString().replace(/ /g,''); const nextPropsAsParameterTest = /componentWillReceiveProps(| *?= *?)(\\\\(|)nextProps(\\\\)|)( *?=> *?{| *?{|{)/; const nextPropsInConsoleLogTest = /console\\\\.log\\\\(.*?nextProps\\\\b.*?\\\\)/; return ( lifecycleChild.includes('console.log') && nextPropsInConsoleLogTest.test(lifecycleChild) && nextPropsAsParameterTest.test(lifecycleChild) ); })(), '<code>Dialog</code>组件中的<code>componentWillReceiveProps</code>方法应将<code>nextProps</code>记录到控制台。');\"},{\"text\":\"<code>Dialog</code>组件应调用<code>componentDidUpdate</code>方法并将消息记录到控制台。\",\"testString\":\"assert((function() { const lifecycleChild = React.createElement(Dialog).type.prototype.componentDidUpdate.toString().replace(/ /g,''); return lifecycleChild.length !== 'undefined' && lifecycleChild.includes('console.log'); })(), '<code>Dialog</code>组件应调用<code>componentDidUpdate</code>方法并将消息记录到控制台。');\"}]},\"required\":[{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react@16.4.0/umd/react.production.min.js\"},{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react-dom@16.4.0/umd/react-dom.production.min.js\"}],\"files\":{\"indexhtml\":null,\"indexjs\":null,\"indexjsx\":{\"key\":\"indexjsx\",\"ext\":\"jsx\",\"name\":\"index\",\"contents\":\"class Dialog extends React.Component {\\n  constructor(props) {\\n    super(props);\\n  }\\n  componentWillUpdate() {\\n    console.log('Component is about to update...');\\n  }\\n  // change code below this line\\n\\n  // change code above this line\\n  render() {\\n    return <h1>{this.props.message}</h1>\\n  }\\n};\\n\\nclass Controller extends React.Component {\\n  constructor(props) {\\n    super(props);\\n    this.state = {\\n      message: 'First Message'\\n    };\\n    this.changeMessage = this.changeMessage.bind(this);\\n  }\\n  changeMessage() {\\n    this.setState({\\n      message: 'Second Message'\\n    });\\n  }\\n  render() {\\n    return (\\n      <div>\\n        <button onClick={this.changeMessage}>Update</button>\\n        <Dialog message={this.state.message}/>\\n      </div>\\n    );\\n  }\\n};\",\"head\":\"\",\"tail\":\"ReactDOM.render(<Controller />, document.getElementById('root'))\"}}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":\"<body><div id='root'></div><div id='challenge-node'></div>${ source || '' }</body>\",\"required\":[{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react@16.4.0/umd/react.production.min.js\"},{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react-dom@16.4.0/umd/react-dom.production.min.js\"}],\"nextChallengePath\":\"/front-end-libraries/react/optimize-re-renders-with-shouldcomponentupdate\",\"id\":\"5a24c314108439a4d403617f\"},\"slug\":\"/front-end-libraries/react/manage-updates-with-lifecycle-methods\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/front-end-libraries-react-manage-updates-with-lifecycle-methods.json\n// module id = 3585\n// module chunks = 196098996097771"],"sourceRoot":""}
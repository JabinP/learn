{"version":3,"sources":["webpack:///path---javascript-algorithms-and-data-structures-object-oriented-programming-add-methods-after-inheritance-78af997a0934039d4440.js","webpack:///./.cache/json/javascript-algorithms-and-data-structures-object-oriented-programming-add-methods-after-inheritance.json"],"names":["webpackJsonp","3953","module","exports","data","challengeNode","title","description","challengeType","fields","slug","blockName","tests","text","testString","required","files","indexhtml","indexjs","key","ext","name","contents","head","tail","indexjsx","pathContext","challengeMeta","introPath","template","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,gCAAAC,aAAA,wYAAkb,8RAA+R,iMAA8K,gRAAAC,cAAA,EAAAC,QAAmVC,KAAA,uGAAAC,UAAA,8BAAAC,QAAkKC,KAAA,gDAAAC,WAAA,4GAAgLD,KAAA,qEAAAC,WAAA,4HAAqND,KAAA,iEAAAC,WAAA,oHAAyMD,KAAA,uEAAAC,WAAA,8GAAyMD,KAAA,6DAAAC,WAAA,uGAAuLC,YAAAC,OAAwBC,UAAA,KAAAC,SAA4BC,IAAA,UAAAC,IAAA,KAAAC,KAAA,QAAAC,SAAA,oQAA2SC,KAAA,GAAAC,KAAA,IAAwCC,SAAA,QAAmBC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,KAAAd,YAAAe,kBAAA,oGAAAC,GAAA,4BAAqMrB,KAAA","file":"path---javascript-algorithms-and-data-structures-object-oriented-programming-add-methods-after-inheritance-78af997a0934039d4440.js","sourcesContent":["webpackJsonp([247769962310553],{\n\n/***/ 3953:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Add Methods After Inheritance\",\"description\":[\"从<code>父类</code>继承其<code>原型</code>对象的构造函数除了继承的方法之外，还可以有自己的方法。\",\"请看举例：<code>Bird</code>是一个构造函数，它继承了<code>Animal</code>构造函数的<code>原型</code>：\",\"<blockquote>function Animal() { }<br>Animal.prototype.eat = function() {<br>&nbsp;&nbsp;console.log(\\\"nom nom nom\\\");<br>};<br>function Bird() { }<br>Bird.prototype = Object.create(Animal.prototype);<br>Bird.prototype.constructor = Bird;</blockquote>\",\"除了从<code>Animal</code>构造函数继承的行为之外，还需要给<code>Bird</code>对象添加它独有的行为。这里，我们给<code>Bird</code>对象添加一个<code>fly()</code>函数。函数会以一种与其他构造函数相同的方式添加到<code>Bird</code>的<code>原型</code>中：\",\"<blockquote>Bird.prototype.fly = function() {<br>&nbsp;&nbsp;console.log(\\\"I'm flying!\\\");<br>};</blockquote>\",\"现在<code>Bird</code>的实例中就有了<code>eat()</code>和<code>fly()</code>这两个方法：\",\"<blockquote>let duck = new Bird();<br>duck.eat(); // 输出 \\\"nom nom nom\\\"<br>duck.fly(); // 输出 \\\"I'm flying!\\\"</blockquote>\",\"<hr>\",\"添加必要的代码，使得<code>Dog</code>对象继承<code>Animal</code>构造函数，并且把<code>Dog 原型</code>上的 constructor 属性设置为 Dog。然后给<code>Dog</code>对象添加一个<code>bark()</code>方法，这样的话，<code>beagle</code>将同时拥有<code>eat()</code>和<code>bark()</code>这两个方法。<code>bark()</code>方法中应该输出 \\\"Woof!\\\" 到控制台。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/javascript-algorithms-and-data-structures/object-oriented-programming/add-methods-after-inheritance\",\"blockName\":\"Object Oriented Programming\",\"tests\":[{\"text\":\"<code>Animal</code>应该没有<code>bark()</code>方法。\",\"testString\":\"assert(typeof Animal.prototype.bark == \\\"undefined\\\", '<code>Animal</code>应该没有<code>bark()</code>方法。');\"},{\"text\":\"<code>Dog</code>应该继承了<code>Animal</code>构造函数的<code>eat()</code>方法。\",\"testString\":\"assert(typeof Dog.prototype.eat == \\\"function\\\", '<code>Dog</code>应该继承了<code>Animal</code>构造函数的<code>eat()</code>方法。');\"},{\"text\":\"<code>Dog</code>应该有一个<code>bark()</code>方法作为<code>自身</code>属性。\",\"testString\":\"assert(Dog.prototype.hasOwnProperty('bark'), '<code>Dog</code>应该有一个<code>bark()</code>方法作为<code>自身</code>属性。');\"},{\"text\":\"<code>beagle</code>应该是<code>Animal</code>的一个<code>instanceof</code>。\",\"testString\":\"assert(beagle instanceof Animal, '<code>beagle</code>应该是<code>Animal</code>的一个<code>instanceof</code>。');\"},{\"text\":\"<code>beagle</code>的 constructor 属性应该被设置为<code>Dog</code>。\",\"testString\":\"assert(beagle.constructor === Dog, '<code>beagle</code>的 constructor 属性应该被设置为<code>Dog</code>。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"function Animal() { }\\nAnimal.prototype.eat = function() { console.log(\\\"nom nom nom\\\"); };\\n\\nfunction Dog() { }\\n\\n// 请把你的代码写在这条注释以下\\n\\n\\n\\n\\n// 请把你的代码写在这条注释以下\\n\\nlet beagle = new Dog();\\n\\nbeagle.eat(); // 应该输出 \\\"nom nom nom\\\"\\nbeagle.bark(); // 应该输出 \\\"Woof!\\\"\",\"head\":\"\",\"tail\":\"\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/javascript-algorithms-and-data-structures/object-oriented-programming/override-inherited-methods\",\"id\":\"587d7db1367417b2b2512b87\"},\"slug\":\"/javascript-algorithms-and-data-structures/object-oriented-programming/add-methods-after-inheritance\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---javascript-algorithms-and-data-structures-object-oriented-programming-add-methods-after-inheritance-78af997a0934039d4440.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Add Methods After Inheritance\",\"description\":[\"从<code>父类</code>继承其<code>原型</code>对象的构造函数除了继承的方法之外，还可以有自己的方法。\",\"请看举例：<code>Bird</code>是一个构造函数，它继承了<code>Animal</code>构造函数的<code>原型</code>：\",\"<blockquote>function Animal() { }<br>Animal.prototype.eat = function() {<br>&nbsp;&nbsp;console.log(\\\"nom nom nom\\\");<br>};<br>function Bird() { }<br>Bird.prototype = Object.create(Animal.prototype);<br>Bird.prototype.constructor = Bird;</blockquote>\",\"除了从<code>Animal</code>构造函数继承的行为之外，还需要给<code>Bird</code>对象添加它独有的行为。这里，我们给<code>Bird</code>对象添加一个<code>fly()</code>函数。函数会以一种与其他构造函数相同的方式添加到<code>Bird</code>的<code>原型</code>中：\",\"<blockquote>Bird.prototype.fly = function() {<br>&nbsp;&nbsp;console.log(\\\"I'm flying!\\\");<br>};</blockquote>\",\"现在<code>Bird</code>的实例中就有了<code>eat()</code>和<code>fly()</code>这两个方法：\",\"<blockquote>let duck = new Bird();<br>duck.eat(); // 输出 \\\"nom nom nom\\\"<br>duck.fly(); // 输出 \\\"I'm flying!\\\"</blockquote>\",\"<hr>\",\"添加必要的代码，使得<code>Dog</code>对象继承<code>Animal</code>构造函数，并且把<code>Dog 原型</code>上的 constructor 属性设置为 Dog。然后给<code>Dog</code>对象添加一个<code>bark()</code>方法，这样的话，<code>beagle</code>将同时拥有<code>eat()</code>和<code>bark()</code>这两个方法。<code>bark()</code>方法中应该输出 \\\"Woof!\\\" 到控制台。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/javascript-algorithms-and-data-structures/object-oriented-programming/add-methods-after-inheritance\",\"blockName\":\"Object Oriented Programming\",\"tests\":[{\"text\":\"<code>Animal</code>应该没有<code>bark()</code>方法。\",\"testString\":\"assert(typeof Animal.prototype.bark == \\\"undefined\\\", '<code>Animal</code>应该没有<code>bark()</code>方法。');\"},{\"text\":\"<code>Dog</code>应该继承了<code>Animal</code>构造函数的<code>eat()</code>方法。\",\"testString\":\"assert(typeof Dog.prototype.eat == \\\"function\\\", '<code>Dog</code>应该继承了<code>Animal</code>构造函数的<code>eat()</code>方法。');\"},{\"text\":\"<code>Dog</code>应该有一个<code>bark()</code>方法作为<code>自身</code>属性。\",\"testString\":\"assert(Dog.prototype.hasOwnProperty('bark'), '<code>Dog</code>应该有一个<code>bark()</code>方法作为<code>自身</code>属性。');\"},{\"text\":\"<code>beagle</code>应该是<code>Animal</code>的一个<code>instanceof</code>。\",\"testString\":\"assert(beagle instanceof Animal, '<code>beagle</code>应该是<code>Animal</code>的一个<code>instanceof</code>。');\"},{\"text\":\"<code>beagle</code>的 constructor 属性应该被设置为<code>Dog</code>。\",\"testString\":\"assert(beagle.constructor === Dog, '<code>beagle</code>的 constructor 属性应该被设置为<code>Dog</code>。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"function Animal() { }\\nAnimal.prototype.eat = function() { console.log(\\\"nom nom nom\\\"); };\\n\\nfunction Dog() { }\\n\\n// 请把你的代码写在这条注释以下\\n\\n\\n\\n\\n// 请把你的代码写在这条注释以下\\n\\nlet beagle = new Dog();\\n\\nbeagle.eat(); // 应该输出 \\\"nom nom nom\\\"\\nbeagle.bark(); // 应该输出 \\\"Woof!\\\"\",\"head\":\"\",\"tail\":\"\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/javascript-algorithms-and-data-structures/object-oriented-programming/override-inherited-methods\",\"id\":\"587d7db1367417b2b2512b87\"},\"slug\":\"/javascript-algorithms-and-data-structures/object-oriented-programming/add-methods-after-inheritance\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/javascript-algorithms-and-data-structures-object-oriented-programming-add-methods-after-inheritance.json\n// module id = 3953\n// module chunks = 247769962310553"],"sourceRoot":""}
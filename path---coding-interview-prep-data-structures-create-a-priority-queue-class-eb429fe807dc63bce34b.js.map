{"version":3,"sources":["webpack:///path---coding-interview-prep-data-structures-create-a-priority-queue-class-eb429fe807dc63bce34b.js","webpack:///./.cache/json/coding-interview-prep-data-structures-create-a-priority-queue-class.json"],"names":["webpackJsonp","2824","module","exports","data","challengeNode","title","description","challengeType","fields","slug","blockName","tests","text","testString","required","files","indexhtml","indexjs","key","ext","name","contents","head","tail","indexjsx","pathContext","challengeMeta","introPath","template","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,gCAAAC,aAAA,41BAAAC,cAAA,EAAAC,QAA+6BC,KAAA,uEAAAC,UAAA,kBAAAC,QAAsHC,KAAA,+CAAAC,WAAA,0JAA6ND,KAAA,+CAAAC,WAAA,0JAA6ND,KAAA,4CAAAC,WAAA,oJAAoND,KAAA,+CAAAC,WAAA,0JAA6ND,KAAA,yDAAAC,WAAA,2XAAwcD,KAAA,sDAAAC,WAAA,oQAA8UD,KAAA,gDAAAC,WAAA,meAAsiBC,YAAAC,OAAwBC,UAAA,KAAAC,SAA4BC,IAAA,UAAAC,IAAA,KAAAC,KAAA,QAAAC,SAAA,kMAAqPC,KAAA,GAAAC,KAAA,IAAsBC,SAAA,QAAmBC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,KAAAd,YAAAe,kBAAA,iEAAAC,GAAA,4BAAkKrB,KAAA","file":"path---coding-interview-prep-data-structures-create-a-priority-queue-class-eb429fe807dc63bce34b.js","sourcesContent":["webpackJsonp([186597405096768],{\n\n/***/ 2824:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Create a Priority Queue Class\",\"description\":[\"在这次挑战中我们来创建 Priority Queue（优先队列）。优先队列是一种特殊的队列类型，这种队列中会有额外的信息来说明队列中元素的优先顺序，这种优先顺序可以用整数来表示，元素的优先级会直接影响元素的出队顺序。就算较高优先级的元素比较低优先级的元素后入队，在出队的时候，较高优先级的元素还是会先出队。\",\"举个例子，对于一个拥有 3 个元素的优先队列：\",\"<code>[['kitten', 2], ['dog', 2], ['rabbit', 2]]</code>\",\"元素中的第二个值（一个整数）代表这个元素的优先级，数字越小则优先级越高。如果我们让优先级为<code>1</code>的元素<code>['human', 1]</code>入队，那么这个元素在本优先队列中会第一个出队。添加该元素后，新的队列如下：\",\"<code>[['human', 1], ['kitten', 2], ['dog', 2], ['rabbit', 2]]</code>\",\"我们已经在右侧的代码编辑器中编写了<code>PriorityQueue</code>。你需要添加一个<code>enqueue</code>方法，使用该方法入队的元素都带有优先级；添加一个移除元素的<code>dequeue</code>方法；添加能够返回队列中元素总数的<code>size</code>方法；添加能够返回队列头部元素的<code>front</code>方法；添加<code>isEmpty</code>方法，当队列为空时<code>isEmpty</code>方法返回<code>true</code>，否则返回<code>false</code>。\",\"<code>enqueue</code>方法接收类似于<code>['human', 1]</code>的元素作为参数，其中数字<code>1</code>表示元素优先级。<code>dequeue</code>方法应该返回元素内容，无需返回它的优先级。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/coding-interview-prep/data-structures/create-a-priority-queue-class\",\"blockName\":\"Data Structures\",\"tests\":[{\"text\":\"<code>Queue</code>应该有<code>enqueue</code>方法。\",\"testString\":\"assert((function(){var test = new PriorityQueue();  return (typeof test.enqueue === 'function')}()), '<code>Queue</code>应该有<code>enqueue</code>方法。');\"},{\"text\":\"<code>Queue</code>应该有<code>dequeue</code>方法。\",\"testString\":\"assert((function(){var test = new PriorityQueue();  return (typeof test.dequeue === 'function')}()), '<code>Queue</code>应该有<code>dequeue</code>方法。');\"},{\"text\":\"<code>Queue</code>应该有<code>size</code>方法。\",\"testString\":\"assert((function(){var test = new PriorityQueue();  return (typeof test.size === 'function')}()), '<code>Queue</code>应该有<code>size</code>方法。');\"},{\"text\":\"<code>Queue</code>应该有<code>isEmpty</code>方法。\",\"testString\":\"assert((function(){var test = new PriorityQueue();  return (typeof test.isEmpty === 'function')}()), '<code>Queue</code>应该有<code>isEmpty</code>方法。');\"},{\"text\":\"当元素出队和入队时，你的优先队列应该可以使用<code>size</code>方法实时获取队列中元素的数量。\",\"testString\":\"assert((function(){var test = new PriorityQueue(); test.enqueue(['David Brown', 2]); test.enqueue(['Jon Snow', 1]); var size1 = test.size(); test.dequeue(); var size2 = test.size(); test.enqueue(['A', 3]); test.enqueue(['B', 3]); test.enqueue(['C', 3]); return (size1 === 2 && size2 === 1 && test.size() === 4)}()), '当元素出队和入队时，你的优先队列应该可以使用<code>size</code>方法实时获取队列中元素的数量。');\"},{\"text\":\"当队列为空时，<code>isEmpty</code>方法应该返回<code>true</code>。\",\"testString\":\"assert((function(){var test = new PriorityQueue(); test.enqueue(['A', 1]); test.enqueue(['B', 1]); test.dequeue(); var first = test.isEmpty(); test.dequeue(); return (!first && test.isEmpty()); }()), '当队列为空时，<code>isEmpty</code>方法应该返回<code>true</code>。');\"},{\"text\":\"优先队列中高优先级的元素应该先于低优先级的元素出队，同一优先级的元素则遵循先进先出的原则。\",\"testString\":\"assert((function(){var test = new PriorityQueue(); test.enqueue(['A', 5]); test.enqueue(['B', 5]); test.enqueue(['C', 5]); test.enqueue(['D', 3]); test.enqueue(['E', 1]); test.enqueue(['F', 7]); var result = []; result.push(test.dequeue()); result.push(test.dequeue()); result.push(test.dequeue()); result.push(test.dequeue()); result.push(test.dequeue()); result.push(test.dequeue()); return result.join('') === 'EDABCF';}()), '优先队列中高优先级的元素应该先于低优先级的元素出队，同一优先级的元素则遵循先进先出的原则。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"function PriorityQueue () {\\n    this.collection = [];\\n    this.printCollection = function() {\\n      console.log(this.collection);\\n    };\\n    // 请把你的代码写在这条注释以下\\n\\n    // 请把你的代码写在这条注释以上\\n}\",\"head\":\"\",\"tail\":\"\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/coding-interview-prep/data-structures/create-a-circular-queue\",\"id\":\"587d8255367417b2b2512c74\"},\"slug\":\"/coding-interview-prep/data-structures/create-a-priority-queue-class\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---coding-interview-prep-data-structures-create-a-priority-queue-class-eb429fe807dc63bce34b.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Create a Priority Queue Class\",\"description\":[\"在这次挑战中我们来创建 Priority Queue（优先队列）。优先队列是一种特殊的队列类型，这种队列中会有额外的信息来说明队列中元素的优先顺序，这种优先顺序可以用整数来表示，元素的优先级会直接影响元素的出队顺序。就算较高优先级的元素比较低优先级的元素后入队，在出队的时候，较高优先级的元素还是会先出队。\",\"举个例子，对于一个拥有 3 个元素的优先队列：\",\"<code>[['kitten', 2], ['dog', 2], ['rabbit', 2]]</code>\",\"元素中的第二个值（一个整数）代表这个元素的优先级，数字越小则优先级越高。如果我们让优先级为<code>1</code>的元素<code>['human', 1]</code>入队，那么这个元素在本优先队列中会第一个出队。添加该元素后，新的队列如下：\",\"<code>[['human', 1], ['kitten', 2], ['dog', 2], ['rabbit', 2]]</code>\",\"我们已经在右侧的代码编辑器中编写了<code>PriorityQueue</code>。你需要添加一个<code>enqueue</code>方法，使用该方法入队的元素都带有优先级；添加一个移除元素的<code>dequeue</code>方法；添加能够返回队列中元素总数的<code>size</code>方法；添加能够返回队列头部元素的<code>front</code>方法；添加<code>isEmpty</code>方法，当队列为空时<code>isEmpty</code>方法返回<code>true</code>，否则返回<code>false</code>。\",\"<code>enqueue</code>方法接收类似于<code>['human', 1]</code>的元素作为参数，其中数字<code>1</code>表示元素优先级。<code>dequeue</code>方法应该返回元素内容，无需返回它的优先级。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/coding-interview-prep/data-structures/create-a-priority-queue-class\",\"blockName\":\"Data Structures\",\"tests\":[{\"text\":\"<code>Queue</code>应该有<code>enqueue</code>方法。\",\"testString\":\"assert((function(){var test = new PriorityQueue();  return (typeof test.enqueue === 'function')}()), '<code>Queue</code>应该有<code>enqueue</code>方法。');\"},{\"text\":\"<code>Queue</code>应该有<code>dequeue</code>方法。\",\"testString\":\"assert((function(){var test = new PriorityQueue();  return (typeof test.dequeue === 'function')}()), '<code>Queue</code>应该有<code>dequeue</code>方法。');\"},{\"text\":\"<code>Queue</code>应该有<code>size</code>方法。\",\"testString\":\"assert((function(){var test = new PriorityQueue();  return (typeof test.size === 'function')}()), '<code>Queue</code>应该有<code>size</code>方法。');\"},{\"text\":\"<code>Queue</code>应该有<code>isEmpty</code>方法。\",\"testString\":\"assert((function(){var test = new PriorityQueue();  return (typeof test.isEmpty === 'function')}()), '<code>Queue</code>应该有<code>isEmpty</code>方法。');\"},{\"text\":\"当元素出队和入队时，你的优先队列应该可以使用<code>size</code>方法实时获取队列中元素的数量。\",\"testString\":\"assert((function(){var test = new PriorityQueue(); test.enqueue(['David Brown', 2]); test.enqueue(['Jon Snow', 1]); var size1 = test.size(); test.dequeue(); var size2 = test.size(); test.enqueue(['A', 3]); test.enqueue(['B', 3]); test.enqueue(['C', 3]); return (size1 === 2 && size2 === 1 && test.size() === 4)}()), '当元素出队和入队时，你的优先队列应该可以使用<code>size</code>方法实时获取队列中元素的数量。');\"},{\"text\":\"当队列为空时，<code>isEmpty</code>方法应该返回<code>true</code>。\",\"testString\":\"assert((function(){var test = new PriorityQueue(); test.enqueue(['A', 1]); test.enqueue(['B', 1]); test.dequeue(); var first = test.isEmpty(); test.dequeue(); return (!first && test.isEmpty()); }()), '当队列为空时，<code>isEmpty</code>方法应该返回<code>true</code>。');\"},{\"text\":\"优先队列中高优先级的元素应该先于低优先级的元素出队，同一优先级的元素则遵循先进先出的原则。\",\"testString\":\"assert((function(){var test = new PriorityQueue(); test.enqueue(['A', 5]); test.enqueue(['B', 5]); test.enqueue(['C', 5]); test.enqueue(['D', 3]); test.enqueue(['E', 1]); test.enqueue(['F', 7]); var result = []; result.push(test.dequeue()); result.push(test.dequeue()); result.push(test.dequeue()); result.push(test.dequeue()); result.push(test.dequeue()); result.push(test.dequeue()); return result.join('') === 'EDABCF';}()), '优先队列中高优先级的元素应该先于低优先级的元素出队，同一优先级的元素则遵循先进先出的原则。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"function PriorityQueue () {\\n    this.collection = [];\\n    this.printCollection = function() {\\n      console.log(this.collection);\\n    };\\n    // 请把你的代码写在这条注释以下\\n\\n    // 请把你的代码写在这条注释以上\\n}\",\"head\":\"\",\"tail\":\"\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/coding-interview-prep/data-structures/create-a-circular-queue\",\"id\":\"587d8255367417b2b2512c74\"},\"slug\":\"/coding-interview-prep/data-structures/create-a-priority-queue-class\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/coding-interview-prep-data-structures-create-a-priority-queue-class.json\n// module id = 2824\n// module chunks = 186597405096768"],"sourceRoot":""}
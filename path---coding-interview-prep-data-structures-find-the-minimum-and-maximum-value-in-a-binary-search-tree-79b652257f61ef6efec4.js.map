{"version":3,"sources":["webpack:///path---coding-interview-prep-data-structures-find-the-minimum-and-maximum-value-in-a-binary-search-tree-79b652257f61ef6efec4.js","webpack:///./.cache/json/coding-interview-prep-data-structures-find-the-minimum-and-maximum-value-in-a-binary-search-tree.json"],"names":["webpackJsonp","2836","module","exports","data","challengeNode","title","description","challengeType","fields","slug","blockName","tests","text","testString","required","files","indexhtml","indexjs","key","ext","name","contents","head","tail","indexjsx","pathContext","challengeMeta","introPath","template","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,6DAAAC,aAAA,w9BAAu7B,2lCAAAC,cAAA,EAAAC,QAA4uCC,KAAA,oGAAAC,UAAA,kBAAAC,QAAmJC,KAAA,yCAAAC,WAAA,4MAAyQD,KAAA,0DAAAC,WAAA,8PAA4UD,KAAA,0DAAAC,WAAA,8PAA4UD,KAAA,wCAAAC,WAAA,mYAA+bD,KAAA,wCAAAC,WAAA,oYAAgcD,KAAA,0EAAAC,WAAA,qZAAkfC,YAAAC,OAAwBC,UAAA,KAAAC,SAA4BC,IAAA,UAAAC,IAAA,KAAAC,KAAA,QAAAC,SAAA,oRAAuUC,KAAA,GAAAC,KAAA,+/BAAihCC,SAAA,QAAmBC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,KAAAd,YAAAe,kBAAA,mFAAAC,GAAA,4BAAoLrB,KAAA","file":"path---coding-interview-prep-data-structures-find-the-minimum-and-maximum-value-in-a-binary-search-tree-79b652257f61ef6efec4.js","sourcesContent":["webpackJsonp([258661968595381],{\n\n/***/ 2836:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Find the Minimum and Maximum Value in a Binary Search Tree\",\"description\":[\"在接下来的挑战中，我们来学习 tree（树）这种数据结构。在计算机科学中，树是一种很重要且常用的数据结构。之所以将这种数据结构称为树，是因为其结构很像真实生活中的树。树有一个叫做根节点（root node，可以类比树根）的初始节点，从根节点开始，通过分支（branch，可以类比树枝）链接其子节点，子节点又可以有其他的子节点，以此类推。如果要把这种数据结构画出来，一般会在最上面画根节点，就好象把真实世界中的树倒置过来。\",\"首先，我们介绍几个树这种数据结构中的常见概念。根节点是树中最顶端的节点，即树的开始；树中的每个数据称为节点（node）；指向其他节点的节点称为父级节点（parent node），被指向的节点称为子节点（child node）。还有一些概念，你应该可以望文生义。子树指的是一个节点下所有的子级节点（注意，包含子级的子级，等等）；分支也可以叫做边缘（edges），叶子节点（leaf node）是指没有子节点的节点。其实，树本身是一种递归性的数据结构。也就是说，任何一个的子节点都是它们子树的父节点。在我们为树的操作设计算法时，一定要注意树的递归特性。\",\"首先，我们来学习一种特殊的树——二叉树（binary tree）。更准确地说，我们现在要学的是二叉树中的一种特殊的类型——二叉查找树（binary search tree），我们先来解释一些概念。通常的树形数据结构中，一个节点可以有任意数量的分支。但二叉树中，每个节点最多只能有两个分支。此外，二叉查找树的子树会按一定规则排列，即每个节点左子树上的数值都小于等于该节点的数值；而每个节点右子树上的数值都大于等于该节点的数值。下面的图就代表一个二叉查找树，应该会对你理解这种数据类型有帮助：\",\"<div style='width: 100%; display: flex; justify-content: center; align-items: center;'><img style='width: 100%; max-width: 350px;' src='https://user-images.githubusercontent.com/18563015/32136009-1e665d98-bbd6-11e7-9133-63184f9f9182.png'></div>\",\"子树的排列方式已经很直观了。你可以注意到根节点 8 左边的子树节点值都小于 8，而右边的值则都大于 8。而且，这种数值间的关系对于任何节点的子树都是成立的。例如，8 的左子树的根节点数值为 3，该节点有两个子节点——根据二叉查找树的规则，我们无需查看便可以知道左子树的各节点数值都小于 3，而右子树的各节点数值都大于 3，以此类推。\",\"二叉查找树之所以有用且高效，是因为常用的操作比如查找元素、插入元素、删除元素等，需要的时间为对数级。如果你不理解这样的优势，可以与数组做个对比。对于一个长度为 n 的数组，找到元素的时间在 1（即第一个元素就是要找的）到 n（即最后一个元素才是要找的）之间。在寻找期间，我们没法跳过任何一个元素，只能一直往下，单向地寻找。因此我们说，在数组中找元素这个操作所需时间是与数组长度 n 线性相关的，它的时间复杂度我们记为 O(n)。而对于二叉查找树，我们只要比较当前节点与要找的数的大小，就可以知道该往左还是往右继续寻找。因此，在寻找元素的过程中，每一步都可以排除掉当前数据量的一半，我们可以用 0.5（代表一半）的 k（代表找到元素需要的步数）次方来表示。所以，对于总节点数为 n 的二叉查找树，找到一个元素所需步数 k 就是 log(2)n，即以 2 为底，n 的对数，排除一些不相干的因素（电脑性能，温度之类的），所需步数越多，时间也就越长，且两者线性相关。于是，它的时间复杂度我们可以记为 O(log(n))。注意，在 big O notation 中，常数是可以忽略的。至于 O(n) 到 O(log(n)) 是多大的提升，请你在纸上画出 y = x 和 y = log(2)x 的函数图像，然后你就懂了。如果看不明白上面的内容，请先去了解一下 big O notation 这种表示方式，在学习数据结构和算法时会经常提及。\",\"挑战说明：我们先来做一个简单任务。我们已经在右边写好了二叉查找树的基本结构，其中我们定义了用来创建树中节点的函数。注意，每个节点都可能有左节点和右节点，而且我们可以给这些节点赋一个子树。现在我们需要在二叉查找树中定义<code>findMin</code>和<code>findMax</code>两个方法，它们应分别返回树中的最小值和最大值。你现在不需要考虑如何往树中添加节点，我们已经在后台为你实现了。如果你写不出，请回忆下二叉查找树的这一规律：左子树上的数值总是小于等于父节点的数值，而右子树上的数值总是大于等于父节点的数值。我们同时需要注意的是树中只会存储整数值。还有，如果树为空的话，所有方法都应该返回<code>null</code>。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/coding-interview-prep/data-structures/find-the-minimum-and-maximum-value-in-a-binary-search-tree\",\"blockName\":\"Data Structures\",\"tests\":[{\"text\":\"<code>BinarySearchTree</code>数据结构应该存在。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');\"},{\"text\":\"<code>BinarySearchTree</code>应该有<code>findMin</code>方法。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.findMin == 'function')})(), '<code>BinarySearchTree</code>应该有<code>findMin</code>方法。');\"},{\"text\":\"<code>BinarySearchTree</code>应该有<code>findMax</code>方法。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.findMax == 'function')})(), '<code>BinarySearchTree</code>应该有<code>findMax</code>方法。');\"},{\"text\":\"<code>findMin</code>方法应该返回二叉查找树中的最小值。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMin !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return test.findMin() == 1; })(), '<code>findMin</code>方法返回二叉查找树中的最小值。');\"},{\"text\":\"<code>findMax</code>方法应该返回二叉查找树中的最大值。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMax !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return test.findMax() == 87; })(), '<code>findMax</code>方法返回二叉查找树中的最大值。');\"},{\"text\":\"当树为空时，<code>findMin</code>和<code>findMax</code>方法应该返回<code>null</code>。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMin !== 'function') { return false; }; if (typeof test.findMax !== 'function') { return false; }; return (test.findMin() == null && test.findMax() == null) })(), '当树为空时，<code>findMin</code>和<code>findMax</code>方法应该返回<code>null</code>。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));\\nfunction Node(value) {\\n    this.value = value;\\n    this.left = null;\\n    this.right = null;\\n}\\nfunction BinarySearchTree() {\\n    this.root = null;\\n    // 请把你的代码写在这条注释以下\\n    // 请把你的代码写在这条注释以上\\n}\",\"head\":\"\",\"tail\":\"BinarySearchTree.prototype = {\\n    add: function(value) {\\n        var node = this.root;\\n        if (node == null) {\\n          this.root = new Node(value);\\n          return;\\n        } else {\\n            function searchTree(node) {\\n                if (value < node.value) {\\n                    if (node.left == null) {\\n                        node.left = new Node(value);\\n                        return;\\n                    } else if (node.left != null) {\\n                        return searchTree(node.left)\\n                    };\\n                } else if (value > node.value) {\\n                    if (node.right == null) {\\n                        node.right = new Node(value);\\n                        return;\\n                    } else if (node.right != null) {\\n                        return searchTree(node.right);\\n                    };\\n                } else {\\n                    return null;\\n                };\\n            };\\n            return searchTree(node);\\n        };\\n    }\\n};\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/coding-interview-prep/data-structures/add-a-new-element-to-a-binary-search-tree\",\"id\":\"587d8256367417b2b2512c7a\"},\"slug\":\"/coding-interview-prep/data-structures/find-the-minimum-and-maximum-value-in-a-binary-search-tree\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---coding-interview-prep-data-structures-find-the-minimum-and-maximum-value-in-a-binary-search-tree-79b652257f61ef6efec4.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Find the Minimum and Maximum Value in a Binary Search Tree\",\"description\":[\"在接下来的挑战中，我们来学习 tree（树）这种数据结构。在计算机科学中，树是一种很重要且常用的数据结构。之所以将这种数据结构称为树，是因为其结构很像真实生活中的树。树有一个叫做根节点（root node，可以类比树根）的初始节点，从根节点开始，通过分支（branch，可以类比树枝）链接其子节点，子节点又可以有其他的子节点，以此类推。如果要把这种数据结构画出来，一般会在最上面画根节点，就好象把真实世界中的树倒置过来。\",\"首先，我们介绍几个树这种数据结构中的常见概念。根节点是树中最顶端的节点，即树的开始；树中的每个数据称为节点（node）；指向其他节点的节点称为父级节点（parent node），被指向的节点称为子节点（child node）。还有一些概念，你应该可以望文生义。子树指的是一个节点下所有的子级节点（注意，包含子级的子级，等等）；分支也可以叫做边缘（edges），叶子节点（leaf node）是指没有子节点的节点。其实，树本身是一种递归性的数据结构。也就是说，任何一个的子节点都是它们子树的父节点。在我们为树的操作设计算法时，一定要注意树的递归特性。\",\"首先，我们来学习一种特殊的树——二叉树（binary tree）。更准确地说，我们现在要学的是二叉树中的一种特殊的类型——二叉查找树（binary search tree），我们先来解释一些概念。通常的树形数据结构中，一个节点可以有任意数量的分支。但二叉树中，每个节点最多只能有两个分支。此外，二叉查找树的子树会按一定规则排列，即每个节点左子树上的数值都小于等于该节点的数值；而每个节点右子树上的数值都大于等于该节点的数值。下面的图就代表一个二叉查找树，应该会对你理解这种数据类型有帮助：\",\"<div style='width: 100%; display: flex; justify-content: center; align-items: center;'><img style='width: 100%; max-width: 350px;' src='https://user-images.githubusercontent.com/18563015/32136009-1e665d98-bbd6-11e7-9133-63184f9f9182.png'></div>\",\"子树的排列方式已经很直观了。你可以注意到根节点 8 左边的子树节点值都小于 8，而右边的值则都大于 8。而且，这种数值间的关系对于任何节点的子树都是成立的。例如，8 的左子树的根节点数值为 3，该节点有两个子节点——根据二叉查找树的规则，我们无需查看便可以知道左子树的各节点数值都小于 3，而右子树的各节点数值都大于 3，以此类推。\",\"二叉查找树之所以有用且高效，是因为常用的操作比如查找元素、插入元素、删除元素等，需要的时间为对数级。如果你不理解这样的优势，可以与数组做个对比。对于一个长度为 n 的数组，找到元素的时间在 1（即第一个元素就是要找的）到 n（即最后一个元素才是要找的）之间。在寻找期间，我们没法跳过任何一个元素，只能一直往下，单向地寻找。因此我们说，在数组中找元素这个操作所需时间是与数组长度 n 线性相关的，它的时间复杂度我们记为 O(n)。而对于二叉查找树，我们只要比较当前节点与要找的数的大小，就可以知道该往左还是往右继续寻找。因此，在寻找元素的过程中，每一步都可以排除掉当前数据量的一半，我们可以用 0.5（代表一半）的 k（代表找到元素需要的步数）次方来表示。所以，对于总节点数为 n 的二叉查找树，找到一个元素所需步数 k 就是 log(2)n，即以 2 为底，n 的对数，排除一些不相干的因素（电脑性能，温度之类的），所需步数越多，时间也就越长，且两者线性相关。于是，它的时间复杂度我们可以记为 O(log(n))。注意，在 big O notation 中，常数是可以忽略的。至于 O(n) 到 O(log(n)) 是多大的提升，请你在纸上画出 y = x 和 y = log(2)x 的函数图像，然后你就懂了。如果看不明白上面的内容，请先去了解一下 big O notation 这种表示方式，在学习数据结构和算法时会经常提及。\",\"挑战说明：我们先来做一个简单任务。我们已经在右边写好了二叉查找树的基本结构，其中我们定义了用来创建树中节点的函数。注意，每个节点都可能有左节点和右节点，而且我们可以给这些节点赋一个子树。现在我们需要在二叉查找树中定义<code>findMin</code>和<code>findMax</code>两个方法，它们应分别返回树中的最小值和最大值。你现在不需要考虑如何往树中添加节点，我们已经在后台为你实现了。如果你写不出，请回忆下二叉查找树的这一规律：左子树上的数值总是小于等于父节点的数值，而右子树上的数值总是大于等于父节点的数值。我们同时需要注意的是树中只会存储整数值。还有，如果树为空的话，所有方法都应该返回<code>null</code>。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/coding-interview-prep/data-structures/find-the-minimum-and-maximum-value-in-a-binary-search-tree\",\"blockName\":\"Data Structures\",\"tests\":[{\"text\":\"<code>BinarySearchTree</code>数据结构应该存在。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');\"},{\"text\":\"<code>BinarySearchTree</code>应该有<code>findMin</code>方法。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.findMin == 'function')})(), '<code>BinarySearchTree</code>应该有<code>findMin</code>方法。');\"},{\"text\":\"<code>BinarySearchTree</code>应该有<code>findMax</code>方法。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.findMax == 'function')})(), '<code>BinarySearchTree</code>应该有<code>findMax</code>方法。');\"},{\"text\":\"<code>findMin</code>方法应该返回二叉查找树中的最小值。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMin !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return test.findMin() == 1; })(), '<code>findMin</code>方法返回二叉查找树中的最小值。');\"},{\"text\":\"<code>findMax</code>方法应该返回二叉查找树中的最大值。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMax !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return test.findMax() == 87; })(), '<code>findMax</code>方法返回二叉查找树中的最大值。');\"},{\"text\":\"当树为空时，<code>findMin</code>和<code>findMax</code>方法应该返回<code>null</code>。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMin !== 'function') { return false; }; if (typeof test.findMax !== 'function') { return false; }; return (test.findMin() == null && test.findMax() == null) })(), '当树为空时，<code>findMin</code>和<code>findMax</code>方法应该返回<code>null</code>。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));\\nfunction Node(value) {\\n    this.value = value;\\n    this.left = null;\\n    this.right = null;\\n}\\nfunction BinarySearchTree() {\\n    this.root = null;\\n    // 请把你的代码写在这条注释以下\\n    // 请把你的代码写在这条注释以上\\n}\",\"head\":\"\",\"tail\":\"BinarySearchTree.prototype = {\\n    add: function(value) {\\n        var node = this.root;\\n        if (node == null) {\\n          this.root = new Node(value);\\n          return;\\n        } else {\\n            function searchTree(node) {\\n                if (value < node.value) {\\n                    if (node.left == null) {\\n                        node.left = new Node(value);\\n                        return;\\n                    } else if (node.left != null) {\\n                        return searchTree(node.left)\\n                    };\\n                } else if (value > node.value) {\\n                    if (node.right == null) {\\n                        node.right = new Node(value);\\n                        return;\\n                    } else if (node.right != null) {\\n                        return searchTree(node.right);\\n                    };\\n                } else {\\n                    return null;\\n                };\\n            };\\n            return searchTree(node);\\n        };\\n    }\\n};\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/coding-interview-prep/data-structures/add-a-new-element-to-a-binary-search-tree\",\"id\":\"587d8256367417b2b2512c7a\"},\"slug\":\"/coding-interview-prep/data-structures/find-the-minimum-and-maximum-value-in-a-binary-search-tree\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/coding-interview-prep-data-structures-find-the-minimum-and-maximum-value-in-a-binary-search-tree.json\n// module id = 2836\n// module chunks = 258661968595381"],"sourceRoot":""}
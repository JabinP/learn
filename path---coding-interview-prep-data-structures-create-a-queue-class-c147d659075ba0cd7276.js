webpackJsonp([0xda8695229dbb],{2825:function(e,t){e.exports={data:{challengeNode:{title:"Create a Queue Class",description:["如同栈一样，队列也是一系列元素的集合。但是与栈不同的是队列遵循 FIFO（First-In First-Out，先进先出）原则。新增元素会被添加进队列尾部，删除元素则是删除队列头部的元素。","我们可以使用数组像创建栈那样来创建队列，同时我们也希望控制队列拥有哪些操作方法。","<code>enqueue</code>和<code>dequeue</code>是队列中两个最主要的方法。<code>enqueue</code>方法将元素添加至队尾，而<code>dequeue</code>方法将队首元素移除并返回该元素。其它比较实用的方法有<code>front</code>、<code>size</code>和<code>isEmpty</code>等。","挑战说明：","请编写<code>enqueue</code>方法，该方法将新元素推入队尾；编写<code>dequeue</code>方法，该方法移除并返回队首元素；编写<code>front</code>方法，该方法返回队首元素；编写<code>size</code>方法，该方法返回队列长度；编写<code>isEmpty</code>方法，该方法判断队列是否为空。"],challengeType:1,fields:{slug:"/coding-interview-prep/data-structures/create-a-queue-class",blockName:"Data Structures",tests:[{text:"<code>Queue</code>应该有<code>enqueue</code>方法。",testString:"assert((function(){var test = new Queue();  return (typeof test.enqueue === 'function')}()), '<code>Queue</code>应该有<code>enqueue</code>方法。');"},{text:"<code>Queue</code>应该有<code>dequeue</code>方法。",testString:"assert((function(){var test = new Queue();  return (typeof test.dequeue === 'function')}()), '<code>Queue</code>应该有<code>dequeue</code>方法。');"},{text:"<code>Queue</code>应该有<code>front</code>方法。",testString:"assert((function(){var test = new Queue();  return (typeof test.front === 'function')}()), '<code>Queue</code>应该有<code>front</code>方法。');"},{text:"<code>Queue</code>应该有<code>size</code>方法。",testString:"assert((function(){var test = new Queue();  return (typeof test.size === 'function')}()), '<code>Queue</code>应该有<code>size</code>方法。');"},{text:"<code>Queue</code>应该有<code>isEmpty</code>方法。",testString:"assert((function(){var test = new Queue();  return (typeof test.isEmpty === 'function')}()), '<code>Queue</code>应该有<code>isEmpty</code>方法。');"},{text:"<code>dequeue</code>方法应该移除并返回队首元素。",testString:"assert((function(){var test = new Queue();  test.enqueue('Smith'); return (test.dequeue() === 'Smith')}()), '<code>dequeue</code>方法应该移除并返回队首元素。');"},{text:"<code>front</code>方法应该返回队首元素。",testString:"assert((function(){var test = new Queue();  test.enqueue('Smith'); test.enqueue('John'); return (test.front() === 'Smith')}()), '<code>front</code>方法应该返回队首元素。');"},{text:"<code>size</code>方法应该返回队列长度。",testString:"assert((function(){var test = new Queue();  test.enqueue('Smith'); return (test.size() === 1)}()), '<code>size</code>方法应该返回队列长度。');"},{text:"当队列中有元素时，<code>isEmpty</code>方法应该返回<code>false</code>。",testString:"assert((function(){var test = new Queue();  test.enqueue('Smith'); return !(test.isEmpty())}()), '当队列当中有元素时，<code>isEmpty</code>方法应该返回<code>false</code>。');"}]},required:[],files:{indexhtml:null,indexjs:{key:"indexjs",ext:"js",name:"index",contents:"function Queue () { \n    var collection = [];\n    this.print = function() {\n        console.log(collection);\n    };\n    // 请把你的代码写在这条注释以下\n\n    // 请把你的代码写在这条注释以上\n}",head:"",tail:""},indexjsx:null}}},pathContext:{challengeMeta:{introPath:"",template:null,required:[],nextChallengePath:"/coding-interview-prep/data-structures/create-a-priority-queue-class",id:"587d8250367417b2b2512c60"},slug:"/coding-interview-prep/data-structures/create-a-queue-class"}}}});
//# sourceMappingURL=path---coding-interview-prep-data-structures-create-a-queue-class-c147d659075ba0cd7276.js.map
webpackJsonp([0xca5d5519f718],{2856:function(e,t){e.exports={data:{challengeNode:{title:"Use Depth First Search in a Binary Search Tree",description:["我们已经了解了如何在二叉查找树当中找到一个值。但是如果我们只想遍历整棵树呢？或者我们想在一个乱序的树结构中找到一个值又该如何操作呢？接下来我们就介绍一些树的遍历算法。第一个方法就是深度优先（depth-first）查找方法。在深度优先查找当中，需要先走完（遍历完）当前子树，再去遍历下一个子树。我们有三种方式可以实现深度优先查找：","中序（in-order）：先访问最左端节点，然后访问根节点，最后访问最右端节点。","前序（pre-order）：先访问根节点，然后访问子树。","后序（post-order）：先访问子树，最后访问根节点。","我们应该根据树结构中存储数据的类型以及所要查找的值来选择不同的查找方法。对于二叉查找树，中序遍历会按大小顺序返回所有的节点值。","挑战说明：我们需要为二叉查找树添加这三个查找方法。深度优先查找本身就是一种递归操作，只要当前节点存在子节点，遍历就会一直进行到底。只要你能理解这个基本概念，你就可以调整遍历过程中节点的访问顺序，也就可以写出这三种查找方法。例如，在后序遍历中，我们在访问任何父级节点之前需要递归地遍历完它的所有子节点；然而在前序遍历中，遍历完节点的一个分支之后，我们需要先回到父节点，再递归地遍历它的另一个分支。","在树中定义<code>inorder</code>、<code>preorder</code>、<code>postorder</code>方法。三个方法都应该返回一个数组，该数组用于表示树的遍历结果。每个节点返回的都应该是整数值，而非节点本身。以及，如果树为空，那么三个方法都应该返回<code>null</code>。"],challengeType:1,fields:{slug:"/coding-interview-prep/data-structures/use-depth-first-search-in-a-binary-search-tree",blockName:"Data Structures",tests:[{text:"<code>BinarySearchTree</code>数据结构应该存在。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');"},{text:"<code>BinarySearchTree</code>应该有<code>inorder</code>方法。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.inorder == 'function')})(), '<code>BinarySearchTree</code>应该有<code>inorder</code>方法。');"},{text:"<code>BinarySearchTree</code>应该有<code>preorder</code>方法。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.preorder == 'function')})(), '<code>BinarySearchTree</code>应该有<code>preorder</code>方法。');"},{text:"<code>BinarySearchTree</code>应该有<code>postorder</code>方法。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.postorder == 'function')})(), '<code>BinarySearchTree</code>应该有<code>postorder</code>方法。');"},{text:"<code>inorder</code>方法应返回一个数组，该数组的元素值应是以中序遍历的方式存储进去的。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.inorder !== 'function') { return false; }; test.add(7); test.add(1); test.add(9); test.add(0); test.add(3); test.add(8); test.add(10); test.add(2); test.add(5); test.add(4); test.add(6); return (test.inorder().join('') == '012345678910'); })(), '<code>inorder</code>方法应返回一个数组，该数组的元素值应是以中序遍历的方式存储进去的。');"},{text:"<code>preorder</code>方法应返回一个数组，该数组的元素值应是以前序遍历的方式存储进去的。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.preorder !== 'function') { return false; }; test.add(7); test.add(1); test.add(9); test.add(0); test.add(3); test.add(8); test.add(10); test.add(2); test.add(5); test.add(4); test.add(6); return (test.preorder().join('') == '710325469810'); })(), '<code>preorder</code>方法应返回一个数组，该数组的元素值应是以前序遍历的方式存储进去的。');"},{text:"<code>postorder</code>方法应返回一个数组，该数组的元素值应是以后序遍历的方式存储进去的。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.postorder !== 'function') { return false; }; test.add(7); test.add(1); test.add(9); test.add(0); test.add(3); test.add(8); test.add(10); test.add(2); test.add(5); test.add(4); test.add(6); return (test.postorder().join('') == '024653181097'); })(), '<code>postorder</code>方法应返回一个数组，该数组的元素值应是以后序遍历的方式存储进去的。');"},{text:"当树为空时，<code>inorder</code>方法应返回<code>null</code>。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.inorder !== 'function') { return false; }; return (test.inorder() == null); })(), '当树为空时，<code>inorder</code>方法应返回<code>null</code>。');"},{text:"当树为空时，<code>preorder</code>方法应返回<code>null</code>。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.preorder !== 'function') { return false; }; return (test.preorder() == null); })(), '当树为空时，<code>preorder</code>方法应返回<code>null</code>。');"},{text:"当树为空时，<code>postorder</code>方法应返回<code>null</code>。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.postorder !== 'function') { return false; }; return (test.postorder() == null); })(), '当树为空时，<code>postorder</code>方法应返回<code>null</code>。');"}]},required:[],files:{indexhtml:null,indexjs:{key:"indexjs",ext:"js",name:"index",contents:"var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n}\nfunction BinarySearchTree() {\n    this.root = null;\n    // 请把你的代码写在这条注释以下\n    // 请把你的代码写在这条注释以上\n}",head:"",tail:"BinarySearchTree.prototype = {\n    add: function(value) {\n        var node = this.root;\n        if (node == null) {\n          this.root = new Node(value);\n          return;\n        } else {\n            function searchTree(node) {\n                if (value < node.value) {\n                    if (node.left == null) {\n                        node.left = new Node(value);\n                        return;\n                    } else if (node.left != null) {\n                        return searchTree(node.left)\n                    };\n                } else if (value > node.value) {\n                    if (node.right == null) {\n                        node.right = new Node(value);\n                        return;\n                    } else if (node.right != null) {\n                        return searchTree(node.right);\n                    };\n                } else {\n                    return null;\n                };\n            };\n            return searchTree(node);\n        };\n    }\n};"},indexjsx:null}}},pathContext:{challengeMeta:{introPath:"",template:null,required:[],nextChallengePath:"/coding-interview-prep/data-structures/use-breadth-first-search-in-a-binary-search-tree",id:"587d8257367417b2b2512c7e"},slug:"/coding-interview-prep/data-structures/use-depth-first-search-in-a-binary-search-tree"}}}});
//# sourceMappingURL=path---coding-interview-prep-data-structures-use-depth-first-search-in-a-binary-search-tree-f5ed69c2c662310e84e9.js.map
{"version":3,"sources":["webpack:///path---javascript-algorithms-and-data-structures-basic-data-structures-copy-array-items-using-slice-f0ad75e05ef8490c655e.js","webpack:///./.cache/json/javascript-algorithms-and-data-structures-basic-data-structures-copy-array-items-using-slice.json"],"names":["webpackJsonp","3741","module","exports","data","challengeNode","title","description","challengeType","fields","slug","blockName","tests","text","testString","required","files","indexhtml","indexjs","key","ext","name","contents","head","tail","indexjsx","pathContext","challengeMeta","introPath","template","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,iCAAAC,aAAA,6OAAiN,+QAAwQ,iMAAAC,cAAA,EAAAC,QAAwTC,KAAA,gGAAAC,UAAA,wBAAAC,QAAqJC,KAAA,oDAAAC,WAAA,yKAAqPD,KAAA,sDAAAC,WAAA,8FAAuKC,YAAAC,OAAwBC,UAAA,KAAAC,SAA4BC,IAAA,UAAAC,IAAA,KAAAC,KAAA,QAAAC,SAAA,8KAAiOC,KAAA,GAAAC,KAAA,IAAsBC,SAAA,QAAmBC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,KAAAd,YAAAe,kBAAA,0GAAAC,GAAA,4BAA2MrB,KAAA","file":"path---javascript-algorithms-and-data-structures-basic-data-structures-copy-array-items-using-slice-f0ad75e05ef8490c655e.js","sourcesContent":["webpackJsonp([159430238499677],{\n\n/***/ 3741:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Copy Array Items Using slice()\",\"description\":[\"接下来我们要介绍<code>slice()</code>方法。<code>slice()</code>并不修改数组，而是复制或者说<em>提取（extract）</em>给定数量的元素到一个新数组里，而调用方法的数组则保持不变。<code>slice()</code>只接受 2 个输入参数&mdash;第一个是开始提取元素的位置（索引），第二个是结束提取元素的位置（索引）。slice 方法会提取直到该索引的元素，但被提取的元素不包括该索引对应的元素。请看以下例子：\",\"<blockquote>let weatherConditions = ['rain', 'snow', 'sleet', 'hail', 'clear'];<br><br>let todaysWeather = weatherConditions.slice(1, 3);<br>// todaysWeather 等于 ['snow', 'sleet'];<br>// weatherConditions 仍然等于 ['rain', 'snow', 'sleet', 'hail', 'clear']<br></blockquote>\",\"现在我们从一个已有的数组中提取了一些元素，并用这些元素创建了一个新数组。\",\"<hr>\",\"我们已经定义了一个<code>forecast</code>函数，它接受一个数组作为参数。请修改这个函数，利用<code>slice()</code>来从输入的数组中提取信息，并返回一个包含元素<code>'warm'</code>和<code>'sunny'</code> 的新数组。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/javascript-algorithms-and-data-structures/basic-data-structures/copy-array-items-using-slice\",\"blockName\":\"Basic Data Structures\",\"tests\":[{\"text\":\"<code>forecast</code>应该返回<code>[\\\"warm\\\", \\\"sunny\\\"]。\",\"testString\":\"assert.deepEqual(forecast(['cold', 'rainy', 'warm', 'sunny', 'cool', 'thunderstorms']), ['warm', 'sunny'], '<code>forecast</code>应该返回<code>[\\\"warm\\\", \\\"sunny\\\"]。');\"},{\"text\":\"<code>forecast</code>函数中应该用到<code>slice()</code>方法。\",\"testString\":\"assert(/\\\\.slice\\\\(/.test(code), '<code>forecast</code>函数中应该用到<code>slice()</code>方法。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"function forecast(arr) {\\n  // 请把你的代码写在这条注释以下\\n  \\n  return arr;\\n}\\n\\n// 请不要修改本行以下的代码\\nconsole.log(forecast(['cold', 'rainy', 'warm', 'sunny', 'cool', 'thunderstorms']));\",\"head\":\"\",\"tail\":\"\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/javascript-algorithms-and-data-structures/basic-data-structures/copy-an-array-with-the-spread-operator\",\"id\":\"587d7b7a367417b2b2512b12\"},\"slug\":\"/javascript-algorithms-and-data-structures/basic-data-structures/copy-array-items-using-slice\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---javascript-algorithms-and-data-structures-basic-data-structures-copy-array-items-using-slice-f0ad75e05ef8490c655e.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Copy Array Items Using slice()\",\"description\":[\"接下来我们要介绍<code>slice()</code>方法。<code>slice()</code>并不修改数组，而是复制或者说<em>提取（extract）</em>给定数量的元素到一个新数组里，而调用方法的数组则保持不变。<code>slice()</code>只接受 2 个输入参数&mdash;第一个是开始提取元素的位置（索引），第二个是结束提取元素的位置（索引）。slice 方法会提取直到该索引的元素，但被提取的元素不包括该索引对应的元素。请看以下例子：\",\"<blockquote>let weatherConditions = ['rain', 'snow', 'sleet', 'hail', 'clear'];<br><br>let todaysWeather = weatherConditions.slice(1, 3);<br>// todaysWeather 等于 ['snow', 'sleet'];<br>// weatherConditions 仍然等于 ['rain', 'snow', 'sleet', 'hail', 'clear']<br></blockquote>\",\"现在我们从一个已有的数组中提取了一些元素，并用这些元素创建了一个新数组。\",\"<hr>\",\"我们已经定义了一个<code>forecast</code>函数，它接受一个数组作为参数。请修改这个函数，利用<code>slice()</code>来从输入的数组中提取信息，并返回一个包含元素<code>'warm'</code>和<code>'sunny'</code> 的新数组。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/javascript-algorithms-and-data-structures/basic-data-structures/copy-array-items-using-slice\",\"blockName\":\"Basic Data Structures\",\"tests\":[{\"text\":\"<code>forecast</code>应该返回<code>[\\\"warm\\\", \\\"sunny\\\"]。\",\"testString\":\"assert.deepEqual(forecast(['cold', 'rainy', 'warm', 'sunny', 'cool', 'thunderstorms']), ['warm', 'sunny'], '<code>forecast</code>应该返回<code>[\\\"warm\\\", \\\"sunny\\\"]。');\"},{\"text\":\"<code>forecast</code>函数中应该用到<code>slice()</code>方法。\",\"testString\":\"assert(/\\\\.slice\\\\(/.test(code), '<code>forecast</code>函数中应该用到<code>slice()</code>方法。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"function forecast(arr) {\\n  // 请把你的代码写在这条注释以下\\n  \\n  return arr;\\n}\\n\\n// 请不要修改本行以下的代码\\nconsole.log(forecast(['cold', 'rainy', 'warm', 'sunny', 'cool', 'thunderstorms']));\",\"head\":\"\",\"tail\":\"\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/javascript-algorithms-and-data-structures/basic-data-structures/copy-an-array-with-the-spread-operator\",\"id\":\"587d7b7a367417b2b2512b12\"},\"slug\":\"/javascript-algorithms-and-data-structures/basic-data-structures/copy-array-items-using-slice\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/javascript-algorithms-and-data-structures-basic-data-structures-copy-array-items-using-slice.json\n// module id = 3741\n// module chunks = 159430238499677"],"sourceRoot":""}
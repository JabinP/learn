{"version":3,"sources":["webpack:///path---coding-interview-prep-data-structures-typed-arrays-cffe95690bc1c5e1c5de.js","webpack:///./.cache/json/coding-interview-prep-data-structures-typed-arrays.json"],"names":["webpackJsonp","2854","module","exports","data","challengeNode","title","description","challengeType","fields","slug","blockName","tests","text","testString","required","files","indexhtml","indexjs","key","ext","name","contents","head","tail","indexjsx","pathContext","challengeMeta","introPath","template","nextChallengePath","id"],"mappings":"AAAAA,cAAc,gBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,eAAAC,aAAA,6GAAkJ,u4BAA82B,wdAA2d,mJAAkJ,2VAAAC,cAAA,EAAAC,QAAuZC,KAAA,sDAAAC,UAAA,kBAAAC,QAAqGC,KAAA,oCAAAC,WAAA,2EAAmID,KAAA,uCAAAC,WAAA,+EAA0ID,KAAA,sCAAAC,WAAA,2EAAoIC,YAAAC,OAAwBC,UAAA,KAAAC,SAA4BC,IAAA,UAAAC,IAAA,KAAAC,KAAA,QAAAC,SAAA,4BAA+EC,KAAA,GAAAC,KAAA,IAAsBC,SAAA,QAAmBC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,KAAAd,YAAAe,kBAAA,iEAAAC,GAAA,4BAAkKrB,KAAA","file":"path---coding-interview-prep-data-structures-typed-arrays-cffe95690bc1c5e1c5de.js","sourcesContent":["webpackJsonp([13051441015663],{\n\n/***/ 2854:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Typed Arrays\",\"description\":[\"数组是一种 JavaScript 对象，它能存储各种数据类型的元素。\",\"<code>var complexArr = [1, 5, \\\"2\\\", \\\"Word\\\", {\\\"name\\\": \\\"James\\\"}];</code>\",\"通常浏览器会自动地为数组分配合适的内存空间，同时内存大小也会随着你增删元素而发生变化。\",\"然而，在一些对性能有较高要求以及存在不同数据类型的场景下，我们需要更精确地给数组分配内存空间。\",\"<dfn>Typed arrays</dfn>就是解决这类问题的一种方案。我们可以精确地给一个数组分配内存空间。下面的表格列出了这种数组能够存放的数据类型以及不同数据类型所占据的字节数。\",\"<table class='table table-striped'><tr><th>类型</th><th>元素所占字节数</th></tr><tr><td><code>Int8Array</code></td><td>1</td></tr><tr><td><code>Uint8Array</code></td><td>1</td></tr><tr><td><code>Uint8ClampedArray</code></td><td>1</td></tr><tr><td><code>Int16Array</code></td><td>2</td></tr><tr><td><code>Uint16Array</code></td><td>2</td></tr><tr><td><code>Int32Array</code></td><td>4</td></tr><tr><td><code>Uint32Array</code></td><td>4</td></tr><tr><td><code>Float32Array</code></td><td>4</td></tr><tr><td><code>Float64Array</code></td><td>8</td></tr></table>\",\"创建这类数组有两种方式，一种是直接创建，如下代码创建了一个长度为 3 的 <code>Int16Array</code>：\",\"<blockquote>var i8 = new Int16Array(3);<br>console.log(i8);<br>// 输出 [0, 0, 0]</blockquote>\",\"我们也可以通过创建<dfn>buffer</dfn>的方式来决定一个数组要容纳多少元素（以 bytes 为单位）。\",\"<strong>注意：</strong><br>使用<code>ArrayBuffer</code>创建<code>Typed array</code>时，我们需要传入一个表示<code>ArrayBuffer</code>大小的数字。由于其单位为字节，因此它必须是偶数：\",\"<blockquote>// 用另一种方式创建和上面相同的 Int16Array<br>var byteSize = 6; // 必须是 2 的倍数<br>var buffer = new ArrayBuffer(byteSize);<br>var i8View = new Int16Array(buffer);<br>buffer.byteLength; // 输出 6<br>i8View.byteLength; // 输出 6<br>console.log(i8View); // 输出 [0, 0, 0]</blockquote>\",\"<dfn>Buffers</dfn>是存放数据的通用对象，你无法直接访问它们。若要访问它们。你需要先创建一个 view。\",\"<blockquote>i8View[0] = 42;<br>console.log(i8View); // 输出 [42, 0, 0]</blockquote>\",\"<strong>注意：</strong><br>Typed Arrays 没有<code>.pop()</code>或<code>.push()</code>这些传统数组拥有的方法。使用<code>Array.isArray()</code>方法对 Typed Arrays 做判断返回的是<code>false</code>，而非<code>true</code>。因为 Typed Arrays 的接口相对简洁，因此对 JavaScript 引擎来说，实现这类数组会更加容易。\",\"<hr>\",\"请先创建一个 64 个字节的<code>buffer</code>，再创建一个类型是<code>Int32Array</code>名称叫做<code>i32View</code>的视图。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/coding-interview-prep/data-structures/typed-arrays\",\"blockName\":\"Data Structures\",\"tests\":[{\"text\":\"<code>buffer</code>应该有 64 个字节的大小。\",\"testString\":\"assert(buffer.byteLength === 64, '<code>buffer</code>应该有 64 个字节的大小。');\"},{\"text\":\"<code>i32View</code>视图应该有 64 个字节的大小。\",\"testString\":\"assert(i32View.byteLength === 64, '<code>i32View</code>视图应该有 64 个字节的大小。');\"},{\"text\":\"<code>i32View</code>视图应该能容纳 16 个元素。\",\"testString\":\"assert(i32View.length === 16, '<code>i32View</code>视图应该能容纳 16 个元素。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"var buffer;\\nvar i32View;\",\"head\":\"\",\"tail\":\"\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/coding-interview-prep/data-structures/learn-how-a-stack-works\",\"id\":\"587d8253367417b2b2512c6a\"},\"slug\":\"/coding-interview-prep/data-structures/typed-arrays\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---coding-interview-prep-data-structures-typed-arrays-cffe95690bc1c5e1c5de.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Typed Arrays\",\"description\":[\"数组是一种 JavaScript 对象，它能存储各种数据类型的元素。\",\"<code>var complexArr = [1, 5, \\\"2\\\", \\\"Word\\\", {\\\"name\\\": \\\"James\\\"}];</code>\",\"通常浏览器会自动地为数组分配合适的内存空间，同时内存大小也会随着你增删元素而发生变化。\",\"然而，在一些对性能有较高要求以及存在不同数据类型的场景下，我们需要更精确地给数组分配内存空间。\",\"<dfn>Typed arrays</dfn>就是解决这类问题的一种方案。我们可以精确地给一个数组分配内存空间。下面的表格列出了这种数组能够存放的数据类型以及不同数据类型所占据的字节数。\",\"<table class='table table-striped'><tr><th>类型</th><th>元素所占字节数</th></tr><tr><td><code>Int8Array</code></td><td>1</td></tr><tr><td><code>Uint8Array</code></td><td>1</td></tr><tr><td><code>Uint8ClampedArray</code></td><td>1</td></tr><tr><td><code>Int16Array</code></td><td>2</td></tr><tr><td><code>Uint16Array</code></td><td>2</td></tr><tr><td><code>Int32Array</code></td><td>4</td></tr><tr><td><code>Uint32Array</code></td><td>4</td></tr><tr><td><code>Float32Array</code></td><td>4</td></tr><tr><td><code>Float64Array</code></td><td>8</td></tr></table>\",\"创建这类数组有两种方式，一种是直接创建，如下代码创建了一个长度为 3 的 <code>Int16Array</code>：\",\"<blockquote>var i8 = new Int16Array(3);<br>console.log(i8);<br>// 输出 [0, 0, 0]</blockquote>\",\"我们也可以通过创建<dfn>buffer</dfn>的方式来决定一个数组要容纳多少元素（以 bytes 为单位）。\",\"<strong>注意：</strong><br>使用<code>ArrayBuffer</code>创建<code>Typed array</code>时，我们需要传入一个表示<code>ArrayBuffer</code>大小的数字。由于其单位为字节，因此它必须是偶数：\",\"<blockquote>// 用另一种方式创建和上面相同的 Int16Array<br>var byteSize = 6; // 必须是 2 的倍数<br>var buffer = new ArrayBuffer(byteSize);<br>var i8View = new Int16Array(buffer);<br>buffer.byteLength; // 输出 6<br>i8View.byteLength; // 输出 6<br>console.log(i8View); // 输出 [0, 0, 0]</blockquote>\",\"<dfn>Buffers</dfn>是存放数据的通用对象，你无法直接访问它们。若要访问它们。你需要先创建一个 view。\",\"<blockquote>i8View[0] = 42;<br>console.log(i8View); // 输出 [42, 0, 0]</blockquote>\",\"<strong>注意：</strong><br>Typed Arrays 没有<code>.pop()</code>或<code>.push()</code>这些传统数组拥有的方法。使用<code>Array.isArray()</code>方法对 Typed Arrays 做判断返回的是<code>false</code>，而非<code>true</code>。因为 Typed Arrays 的接口相对简洁，因此对 JavaScript 引擎来说，实现这类数组会更加容易。\",\"<hr>\",\"请先创建一个 64 个字节的<code>buffer</code>，再创建一个类型是<code>Int32Array</code>名称叫做<code>i32View</code>的视图。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/coding-interview-prep/data-structures/typed-arrays\",\"blockName\":\"Data Structures\",\"tests\":[{\"text\":\"<code>buffer</code>应该有 64 个字节的大小。\",\"testString\":\"assert(buffer.byteLength === 64, '<code>buffer</code>应该有 64 个字节的大小。');\"},{\"text\":\"<code>i32View</code>视图应该有 64 个字节的大小。\",\"testString\":\"assert(i32View.byteLength === 64, '<code>i32View</code>视图应该有 64 个字节的大小。');\"},{\"text\":\"<code>i32View</code>视图应该能容纳 16 个元素。\",\"testString\":\"assert(i32View.length === 16, '<code>i32View</code>视图应该能容纳 16 个元素。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"var buffer;\\nvar i32View;\",\"head\":\"\",\"tail\":\"\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/coding-interview-prep/data-structures/learn-how-a-stack-works\",\"id\":\"587d8253367417b2b2512c6a\"},\"slug\":\"/coding-interview-prep/data-structures/typed-arrays\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/coding-interview-prep-data-structures-typed-arrays.json\n// module id = 2854\n// module chunks = 13051441015663"],"sourceRoot":""}
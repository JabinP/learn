{"version":3,"sources":["webpack:///path---front-end-libraries-react-give-sibling-elements-a-unique-key-attribute-fb98c8277fa49d5c9acd.js","webpack:///./.cache/json/front-end-libraries-react-give-sibling-elements-a-unique-key-attribute.json"],"names":["webpackJsonp","3582","module","exports","data","challengeNode","title","description","challengeType","fields","slug","blockName","tests","text","testString","required","link","raw","src","files","indexhtml","indexjs","indexjsx","key","ext","name","contents","head","tail","pathContext","challengeMeta","introPath","template","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,+CAAAC,aAAA,igBAAAC,cAAA,EAAAC,QAAmmBC,KAAA,0EAAAC,UAAA,QAAAC,QAA+GC,KAAA,wCAAAC,WAAA,oIAAgMD,KAAA,kDAAAC,WAAA,sIAA4MD,KAAA,kDAAAC,WAAA,sIAA4MD,KAAA,+CAAAC,WAAA,8SAAiXD,KAAA,sCAAAC,WAAA,yTAAkXC,WAAcC,KAAA,KAAAC,IAAA,KAAAC,IAAA,+DAA4FF,KAAA,KAAAC,IAAA,KAAAC,IAAA,uEAAkGC,OAAWC,UAAA,KAAAC,QAAA,KAAAC,UAA4CC,IAAA,WAAAC,IAAA,MAAAC,KAAA,QAAAC,SAAA,6VAAkZC,KAAA,GAAAC,KAAA,uEAAyFC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,qFAAsGjB,WAAsBC,KAAA,KAAAC,IAAA,KAAAC,IAAA,+DAA4FF,KAAA,KAAAC,IAAA,KAAAC,IAAA,uEAAkGe,kBAAA,6EAAAC,GAAA,4BAAmIxB,KAAA","file":"path---front-end-libraries-react-give-sibling-elements-a-unique-key-attribute-fb98c8277fa49d5c9acd.js","sourcesContent":["webpackJsonp([171084004378206],{\n\n/***/ 3582:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Give Sibling Elements a Unique Key Attribute\",\"description\":[\"上一个挑战展示了如何使用<code>map</code>方法根据用户输入动态渲染多个元素。然而，这个例子中缺少一个重要的部分。创建元素数组时，每个元素都需要一个设置为唯一值的<code>key</code>属性。React 使用这些键来跟踪哪些项目被添加、更改或删除。这有助于在以任何方式修改列表时提高重新渲染过程的效率。请注意，键只需要在同级元素之间是唯一的，它们不需要在应用程序中是全局唯一的。\",\"<hr>\",\"代码编辑器有一个数组，它包含一些前端框架和一个名为<code>Frameworks()</code>的无状态函数组件。<code>Frameworks()</code>需要将数组映射到无序列表，就像上一个挑战一样。完成<code>map</code>回调，为<code>frontEndFrameworks</code>数组中的每个框架返回一个<code>li</code>元素。这次，确保给每个<code>li</code>的<code>key</code>属性设置一个唯一的值。\",\"通常，你希望使 key 能唯一标识要渲染的元素。作为最后的手段，可以使用数组索引，但通常你应该尝试使用唯一标识。\"],\"challengeType\":6,\"fields\":{\"slug\":\"/front-end-libraries/react/give-sibling-elements-a-unique-key-attribute\",\"blockName\":\"React\",\"tests\":[{\"text\":\"<code>Frameworks</code> 组件应该存在并渲染到页面。\",\"testString\":\"assert(Enzyme.mount(React.createElement(Frameworks)).find('Frameworks').length === 1, '<code>Frameworks</code> 组件应该存在并渲染到页面。');\"},{\"text\":\"<code>Frameworks</code>应该渲染一个<code>h1</code>元素。\",\"testString\":\"assert(Enzyme.mount(React.createElement(Frameworks)).find('h1').length === 1, '<code>Frameworks</code>应该渲染一个<code>h1</code>元素。');\"},{\"text\":\"<code>Frameworks</code>应该渲染一个<code>ul</code>元素。\",\"testString\":\"assert(Enzyme.mount(React.createElement(Frameworks)).find('ul').length === 1, '<code>Frameworks</code>应该渲染一个<code>ul</code>元素。');\"},{\"text\":\"<code>ul</code>标签应该渲染 6 个<code>li</code>子元素。\",\"testString\":\"assert(Enzyme.mount(React.createElement(Frameworks)).find('ul').children().length === 6 && Enzyme.mount(React.createElement(Frameworks)).find('ul').childAt(0).name() === 'li' && Enzyme.mount(React.createElement(Frameworks)).find('li').length === 6, '<code>ul</code>标签应该渲染 6 个<code>li</code>子元素。');\"},{\"text\":\"每个列表项元素都应该有一个唯一的<code>key</code>属性。\",\"testString\":\"assert((() => { const ul = Enzyme.mount(React.createElement(Frameworks)).find('ul'); const keys = new Set([ ul.childAt(0).key(), ul.childAt(1).key(), ul.childAt(2).key(), ul.childAt(3).key(), ul.childAt(4).key(), ul.childAt(5).key(), ]); return keys.size === 6; })(), '每个列表项元素都应该有一个唯一的<code>key</code>属性。');\"}]},\"required\":[{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react@16.4.0/umd/react.production.min.js\"},{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react-dom@16.4.0/umd/react-dom.production.min.js\"}],\"files\":{\"indexhtml\":null,\"indexjs\":null,\"indexjsx\":{\"key\":\"indexjsx\",\"ext\":\"jsx\",\"name\":\"index\",\"contents\":\"\\nconst frontEndFrameworks = [\\n  'React',\\n  'Angular',\\n  'Ember',\\n  'Knockout',\\n  'Backbone',\\n  'Vue'\\n];\\n\\nfunction Frameworks() {\\n  const renderFrameworks = null; // change code here\\n  return (\\n    <div>\\n      <h1>Popular Front End JavaScript Frameworks</h1>\\n      <ul>\\n        {renderFrameworks}\\n      </ul>\\n    </div>\\n  );\\n};\",\"head\":\"\",\"tail\":\"ReactDOM.render(<Frameworks />, document.getElementById('root'))\"}}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":\"<body><div id='root'></div><div id='challenge-node'></div>${ source || '' }</body>\",\"required\":[{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react@16.4.0/umd/react.production.min.js\"},{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react-dom@16.4.0/umd/react-dom.production.min.js\"}],\"nextChallengePath\":\"/front-end-libraries/react/use-array-filter-to-dynamically-filter-an-array\",\"id\":\"5a24c314108439a4d403618b\"},\"slug\":\"/front-end-libraries/react/give-sibling-elements-a-unique-key-attribute\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---front-end-libraries-react-give-sibling-elements-a-unique-key-attribute-fb98c8277fa49d5c9acd.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Give Sibling Elements a Unique Key Attribute\",\"description\":[\"上一个挑战展示了如何使用<code>map</code>方法根据用户输入动态渲染多个元素。然而，这个例子中缺少一个重要的部分。创建元素数组时，每个元素都需要一个设置为唯一值的<code>key</code>属性。React 使用这些键来跟踪哪些项目被添加、更改或删除。这有助于在以任何方式修改列表时提高重新渲染过程的效率。请注意，键只需要在同级元素之间是唯一的，它们不需要在应用程序中是全局唯一的。\",\"<hr>\",\"代码编辑器有一个数组，它包含一些前端框架和一个名为<code>Frameworks()</code>的无状态函数组件。<code>Frameworks()</code>需要将数组映射到无序列表，就像上一个挑战一样。完成<code>map</code>回调，为<code>frontEndFrameworks</code>数组中的每个框架返回一个<code>li</code>元素。这次，确保给每个<code>li</code>的<code>key</code>属性设置一个唯一的值。\",\"通常，你希望使 key 能唯一标识要渲染的元素。作为最后的手段，可以使用数组索引，但通常你应该尝试使用唯一标识。\"],\"challengeType\":6,\"fields\":{\"slug\":\"/front-end-libraries/react/give-sibling-elements-a-unique-key-attribute\",\"blockName\":\"React\",\"tests\":[{\"text\":\"<code>Frameworks</code> 组件应该存在并渲染到页面。\",\"testString\":\"assert(Enzyme.mount(React.createElement(Frameworks)).find('Frameworks').length === 1, '<code>Frameworks</code> 组件应该存在并渲染到页面。');\"},{\"text\":\"<code>Frameworks</code>应该渲染一个<code>h1</code>元素。\",\"testString\":\"assert(Enzyme.mount(React.createElement(Frameworks)).find('h1').length === 1, '<code>Frameworks</code>应该渲染一个<code>h1</code>元素。');\"},{\"text\":\"<code>Frameworks</code>应该渲染一个<code>ul</code>元素。\",\"testString\":\"assert(Enzyme.mount(React.createElement(Frameworks)).find('ul').length === 1, '<code>Frameworks</code>应该渲染一个<code>ul</code>元素。');\"},{\"text\":\"<code>ul</code>标签应该渲染 6 个<code>li</code>子元素。\",\"testString\":\"assert(Enzyme.mount(React.createElement(Frameworks)).find('ul').children().length === 6 && Enzyme.mount(React.createElement(Frameworks)).find('ul').childAt(0).name() === 'li' && Enzyme.mount(React.createElement(Frameworks)).find('li').length === 6, '<code>ul</code>标签应该渲染 6 个<code>li</code>子元素。');\"},{\"text\":\"每个列表项元素都应该有一个唯一的<code>key</code>属性。\",\"testString\":\"assert((() => { const ul = Enzyme.mount(React.createElement(Frameworks)).find('ul'); const keys = new Set([ ul.childAt(0).key(), ul.childAt(1).key(), ul.childAt(2).key(), ul.childAt(3).key(), ul.childAt(4).key(), ul.childAt(5).key(), ]); return keys.size === 6; })(), '每个列表项元素都应该有一个唯一的<code>key</code>属性。');\"}]},\"required\":[{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react@16.4.0/umd/react.production.min.js\"},{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react-dom@16.4.0/umd/react-dom.production.min.js\"}],\"files\":{\"indexhtml\":null,\"indexjs\":null,\"indexjsx\":{\"key\":\"indexjsx\",\"ext\":\"jsx\",\"name\":\"index\",\"contents\":\"\\nconst frontEndFrameworks = [\\n  'React',\\n  'Angular',\\n  'Ember',\\n  'Knockout',\\n  'Backbone',\\n  'Vue'\\n];\\n\\nfunction Frameworks() {\\n  const renderFrameworks = null; // change code here\\n  return (\\n    <div>\\n      <h1>Popular Front End JavaScript Frameworks</h1>\\n      <ul>\\n        {renderFrameworks}\\n      </ul>\\n    </div>\\n  );\\n};\",\"head\":\"\",\"tail\":\"ReactDOM.render(<Frameworks />, document.getElementById('root'))\"}}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":\"<body><div id='root'></div><div id='challenge-node'></div>${ source || '' }</body>\",\"required\":[{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react@16.4.0/umd/react.production.min.js\"},{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react-dom@16.4.0/umd/react-dom.production.min.js\"}],\"nextChallengePath\":\"/front-end-libraries/react/use-array-filter-to-dynamically-filter-an-array\",\"id\":\"5a24c314108439a4d403618b\"},\"slug\":\"/front-end-libraries/react/give-sibling-elements-a-unique-key-attribute\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/front-end-libraries-react-give-sibling-elements-a-unique-key-attribute.json\n// module id = 3582\n// module chunks = 171084004378206"],"sourceRoot":""}
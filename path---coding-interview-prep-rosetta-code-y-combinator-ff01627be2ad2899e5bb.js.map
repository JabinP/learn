{"version":3,"sources":["webpack:///path---coding-interview-prep-rosetta-code-y-combinator-ff01627be2ad2899e5bb.js","webpack:///./.cache/json/coding-interview-prep-rosetta-code-y-combinator.json"],"names":["webpackJsonp","3425","module","exports","data","challengeNode","title","description","challengeType","fields","slug","blockName","tests","text","testString","required","files","indexhtml","indexjs","key","ext","name","contents","head","tail","indexjsx","pathContext","challengeMeta","introPath","template","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,eAAAC,aAAA,wzCAAAC,cAAA,EAAAC,QAA84CC,KAAA,mDAAAC,UAAA,eAAAC,QAA+FC,KAAA,2BAAAC,WAAA,iFAAgID,KAAA,8BAAAC,WAAA,kEAAoHD,KAAA,8BAAAC,WAAA,kEAAoHD,KAAA,8BAAAC,WAAA,kEAAoHD,KAAA,+BAAAC,WAAA,oEAAuHD,KAAA,qCAAAC,WAAA,iFAAyIC,YAAAC,OAAwBC,UAAA,KAAAC,SAA4BC,IAAA,UAAAC,IAAA,KAAAC,KAAA,QAAAC,SAAA,gLAAmOC,KAAA,GAAAC,KAAA,4DAA8EC,SAAA,QAAmBC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,KAAAd,YAAAe,kBAAA,uEAAAC,GAAA,4BAAwKrB,KAAA","file":"path---coding-interview-prep-rosetta-code-y-combinator-ff01627be2ad2899e5bb.js","sourcesContent":["webpackJsonp([195852070625684],{\n\n/***/ 3425:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Y combinator\",\"description\":[\"<p>\",\"In strict \",\"<a href=\\\"https://en.wikipedia.org/wiki/Functional programming\\\" title=\\\"wp: functional programming\\\">functional programming</a> and\",\"the <a href=\\\"https://en.wikipedia.org/wiki/lambda calculus\\\" title=\\\"wp: lambda calculus\\\">lambda calculus</a>, \",\"functions (lambda expressions) don't have state and are only allowed to refer to arguments of enclosing functions. \",\"This rules out the usual definition of a recursive function wherein a function is associated with the state of a variable and this variable's state is used in the body of the function.\",\"</p>\",\"<p>\",\"The <a href=\\\"http://mvanier.livejournal.com/2897.html\\\">Y combinator</a> is itself a stateless function that,\",\"when applied to another stateless function, returns a recursive version of the function. The Y combinator is\",\"the simplest of the class of such functions, called \",\"<a href=\\\"https://en.wikipedia.org/wiki/Fixed-point combinator\\\" title=\\\"wp: fixed-point combinator\\\">fixed-point combinators</a>.\",\"</p>\",\"Task:\",\"\",\"    Define the stateless Y combinator function and use it to compute\",\"    <a href=\\\"https://en.wikipedia.org/wiki/Factorial\\\" title=\\\"wp: factorial\\\">factorial</a>.\",\"\",\"<code>factorial(N)</code> function is already given to you.\",\"See also <a href=\\\"http://vimeo.com/45140590\\\">Jim Weirich: Adventures in Functional Programming</a>.\"],\"challengeType\":5,\"fields\":{\"slug\":\"/coding-interview-prep/rosetta-code/y-combinator\",\"blockName\":\"Rosetta Code\",\"tests\":[{\"text\":\"Y must return a function\",\"testString\":\"assert.equal(typeof Y(f => n => n), 'function', 'Y must return a function');\"},{\"text\":\"factorial(1) must return 1.\",\"testString\":\"assert.equal(factorial(1), 1, 'factorial(1) must return 1.');\"},{\"text\":\"factorial(2) must return 2.\",\"testString\":\"assert.equal(factorial(2), 2, 'factorial(2) must return 2.');\"},{\"text\":\"factorial(3) must return 6.\",\"testString\":\"assert.equal(factorial(3), 6, 'factorial(3) must return 6.');\"},{\"text\":\"factorial(4) must return 24.\",\"testString\":\"assert.equal(factorial(4), 24, 'factorial(4) must return 24.');\"},{\"text\":\"factorial(10) must return 3628800.\",\"testString\":\"assert.equal(factorial(10), 3628800, 'factorial(10) must return 3628800.');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"function Y(f) {\\n  return function() {\\n  // Good luck!\\n  };\\n}\\n\\nvar factorial = Y(function(f) {\\n  return function (n) {\\n    return n > 1 ? n * f(n - 1) : 1;\\n  };\\n});\",\"head\":\"\",\"tail\":\"var factorial = Y(f => n => (n > 1 ? n * f(n - 1) : 1));\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/coding-interview-prep/rosetta-code/zeckendorf-number-representation\",\"id\":\"594810f028c0303b75339ad5\"},\"slug\":\"/coding-interview-prep/rosetta-code/y-combinator\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---coding-interview-prep-rosetta-code-y-combinator-ff01627be2ad2899e5bb.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Y combinator\",\"description\":[\"<p>\",\"In strict \",\"<a href=\\\"https://en.wikipedia.org/wiki/Functional programming\\\" title=\\\"wp: functional programming\\\">functional programming</a> and\",\"the <a href=\\\"https://en.wikipedia.org/wiki/lambda calculus\\\" title=\\\"wp: lambda calculus\\\">lambda calculus</a>, \",\"functions (lambda expressions) don't have state and are only allowed to refer to arguments of enclosing functions. \",\"This rules out the usual definition of a recursive function wherein a function is associated with the state of a variable and this variable's state is used in the body of the function.\",\"</p>\",\"<p>\",\"The <a href=\\\"http://mvanier.livejournal.com/2897.html\\\">Y combinator</a> is itself a stateless function that,\",\"when applied to another stateless function, returns a recursive version of the function. The Y combinator is\",\"the simplest of the class of such functions, called \",\"<a href=\\\"https://en.wikipedia.org/wiki/Fixed-point combinator\\\" title=\\\"wp: fixed-point combinator\\\">fixed-point combinators</a>.\",\"</p>\",\"Task:\",\"\",\"    Define the stateless Y combinator function and use it to compute\",\"    <a href=\\\"https://en.wikipedia.org/wiki/Factorial\\\" title=\\\"wp: factorial\\\">factorial</a>.\",\"\",\"<code>factorial(N)</code> function is already given to you.\",\"See also <a href=\\\"http://vimeo.com/45140590\\\">Jim Weirich: Adventures in Functional Programming</a>.\"],\"challengeType\":5,\"fields\":{\"slug\":\"/coding-interview-prep/rosetta-code/y-combinator\",\"blockName\":\"Rosetta Code\",\"tests\":[{\"text\":\"Y must return a function\",\"testString\":\"assert.equal(typeof Y(f => n => n), 'function', 'Y must return a function');\"},{\"text\":\"factorial(1) must return 1.\",\"testString\":\"assert.equal(factorial(1), 1, 'factorial(1) must return 1.');\"},{\"text\":\"factorial(2) must return 2.\",\"testString\":\"assert.equal(factorial(2), 2, 'factorial(2) must return 2.');\"},{\"text\":\"factorial(3) must return 6.\",\"testString\":\"assert.equal(factorial(3), 6, 'factorial(3) must return 6.');\"},{\"text\":\"factorial(4) must return 24.\",\"testString\":\"assert.equal(factorial(4), 24, 'factorial(4) must return 24.');\"},{\"text\":\"factorial(10) must return 3628800.\",\"testString\":\"assert.equal(factorial(10), 3628800, 'factorial(10) must return 3628800.');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"function Y(f) {\\n  return function() {\\n  // Good luck!\\n  };\\n}\\n\\nvar factorial = Y(function(f) {\\n  return function (n) {\\n    return n > 1 ? n * f(n - 1) : 1;\\n  };\\n});\",\"head\":\"\",\"tail\":\"var factorial = Y(f => n => (n > 1 ? n * f(n - 1) : 1));\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/coding-interview-prep/rosetta-code/zeckendorf-number-representation\",\"id\":\"594810f028c0303b75339ad5\"},\"slug\":\"/coding-interview-prep/rosetta-code/y-combinator\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/coding-interview-prep-rosetta-code-y-combinator.json\n// module id = 3425\n// module chunks = 195852070625684"],"sourceRoot":""}
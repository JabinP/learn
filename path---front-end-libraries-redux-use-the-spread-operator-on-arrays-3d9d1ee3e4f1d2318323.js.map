{"version":3,"sources":["webpack:///path---front-end-libraries-redux-use-the-spread-operator-on-arrays-3d9d1ee3e4f1d2318323.js","webpack:///./.cache/json/front-end-libraries-redux-use-the-spread-operator-on-arrays.json"],"names":["webpackJsonp","3630","module","exports","data","challengeNode","title","description","challengeType","fields","slug","blockName","tests","text","testString","required","link","raw","src","files","indexhtml","indexjs","indexjsx","key","ext","name","contents","head","tail","pathContext","challengeMeta","introPath","template","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,oCAAAC,aAAA,waAA0d,+3BAAAC,cAAA,EAAAC,QAAo6BC,KAAA,+DAAAC,UAAA,QAAAC,QAAoGC,KAAA,yGAAAC,WAAA,+QAA4YD,KAAA,mFAAAC,WAAA,yKAAgRD,KAAA,2IAAAC,WAAA,idAAgnBD,KAAA,0DAAAC,WAAA,oIAAiNC,WAAcC,KAAA,KAAAC,IAAA,KAAAC,IAAA,oEAAiGF,KAAA,KAAAC,IAAA,KAAAC,IAAA,gFAA2GC,OAAWC,UAAA,KAAAC,QAAA,KAAAC,UAA4CC,IAAA,WAAAC,IAAA,MAAAC,KAAA,QAAAC,SAAA,yXAA8aC,KAAA,GAAAC,KAAA,OAAyBC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,KAAAjB,WAA4CC,KAAA,KAAAC,IAAA,KAAAC,IAAA,oEAAiGF,KAAA,KAAAC,IAAA,KAAAC,IAAA,gFAA2Ge,kBAAA,0DAAAC,GAAA,4BAAgHxB,KAAA","file":"path---front-end-libraries-redux-use-the-spread-operator-on-arrays-3d9d1ee3e4f1d2318323.js","sourcesContent":["webpackJsonp([279909309633826],{\n\n/***/ 3630:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Use the Spread Operator on Arrays\",\"description\":[\"One solution from ES6 to help enforce state immutability in Redux is the spread operator: <code>...</code>. The spread operator has a variety of applications, one of which is well-suited to the previous challenge of producing a new array from an existing array. This is relatively new, but commonly used syntax. For example, if you have an array <code>myArray</code> and write:\",\"<code>let newArray = [...myArray];</code>\",\"<code>newArray</code> is now a clone of <code>myArray</code>. Both arrays still exist separately in memory. If you perform a mutation like <code>newArray.push(5)</code>, <code>myArray</code> doesn't change. The <code>...</code> effectively <i>spreads</i> out the values in <code>myArray</code> into a new array. To clone an array but add additional values in the new array, you could write <code>[...myArray, 'new value']</code>. This would return a new array composed of the values in <code>myArray</code> and the string <code>'new value'</code> as the last value. The spread syntax can be used multiple times in array composition like this, but it's important to note that it only makes a shallow copy of the array. That is to say, it only provides immutable array operations for one-dimensional arrays.\",\"<hr>\",\"Use the spread operator to return a new copy of state when a to-do is added.\"],\"challengeType\":6,\"fields\":{\"slug\":\"/front-end-libraries/redux/use-the-spread-operator-on-arrays\",\"blockName\":\"Redux\",\"tests\":[{\"text\":\"The Redux store should exist and initialize with a state equal to <code>[Do not mutate state!]</code>.\",\"testString\":\"assert((function() { const initialState = store.getState(); return ( Array.isArray(initialState) === true && initialState[0] === 'Do not mutate state!'); })(), 'The Redux store should exist and initialize with a state equal to <code>[Do not mutate state!]</code>.');\"},{\"text\":\"<code>addToDo</code> and <code>immutableReducer</code> both should be functions.\",\"testString\":\"assert(typeof addToDo === 'function' && typeof immutableReducer === 'function', '<code>addToDo</code> and <code>immutableReducer</code> both should be functions.');\"},{\"text\":\"Dispatching an action of type <code>ADD_TO_DO</code> on the Redux store should add a <code>todo</code> item and should NOT mutate state.\",\"testString\":\"assert((function() { const initialState = store.getState(); const isFrozen = DeepFreeze(initialState); store.dispatch(addToDo('__TEST__TO__DO__')); const finalState = store.getState(); const expectedState = [ 'Do not mutate state!', '__TEST__TO__DO__' ]; return( isFrozen && DeepEqual(finalState, expectedState)); })(), 'Dispatching an action of type <code>ADD_TO_DO</code> on the Redux store should add a <code>todo</code> item and should NOT mutate state.');\"},{\"text\":\"The spread operator should be used to return new state.\",\"testString\":\"getUserInput => assert(getUserInput('index').includes('...state'), 'The spread operator should be used to return new state.');\"}]},\"required\":[{\"link\":null,\"raw\":null,\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js\"},{\"link\":null,\"raw\":null,\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/redux-thunk/2.2.0/redux-thunk.min.js\"}],\"files\":{\"indexhtml\":null,\"indexjs\":null,\"indexjsx\":{\"key\":\"indexjsx\",\"ext\":\"jsx\",\"name\":\"index\",\"contents\":\"const immutableReducer = (state = ['Do not mutate state!'], action) => {\\n  switch(action.type) {\\n    case 'ADD_TO_DO':\\n      // don't mutate state here or the tests will fail\\n      return\\n    default:\\n      return state;\\n  }\\n};\\n\\nconst addToDo = (todo) => {\\n  return {\\n    type: 'ADD_TO_DO',\\n    todo\\n  }\\n}\\n\\nconst store = Redux.createStore(immutableReducer);\",\"head\":\"\",\"tail\":\"\"}}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[{\"link\":null,\"raw\":null,\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js\"},{\"link\":null,\"raw\":null,\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/redux-thunk/2.2.0/redux-thunk.min.js\"}],\"nextChallengePath\":\"/front-end-libraries/redux/remove-an-item-from-an-array\",\"id\":\"5a24c314108439a4d4036159\"},\"slug\":\"/front-end-libraries/redux/use-the-spread-operator-on-arrays\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---front-end-libraries-redux-use-the-spread-operator-on-arrays-3d9d1ee3e4f1d2318323.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Use the Spread Operator on Arrays\",\"description\":[\"One solution from ES6 to help enforce state immutability in Redux is the spread operator: <code>...</code>. The spread operator has a variety of applications, one of which is well-suited to the previous challenge of producing a new array from an existing array. This is relatively new, but commonly used syntax. For example, if you have an array <code>myArray</code> and write:\",\"<code>let newArray = [...myArray];</code>\",\"<code>newArray</code> is now a clone of <code>myArray</code>. Both arrays still exist separately in memory. If you perform a mutation like <code>newArray.push(5)</code>, <code>myArray</code> doesn't change. The <code>...</code> effectively <i>spreads</i> out the values in <code>myArray</code> into a new array. To clone an array but add additional values in the new array, you could write <code>[...myArray, 'new value']</code>. This would return a new array composed of the values in <code>myArray</code> and the string <code>'new value'</code> as the last value. The spread syntax can be used multiple times in array composition like this, but it's important to note that it only makes a shallow copy of the array. That is to say, it only provides immutable array operations for one-dimensional arrays.\",\"<hr>\",\"Use the spread operator to return a new copy of state when a to-do is added.\"],\"challengeType\":6,\"fields\":{\"slug\":\"/front-end-libraries/redux/use-the-spread-operator-on-arrays\",\"blockName\":\"Redux\",\"tests\":[{\"text\":\"The Redux store should exist and initialize with a state equal to <code>[Do not mutate state!]</code>.\",\"testString\":\"assert((function() { const initialState = store.getState(); return ( Array.isArray(initialState) === true && initialState[0] === 'Do not mutate state!'); })(), 'The Redux store should exist and initialize with a state equal to <code>[Do not mutate state!]</code>.');\"},{\"text\":\"<code>addToDo</code> and <code>immutableReducer</code> both should be functions.\",\"testString\":\"assert(typeof addToDo === 'function' && typeof immutableReducer === 'function', '<code>addToDo</code> and <code>immutableReducer</code> both should be functions.');\"},{\"text\":\"Dispatching an action of type <code>ADD_TO_DO</code> on the Redux store should add a <code>todo</code> item and should NOT mutate state.\",\"testString\":\"assert((function() { const initialState = store.getState(); const isFrozen = DeepFreeze(initialState); store.dispatch(addToDo('__TEST__TO__DO__')); const finalState = store.getState(); const expectedState = [ 'Do not mutate state!', '__TEST__TO__DO__' ]; return( isFrozen && DeepEqual(finalState, expectedState)); })(), 'Dispatching an action of type <code>ADD_TO_DO</code> on the Redux store should add a <code>todo</code> item and should NOT mutate state.');\"},{\"text\":\"The spread operator should be used to return new state.\",\"testString\":\"getUserInput => assert(getUserInput('index').includes('...state'), 'The spread operator should be used to return new state.');\"}]},\"required\":[{\"link\":null,\"raw\":null,\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js\"},{\"link\":null,\"raw\":null,\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/redux-thunk/2.2.0/redux-thunk.min.js\"}],\"files\":{\"indexhtml\":null,\"indexjs\":null,\"indexjsx\":{\"key\":\"indexjsx\",\"ext\":\"jsx\",\"name\":\"index\",\"contents\":\"const immutableReducer = (state = ['Do not mutate state!'], action) => {\\n  switch(action.type) {\\n    case 'ADD_TO_DO':\\n      // don't mutate state here or the tests will fail\\n      return\\n    default:\\n      return state;\\n  }\\n};\\n\\nconst addToDo = (todo) => {\\n  return {\\n    type: 'ADD_TO_DO',\\n    todo\\n  }\\n}\\n\\nconst store = Redux.createStore(immutableReducer);\",\"head\":\"\",\"tail\":\"\"}}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[{\"link\":null,\"raw\":null,\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js\"},{\"link\":null,\"raw\":null,\"src\":\"https://cdnjs.cloudflare.com/ajax/libs/redux-thunk/2.2.0/redux-thunk.min.js\"}],\"nextChallengePath\":\"/front-end-libraries/redux/remove-an-item-from-an-array\",\"id\":\"5a24c314108439a4d4036159\"},\"slug\":\"/front-end-libraries/redux/use-the-spread-operator-on-arrays\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/front-end-libraries-redux-use-the-spread-operator-on-arrays.json\n// module id = 3630\n// module chunks = 279909309633826"],"sourceRoot":""}
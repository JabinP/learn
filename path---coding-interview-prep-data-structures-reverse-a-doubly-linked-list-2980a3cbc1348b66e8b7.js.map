{"version":3,"sources":["webpack:///path---coding-interview-prep-data-structures-reverse-a-doubly-linked-list-2980a3cbc1348b66e8b7.js","webpack:///./.cache/json/coding-interview-prep-data-structures-reverse-a-doubly-linked-list.json"],"names":["webpackJsonp","2851","module","exports","data","challengeNode","title","description","challengeType","fields","slug","blockName","tests","text","testString","required","files","indexhtml","indexjs","key","ext","name","contents","head","tail","indexjsx","pathContext","challengeMeta","introPath","template","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,+BAAAC,aAAA,+JAAAC,cAAA,EAAAC,QAAiPC,KAAA,sEAAAC,UAAA,kBAAAC,QAAqHC,KAAA,YAAAC,WAAA,+KAA+MD,KAAA,kBAAAC,WAAA,0OAAgRD,KAAA,sBAAAC,WAAA,sPAAgSD,KAAA,sBAAAC,WAAA,0LAAoOD,KAAA,qBAAAC,WAAA,8PAAuSD,KAAA,4CAAAC,WAAA,6RAA4VC,YAAAC,OAAwBC,UAAA,KAAAC,SAA4BC,IAAA,UAAAC,IAAA,KAAAC,KAAA,QAAAC,SAAA,oOAAuRC,KAAA,GAAAC,KAAA,giCAAkjCC,SAAA,QAAmBC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,KAAAd,YAAAe,kBAAA,oGAAAC,GAAA,4BAAqMrB,KAAA","file":"path---coding-interview-prep-data-structures-reverse-a-doubly-linked-list-2980a3cbc1348b66e8b7.js","sourcesContent":["webpackJsonp([78511376825813],{\n\n/***/ 2851:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Reverse a Doubly Linked List\",\"description\":[\"现在我们来为双向链表创建一个<code>reverse</code>方法，该方法可以反转链表中的元素。在该方法执行后，head 指针应该指向链表尾部，tail 指针则应指向链表头部。此时，如果我们从头到尾遍历链表，则新的链表中节点顺序应与原链表中节点顺序相反。当试图反转一个空链表时，该方法应该返回 null。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/coding-interview-prep/data-structures/reverse-a-doubly-linked-list\",\"blockName\":\"Data Structures\",\"tests\":[{\"text\":\"应该存在双向链表。\",\"testString\":\"assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; return (typeof test == 'object')})(), '应该存在双向链表。');\"},{\"text\":\"双向链表应该有 add 方法。\",\"testString\":\"assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; if (test.add == undefined) { return false; }; return (typeof test.add == 'function')})(), '该双向链表应该有 add 方法。');\"},{\"text\":\"双向链表应该有 reverse 方法。\",\"testString\":\"assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; if (test.reverse == undefined) { return false; }; return (typeof test.reverse == 'function')})(), '该双向链表应该有 reverse 方法。');\"},{\"text\":\"试图反转一个空链表时应返回 null。\",\"testString\":\"assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; return (test.reverse() == null); })(), '试图反转一个空链表时应返回 null。');\"},{\"text\":\"reverse 方法应反转整个链表。\",\"testString\":\"assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; test.add(58); test.add(61); test.add(32); test.reverse(); return (test.print().join('') == '326158'); })(), 'reverse 方法应反转整个链表。');\"},{\"text\":\"在整个表被反转后，表中每个元素的 next 和 previous 指针都应该存在。\",\"testString\":\"assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; test.add(11); test.add(22); test.add(33); test.reverse(); return (test.printReverse().join('') == '112233'); })(), '在整个表被反转后，表中每个元素的 next 和 previous 指针都应该存在。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"var Node = function(data, prev) {\\n  this.data = data;\\n  this.prev = prev;\\n  this.next = null;\\n};\\nvar DoublyLinkedList = function() {\\n  this.head = null;\\n  this.tail = null;\\n  // 请把你的代码写在这条注释以下\\n  // 请把你的代码写在这条注释以上\\n};\",\"head\":\"\",\"tail\":\"DoublyLinkedList.prototype = {\\n  add(data) {\\n    if (this.head == null) {\\n      this.head = new Node(data, null);\\n      this.tail = this.head;\\n    } else {\\n      var node = this.head;\\n      var prev = null;\\n      while (node.next != null) {\\n        prev = node;\\n        node = node.next;\\n      };\\n      var newNode = new Node(data, node);\\n      node.next = newNode;\\n      this.tail = newNode;\\n    };\\n  },\\n  print() {\\n    if (this.head == null) {\\n      return null;\\n    } else {\\n      var result = new Array();\\n      var node = this.head;\\n      while (node.next != null) {\\n        result.push(node.data);\\n        node = node.next;\\n      };\\n      result.push(node.data);\\n      return result;\\n    };\\n  },\\n  printReverse() {\\n    if (this.tail == null) {\\n      return null;\\n    } else {\\n      var result = new Array();\\n      var node = this.tail;\\n      while (node.prev != null) {\\n        result.push(node.data);\\n        node = node.prev;\\n      };\\n      result.push(node.data);\\n      return result;\\n    };\\n  }\\n};\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/coding-interview-prep/data-structures/find-the-minimum-and-maximum-value-in-a-binary-search-tree\",\"id\":\"587d825a367417b2b2512c88\"},\"slug\":\"/coding-interview-prep/data-structures/reverse-a-doubly-linked-list\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---coding-interview-prep-data-structures-reverse-a-doubly-linked-list-2980a3cbc1348b66e8b7.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Reverse a Doubly Linked List\",\"description\":[\"现在我们来为双向链表创建一个<code>reverse</code>方法，该方法可以反转链表中的元素。在该方法执行后，head 指针应该指向链表尾部，tail 指针则应指向链表头部。此时，如果我们从头到尾遍历链表，则新的链表中节点顺序应与原链表中节点顺序相反。当试图反转一个空链表时，该方法应该返回 null。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/coding-interview-prep/data-structures/reverse-a-doubly-linked-list\",\"blockName\":\"Data Structures\",\"tests\":[{\"text\":\"应该存在双向链表。\",\"testString\":\"assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; return (typeof test == 'object')})(), '应该存在双向链表。');\"},{\"text\":\"双向链表应该有 add 方法。\",\"testString\":\"assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; if (test.add == undefined) { return false; }; return (typeof test.add == 'function')})(), '该双向链表应该有 add 方法。');\"},{\"text\":\"双向链表应该有 reverse 方法。\",\"testString\":\"assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; if (test.reverse == undefined) { return false; }; return (typeof test.reverse == 'function')})(), '该双向链表应该有 reverse 方法。');\"},{\"text\":\"试图反转一个空链表时应返回 null。\",\"testString\":\"assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; return (test.reverse() == null); })(), '试图反转一个空链表时应返回 null。');\"},{\"text\":\"reverse 方法应反转整个链表。\",\"testString\":\"assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; test.add(58); test.add(61); test.add(32); test.reverse(); return (test.print().join('') == '326158'); })(), 'reverse 方法应反转整个链表。');\"},{\"text\":\"在整个表被反转后，表中每个元素的 next 和 previous 指针都应该存在。\",\"testString\":\"assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; test.add(11); test.add(22); test.add(33); test.reverse(); return (test.printReverse().join('') == '112233'); })(), '在整个表被反转后，表中每个元素的 next 和 previous 指针都应该存在。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"var Node = function(data, prev) {\\n  this.data = data;\\n  this.prev = prev;\\n  this.next = null;\\n};\\nvar DoublyLinkedList = function() {\\n  this.head = null;\\n  this.tail = null;\\n  // 请把你的代码写在这条注释以下\\n  // 请把你的代码写在这条注释以上\\n};\",\"head\":\"\",\"tail\":\"DoublyLinkedList.prototype = {\\n  add(data) {\\n    if (this.head == null) {\\n      this.head = new Node(data, null);\\n      this.tail = this.head;\\n    } else {\\n      var node = this.head;\\n      var prev = null;\\n      while (node.next != null) {\\n        prev = node;\\n        node = node.next;\\n      };\\n      var newNode = new Node(data, node);\\n      node.next = newNode;\\n      this.tail = newNode;\\n    };\\n  },\\n  print() {\\n    if (this.head == null) {\\n      return null;\\n    } else {\\n      var result = new Array();\\n      var node = this.head;\\n      while (node.next != null) {\\n        result.push(node.data);\\n        node = node.next;\\n      };\\n      result.push(node.data);\\n      return result;\\n    };\\n  },\\n  printReverse() {\\n    if (this.tail == null) {\\n      return null;\\n    } else {\\n      var result = new Array();\\n      var node = this.tail;\\n      while (node.prev != null) {\\n        result.push(node.data);\\n        node = node.prev;\\n      };\\n      result.push(node.data);\\n      return result;\\n    };\\n  }\\n};\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/coding-interview-prep/data-structures/find-the-minimum-and-maximum-value-in-a-binary-search-tree\",\"id\":\"587d825a367417b2b2512c88\"},\"slug\":\"/coding-interview-prep/data-structures/reverse-a-doubly-linked-list\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/coding-interview-prep-data-structures-reverse-a-doubly-linked-list.json\n// module id = 2851\n// module chunks = 78511376825813"],"sourceRoot":""}
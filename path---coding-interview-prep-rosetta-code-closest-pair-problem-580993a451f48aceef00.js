webpackJsonp([0xee0f9194c5f9],{3357:function(n,e){n.exports={data:{challengeNode:{title:"Closest-pair problem",description:["Task:",'<p>Provide a function to find the closest two points among a set of given points in two dimensions,  i.e. to solve the  <a href="https://en.wikipedia.org/wiki/Closest pair of points problem" title="wp: Closest pair of points problem">Closest pair of points problem</a>  in the  planar  case.</p><p>The straightforward solution is a  O(n<sup>2</sup>)  algorithm  (which we can call brute-force algorithm);  the pseudo-code (using indexes) could be simply:</p>',"<pre>","bruteForceClosestPair of P(1), P(2), ... P(N)","if N &lt; 2 then","  return ∞","else","  minDistance ← |P(1) - P(2)|","  minPoints ← { P(1), P(2) }","  foreach i ∈ [1, N-1]","    foreach j ∈ [i+1, N]","      if |P(i) - P(j)| < minDistance then","        minDistance ← |P(i) - P(j)|","        minPoints ← { P(i), P(j) }","      endif","    endfor","  endfor","  return minDistance, minPoints","endif","</pre>",'<p>A better algorithm is based on the recursive divide&amp;conquer approach, as explained also at  <a href="https://en.wikipedia.org/wiki/Closest pair of points problem#Planar_case" title="wp: Closest pair of points problem#Planar_case">Wikipedia\'s Closest pair of points problem</a>,  which is  O(n log n);  a pseudo-code could be:</p>',"<pre>","closestPair of (xP, yP)","  where xP is P(1) .. P(N) sorted by x coordinate, and","  yP is P(1) .. P(N) sorted by y coordinate (ascending order)","if N ≤ 3 then","  return closest points of xP using brute-force algorithm","else","  xL ← points of xP from 1 to ⌈N/2⌉","  xR ← points of xP from ⌈N/2⌉+1 to N","  xm ← xP(⌈N/2⌉)<sub>x</sub>","  yL ← { p ∈ yP : p<sub>x</sub> ≤ xm }","  yR ← { p ∈ yP : p<sub>x</sub> &gt; xm }","  (dL, pairL) ← closestPair of (xL, yL)","  (dR, pairR) ← closestPair of (xR, yR)","  (dmin, pairMin) ← (dR, pairR)","  if dL &lt; dR then","    (dmin, pairMin) ← (dL, pairL)","  endif","  yS ← { p ∈ yP : |xm - p<sub>x</sub>| &lt; dmin }","  nS ← number of points in yS","  (closest, closestPair) ← (dmin, pairMin)","  for i from 1 to nS - 1","    k ← i + 1","    while k ≤ nS and yS(k)<sub>y</sub> - yS(i)<sub>y</sub> &lt; dmin","      if |yS(k) - yS(i)| &lt; closest then","        (closest, closestPair) ← (|yS(k) - yS(i)|, {yS(k), yS(i)})","      endif","      k ← k + 1","    endwhile","  endfor","  return closest, closestPair","endif","</pre>","References and further readings:",' <a href="https://en.wikipedia.org/wiki/Closest pair of points problem" title="wp: Closest pair of points problem">Closest pair of points problem</a>',' <a href="http://www.cs.mcgill.ca/~cs251/ClosestPair/ClosestPairDQ.html" title="link: http://www.cs.mcgill.ca/~cs251/ClosestPair/ClosestPairDQ.html">Closest Pair (McGill)</a>',' <a href="http://www.cs.ucsb.edu/~suri/cs235/ClosestPair.pdf" title="link: http://www.cs.ucsb.edu/~suri/cs235/ClosestPair.pdf">Closest Pair (UCSB)</a>',' <a href="http://classes.cec.wustl.edu/~cse241/handouts/closestpair.pdf" title="link: http://classes.cec.wustl.edu/~cse241/handouts/closestpair.pdf">Closest pair (WUStL)</a>',' <a href="http://www.cs.iupui.edu/~xkzou/teaching/CS580/Divide-and-conquer-closestPair.ppt" title="link: http://www.cs.iupui.edu/~xkzou/teaching/CS580/Divide-and-conquer-closestPair.ppt">Closest pair (IUPUI)</a> ',"<p>For the input, expect the argument to be an array of objects (points) with <code>x</code> and <code>y</code> members set to numbers. For the output, return an object containing the key:value pairs for  <code>distance</code> and <code>pair</code> (i.e., the pair of two closest points).</p>"],challengeType:5,fields:{slug:"/coding-interview-prep/rosetta-code/closest-pair-problem",blockName:"Rosetta Code",tests:[{text:"<code>getClosestPair</code> is a function.",testString:"assert(typeof getClosestPair === 'function', '<code>getClosestPair</code> is a function.');"},{text:"Distance should be the following.",testString:"assert.equal(getClosestPair(points1).distance, answer1.distance, 'Distance should be the following.');"},{text:"Points should be the following.",testString:"assert.deepEqual(JSON.parse(JSON.stringify(getClosestPair(points1))).pair, answer1.pair, 'Points should be the following.');"},{text:"Distance should be the following.",testString:"assert.equal(getClosestPair(points2).distance, answer2.distance, 'Distance should be the following.');"},{text:"Points should be the following.",testString:"assert.deepEqual(JSON.parse(JSON.stringify(getClosestPair(points2))).pair, answer2.pair, 'Points should be the following.');"}]},required:[],files:{indexhtml:null,indexjs:{key:"indexjs",ext:"js",name:"index",contents:"const Point = function (x, y) {\n  this.x = x;\n  this.y = y;\n};\nPoint.prototype.getX = function () {\n  return this.x;\n};\nPoint.prototype.getY = function () {\n  return this.y;\n};\n\nfunction getClosestPair (pointsArr) {\n  // Good luck!\n  return true;\n}",head:"",tail:"const points1 = [\n\tnew Point(0.748501, 4.09624),\n\tnew Point(3.00302, 5.26164),\n\tnew Point(3.61878,  9.52232),\n\tnew Point(7.46911,  4.71611),\n\tnew Point(5.7819,   2.69367),\n\tnew Point(2.34709,  8.74782),\n\tnew Point(2.87169,  5.97774),\n\tnew Point(6.33101,  0.463131),\n\tnew Point(7.46489,  4.6268),\n\tnew Point(1.45428,  0.087596)\n];\n\nconst points2 = [\n  new Point(37100, 13118),\n  new Point(37134, 1963),\n  new Point(37181, 2008),\n  new Point(37276, 21611),\n  new Point(37307, 9320)\n];\n\nconst answer1 = {\n  distance: 0.0894096443343775,\n  pair: [\n    {\n      x: 7.46489,\n      y: 4.6268\n    },\n    {\n      x: 7.46911,\n      y: 4.71611\n    }\n  ]\n};\n\nconst answer2 = {\n  distance: 65.06919393998976,\n  pair: [\n    {\n      x: 37134,\n      y: 1963\n    },\n    {\n      x: 37181,\n      y: 2008\n    }\n  ]\n};\n\nconst benchmarkPoints = [\n  new Point(16909, 54699),\n  new Point(14773, 61107),\n  new Point(95547, 45344),\n  new Point(95951, 17573),\n  new Point(5824, 41072),\n  new Point(8769, 52562),\n  new Point(21182, 41881),\n  new Point(53226, 45749),\n  new Point(68180, 887),\n  new Point(29322, 44017),\n  new Point(46817, 64975),\n  new Point(10501, 483),\n  new Point(57094, 60703),\n  new Point(23318, 35472),\n  new Point(72452, 88070),\n  new Point(67775, 28659),\n  new Point(19450, 20518),\n  new Point(17314, 26927),\n  new Point(98088, 11164),\n  new Point(25050, 56835),\n  new Point(8364, 6892),\n  new Point(37868, 18382),\n  new Point(23723, 7701),\n  new Point(55767, 11569),\n  new Point(70721, 66707),\n  new Point(31863, 9837),\n  new Point(49358, 30795),\n  new Point(13041, 39745),\n  new Point(59635, 26523),\n  new Point(25859, 1292),\n  new Point(1551, 53890),\n  new Point(70316, 94479),\n  new Point(48549, 86338),\n  new Point(46413, 92747),\n  new Point(27186, 50426),\n  new Point(27591, 22655),\n  new Point(10905, 46153),\n  new Point(40408, 84202),\n  new Point(52821, 73520),\n  new Point(84865, 77388),\n  new Point(99819, 32527),\n  new Point(34404, 75657),\n  new Point(78457, 96615),\n  new Point(42140, 5564),\n  new Point(62175, 92342),\n  new Point(54958, 67112),\n  new Point(4092, 19709),\n  new Point(99415, 60298),\n  new Point(51090, 52158),\n  new Point(48953, 58567)\n];"},indexjsx:null}}},pathContext:{challengeMeta:{introPath:"",template:null,required:[],nextChallengePath:"/coding-interview-prep/rosetta-code/combinations",id:"5951a53863c8a34f02bf1bdc"},slug:"/coding-interview-prep/rosetta-code/closest-pair-problem"}}}});
//# sourceMappingURL=path---coding-interview-prep-rosetta-code-closest-pair-problem-580993a451f48aceef00.js.map
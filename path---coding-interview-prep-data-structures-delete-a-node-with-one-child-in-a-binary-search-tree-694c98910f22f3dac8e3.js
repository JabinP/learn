webpackJsonp([0x98db10d9e5e4],{2832:function(e,n){e.exports={data:{challengeNode:{title:"Delete a Node with One Child in a Binary Search Tree",description:["现在我们已经知道如何删除一个叶子结点了。在这个挑战中，我们来接着尝试删除有一个子节点的节点。比如，对于一个结构为 1 - 2 - 3 的树，它有三个节点：其中 1 是根节点。现在如果我们要删除节点 2，那直接让节点 1 指向节点 3 即可。通常，删除只有一个子节点的节点时，我们只需要让该节点的父节点指向该节点的子节点即可。","挑战说明：我们已经在右边为你写好了<code>remove</code>方法，其中还包含了上一个挑战的实现。与之前的题目描述一样，我们找到需要删除的节点以及其父节点，然后用定义好的方法判断出该节点拥有的子节点数量。现在我们来处理删除仅有一个子节点的节点的情况。首先，我们需要知道这一个子节点是左分支还是右分支，然后才能让被删除节点的父节点的合适分支来指向该节点的子节点。此外，我们需要考虑当删除的节点为根节点的情况，这意味着父节点的值是<code>null</code>。当然，如果你觉得提供给你的代码不够好，也可以用你自己写的版本。"],challengeType:1,fields:{slug:"/coding-interview-prep/data-structures/delete-a-node-with-one-child-in-a-binary-search-tree",blockName:"Data Structures",tests:[{text:"<code>BinarySearchTree</code>数据结构应该存在。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');"},{text:"<code>BinarySearchTree</code>应该有<code>remove</code>方法。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.remove == 'function')})(), '<code>BinarySearchTree</code>应该有<code>remove</code>方法。');"},{text:"当试图移除一个不存在的元素时，方法应返回<code>null</code>。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; return (test.remove(100) == null); })(), '当试图移除一个不存在的元素时，方法应返回<code>null</code>。');"},{text:"如果根节点无子节点，那么删除此节点之后应将该根节点设置为<code>null</code>。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(500); test.remove(500); return (test.inorder() == null); })(), '如果根节点无子节点，那么删除此节点之后应将该根节点设置为<code>null</code>。');"},{text:"<code>remove</code>方法应可以移除树结构中的叶子结点。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(5); test.add(3); test.add(7); test.add(6); test.add(10); test.add(12); test.remove(3); test.remove(12); test.remove(10); return (test.inorder().join('') == '567'); })(), '<code>remove</code>方法应可以移除树结构中的叶子结点。');"},{text:"<code>remove</code>方法应可以移除拥有一个子节点的节点。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(-1); test.add(3); test.add(7); test.add(16); test.remove(16); test.remove(7); test.remove(3); return (test.inorder().join('') == '-1'); })(), '<code>remove</code>方法应可以移除拥有一个子节点的节点。');"},{text:"移除树结构中拥有两个子节点的根节之后，另一个子节点应成为树的根节点。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(15); test.add(27); test.remove(15); return (test.inorder().join('') == '27'); })(), '移除树结构中拥有两个子节点的根节之后，另一个子节点应成为树的根节点。');"}]},required:[],files:{indexhtml:null,indexjs:{key:"indexjs",ext:"js",name:"index",contents:"var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\n\nfunction BinarySearchTree() {\n  this.root = null;\n  this.remove = function(value) {\n    if (this.root === null) {\n      return null;\n    }\n    var target;\n    var parent = null;\n    // 找出要删除的节点及其父节点\n    (function findValue(node = this.root) {\n      if (value == node.value) {\n        target = node;\n      } else if (value < node.value && node.left !== null) {\n        parent = node;\n        return findValue(node.left);\n      } else if (value < node.value && node.left === null) {\n        return null;\n      } else if (value > node.value && node.right !== null) {\n        parent = node;\n        return findValue(node.right);\n      } else {\n        return null;\n      }\n    }).bind(this)();\n    if (target === null) {\n      return null;\n    }\n    // 获取要删除节点的子节点数量\n    var children = (target.left !== null ? 1 : 0) + (target.right !== null ? 1 : 0);\n    // 情况 1：要删除的节点没有子节点\n    if (children === 0) {\n      if (target == this.root) {\n        this.root = null;\n      }\n      else {\n        if (parent.left == target) {\n          parent.left = null;\n        } else {\n          parent.right = null;\n        }\n      }\n    }\n    // 情况 2：要删除的节点只有一个子节点，请把你的代码写在这条注释以下\n  };\n}",head:"",tail:"BinarySearchTree.prototype = {\n    add: function(value) {\n        var node = this.root;\n        if (node == null) {\n          this.root = new Node(value);\n          return;\n        } else {\n            function searchTree(node) {\n                if (value < node.value) {\n                    if (node.left == null) {\n                        node.left = new Node(value);\n                        return;\n                    } else if (node.left != null) {\n                        return searchTree(node.left)\n                    };\n                } else if (value > node.value) {\n                    if (node.right == null) {\n                        node.right = new Node(value);\n                        return;\n                    } else if (node.right != null) {\n                        return searchTree(node.right);\n                    };\n                } else {\n                    return null;\n                };\n            };\n            return searchTree(node);\n        };\n    },\n    inorder: function() {\n        if (this.root == null) {\n          return null;\n        } else {\n          var result = new Array();\n          function traverseInOrder(node) {\n              if (node.left != null) {\n                  traverseInOrder(node.left);\n              };\n              result.push(node.value);\n              if (node.right != null) {\n                  traverseInOrder(node.right);\n              };\n          }\n          traverseInOrder(this.root);\n          return result;\n        };\n    },    \n    isBinarySearchTree() {\n        if (this.root == null) {\n            return null;\n        } else {\n            var check = true;\n            function checkTree(node) {\n                if (node.left != null) {\n                    var left = node.left;\n                    if (left.value > node.value) {\n                        check = false;\n                    } else {\n                        checkTree(left);\n                    }\n                }\n                if (node.right != null) {\n                    var right = node.right;\n                    if (right.value < node.value) {\n                        check = false;\n                    } else {\n                        checkTree(right);\n                    };\n                };\n            };\n            checkTree(this.root);\n            return check;\n        }\n    }\n};"},indexjsx:null}}},pathContext:{challengeMeta:{introPath:"",template:null,required:[],nextChallengePath:"/coding-interview-prep/data-structures/delete-a-node-with-two-children-in-a-binary-search-tree",id:"587d8258367417b2b2512c81"},slug:"/coding-interview-prep/data-structures/delete-a-node-with-one-child-in-a-binary-search-tree"}}}});
//# sourceMappingURL=path---coding-interview-prep-data-structures-delete-a-node-with-one-child-in-a-binary-search-tree-694c98910f22f3dac8e3.js.map
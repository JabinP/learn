webpackJsonp([0x7cedf794ee95],{2787:function(e,t){e.exports={data:{challengeNode:{title:"Use the Tilde-Character to Always Use the Latest Patch Version of a Dependency",guideUrl:null,description:["在最后一个挑战中，我们告诉 npm 只包含特定版本的依赖包。如果想让项目各个部分保持相互兼容，锁定依赖包版本是一个有效的办法。但是大多数情况下，我们并不希望错过依赖项的问题修复，因为它们通常包含重要的安全补丁，而且它们理论上也会兼容我们既有的代码。","为了让 npm 依赖项更新到最新的修订版，你可以在依赖包的版本号前加一个波浪符号（~）。在 package.json 中，我们当前的 moment 依赖包更新规则是：仅使用特定版本（2.10.2），但我们想用它最新的 2.10.x 版本。","例子：",'<code>"some-package-name": "~1.3.8" 定义这个包允许使用的版本为 1.3.x。</code>',"说明：","在 dependencies 中，给 moment 的版本号添加波浪符号（~）前缀，允许 npm 将其更新为最新的修订版。","请注意，原本的版本号不用更改。"],challengeType:2,fields:{blockName:"Managing Packages with Npm",slug:"/apis-and-microservices/managing-packages-with-npm/use-the-tilde-character-to-always-use-the-latest-patch-version-of-a-dependency",tests:[{text:'"dependencies" 应该包含 "moment"。',testString:"getUserInput => $.get(getUserInput('url') + '/_api/package.json').then(data => { var packJson = JSON.parse(data); assert.property(packJson.dependencies, 'moment', '\"dependencies\" 未包含 \"moment\"'); }, xhr => { throw new Error(xhr.responseText); })"},{text:'"moment" 的版本号应该是 "~2.10.2"。',testString:"getUserInput => $.get(getUserInput('url') + '/_api/package.json').then(data => { var packJson = JSON.parse(data); assert.match(packJson.dependencies.moment, /^\\~2\\.10\\.2/, '\"moment\" 版本号有误，它应该是 ~2.10.2'); }, xhr => { throw new Error(xhr.responseText); })"}]}}},pathContext:{challengeMeta:{introPath:"",template:null,required:[],nextChallengePath:"/apis-and-microservices/managing-packages-with-npm/use-the-caret-character-to-use-the-latest-minor-version-of-a-dependency",id:"587d7fb5367417b2b2512c02"},slug:"/apis-and-microservices/managing-packages-with-npm/use-the-tilde-character-to-always-use-the-latest-patch-version-of-a-dependency"}}}});
//# sourceMappingURL=path---apis-and-microservices-managing-packages-with-npm-use-the-tilde-character-to-always-use-the-latest-patch-version-of-a-dependency-6f99c0304375dc5ceb8e.js.map
{"version":3,"sources":["webpack:///path---javascript-algorithms-and-data-structures-functional-programming-understand-the-hazards-of-using-imperative-code-125dd29f5d20269e0343.js","webpack:///./.cache/json/javascript-algorithms-and-data-structures-functional-programming-understand-the-hazards-of-using-imperative-code.json"],"names":["webpackJsonp","3918","module","exports","data","challengeNode","title","description","challengeType","fields","slug","blockName","tests","text","testString","required","files","indexhtml","indexjs","key","ext","name","contents","head","tail","indexjsx","pathContext","challengeMeta","introPath","template","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,kDAAAC,aAAA,48BAAAC,cAAA,EAAAC,QAAmjCC,KAAA,oHAAAC,UAAA,yBAAAC,QAA0KC,KAAA,sCAAAC,WAAA,0DAAmHC,YAAAC,OAAwBC,UAAA,KAAAC,SAA4BC,IAAA,UAAAC,IAAA,KAAAC,KAAA,QAAAC,SAAA,uqCAA0tCC,KAAA,GAAAC,KAAA,IAAsBC,SAAA,QAAmBC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,KAAAd,YAAAe,kBAAA,kIAAAC,GAAA,4BAAmOrB,KAAA","file":"path---javascript-algorithms-and-data-structures-functional-programming-understand-the-hazards-of-using-imperative-code-125dd29f5d20269e0343.js","sourcesContent":["webpackJsonp([156238568156635],{\n\n/***/ 3918:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Understand the Hazards of Using Imperative Code\",\"description\":[\"函数式编程是一种好习惯，它能让代码管理更简单，不受隐藏 bug 影响。在我们开始函数式编程之前，为了更好的突显可能遇到的问题，我们先看看命令式编程。\",\"类似在英语（和许多其他语言）中，命令式时态用于给出命令，编程中的命令式是给计算机一组语句来执行任务。\",\"这些语句通常会改变程序的状态，例如更新全局变量，典型的例子就是写一个<code>for</code>循环，它给出了迭代数组索引的精确方向。\",\"相反，函数式编程是声明式编程的一种形式，通过调用方法或函数来告诉计算机要做什么。\",\"JavaScript 提供了许多处理常见任务的方法，所以你无需写出计算机应如何执行它们。例如，你可以用<code>map</code>函数替代上面提到的<code>for</code>循环来处理数组迭代。这有助于避免语义错误，如调试章节介绍的\\\"Off By One Errors\\\"。\",\"考虑这样的场景：你正在浏览器中浏览网页，并想操作你打开的标签。下面我们来试试用面向对象的思路来描述这种情景。\",\"窗口对象由选项卡组成，通常会打开多个窗口。窗口对象中每个打开网站的标题都保存在一个数组中。在对浏览器进行了如打开新标签、合并窗口、关闭标签之类的操作后，你需要输出所有打开的标签。关掉的标签将从数组中删除，新打开的标签（为简单起见）则添加到数组的末尾。\",\"代码编辑器中显示了此功能的实现，其中包含<code>tabOpen()</code>，<code>tabClose()</code>，和<code>join()</code>函数。<code>tabs</code>数组是窗口对象的一部分用于储存打开页面的名称。\",\"<h4>说明<h4>\",\"在编辑器中运行代码。它使用了有副作用的方法，导致输出错误。打开标签的最终列表应该是<code>['FB', 'Gitter', 'Reddit', 'Twitter', 'Medium', 'new tab', 'Netflix', 'YouTube', 'Vine', 'GMail', 'Work mail', 'Docs', 'freeCodeCamp', 'new tab']</code>但输出会略有不同。\",\"仔细阅读代码，看看你是否能找出问题所在，然后进入下一个挑战，了解更多信息。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/javascript-algorithms-and-data-structures/functional-programming/understand-the-hazards-of-using-imperative-code\",\"blockName\":\"Functional Programming\",\"tests\":[{\"text\":\"Move ahead to understand the error.\",\"testString\":\"assert(true, 'Move ahead to understand the error.');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"// tabs 是窗口中打开网站的标题数组\\nvar Window = function(tabs) {\\n  this.tabs = tabs; // 我们将数组记录在对象内部\\n};\\n\\n// 当两个窗口合并成一个窗口时\\nWindow.prototype.join = function (otherWindow) {\\n  this.tabs = this.tabs.concat(otherWindow.tabs);\\n  return this;\\n};\\n\\n// 在末尾打开一个新标签\\nWindow.prototype.tabOpen = function (tab) {\\n  this.tabs.push('new tab'); // 打开一个新的标签\\n  return this;\\n};\\n\\n// 关闭一个标签\\nWindow.prototype.tabClose = function (index) {\\n  var tabsBeforeIndex = this.tabs.splice(0, index); // 获取前面的标签\\n  var tabsAfterIndex = this.tabs.splice(index); // 获取后面的标签\\n\\n  this.tabs = tabsBeforeIndex.concat(tabsAfterIndex); // 拼接到一起\\n  return this;\\n };\\n\\n// 创建三个浏览器窗口\\nvar workWindow = new Window(['GMail', 'Inbox', 'Work mail', 'Docs', 'freeCodeCamp']); // 邮箱、文档及其他与工作相关的网站\\nvar socialWindow = new Window(['FB', 'Gitter', 'Reddit', 'Twitter', 'Medium']); // 社交网站\\nvar videoWindow = new Window(['Netflix', 'YouTube', 'Vimeo', 'Vine']); // 娱乐网站\\n\\n// 执行标签打开，关闭和其他操作\\nvar finalTabs = socialWindow\\n                    .tabOpen() // 新开一个 cat memes 的标签\\n                    .join(videoWindow.tabClose(2)) // 在娱乐网站关闭第三个标签，加入数组\\n                    .join(workWindow.tabClose(1).tabOpen());\\n\\nalert(finalTabs.tabs);\",\"head\":\"\",\"tail\":\"\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/javascript-algorithms-and-data-structures/functional-programming/avoid-mutations-and-side-effects-using-functional-programming\",\"id\":\"587d7b8e367417b2b2512b5d\"},\"slug\":\"/javascript-algorithms-and-data-structures/functional-programming/understand-the-hazards-of-using-imperative-code\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---javascript-algorithms-and-data-structures-functional-programming-understand-the-hazards-of-using-imperative-code-125dd29f5d20269e0343.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Understand the Hazards of Using Imperative Code\",\"description\":[\"函数式编程是一种好习惯，它能让代码管理更简单，不受隐藏 bug 影响。在我们开始函数式编程之前，为了更好的突显可能遇到的问题，我们先看看命令式编程。\",\"类似在英语（和许多其他语言）中，命令式时态用于给出命令，编程中的命令式是给计算机一组语句来执行任务。\",\"这些语句通常会改变程序的状态，例如更新全局变量，典型的例子就是写一个<code>for</code>循环，它给出了迭代数组索引的精确方向。\",\"相反，函数式编程是声明式编程的一种形式，通过调用方法或函数来告诉计算机要做什么。\",\"JavaScript 提供了许多处理常见任务的方法，所以你无需写出计算机应如何执行它们。例如，你可以用<code>map</code>函数替代上面提到的<code>for</code>循环来处理数组迭代。这有助于避免语义错误，如调试章节介绍的\\\"Off By One Errors\\\"。\",\"考虑这样的场景：你正在浏览器中浏览网页，并想操作你打开的标签。下面我们来试试用面向对象的思路来描述这种情景。\",\"窗口对象由选项卡组成，通常会打开多个窗口。窗口对象中每个打开网站的标题都保存在一个数组中。在对浏览器进行了如打开新标签、合并窗口、关闭标签之类的操作后，你需要输出所有打开的标签。关掉的标签将从数组中删除，新打开的标签（为简单起见）则添加到数组的末尾。\",\"代码编辑器中显示了此功能的实现，其中包含<code>tabOpen()</code>，<code>tabClose()</code>，和<code>join()</code>函数。<code>tabs</code>数组是窗口对象的一部分用于储存打开页面的名称。\",\"<h4>说明<h4>\",\"在编辑器中运行代码。它使用了有副作用的方法，导致输出错误。打开标签的最终列表应该是<code>['FB', 'Gitter', 'Reddit', 'Twitter', 'Medium', 'new tab', 'Netflix', 'YouTube', 'Vine', 'GMail', 'Work mail', 'Docs', 'freeCodeCamp', 'new tab']</code>但输出会略有不同。\",\"仔细阅读代码，看看你是否能找出问题所在，然后进入下一个挑战，了解更多信息。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/javascript-algorithms-and-data-structures/functional-programming/understand-the-hazards-of-using-imperative-code\",\"blockName\":\"Functional Programming\",\"tests\":[{\"text\":\"Move ahead to understand the error.\",\"testString\":\"assert(true, 'Move ahead to understand the error.');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"// tabs 是窗口中打开网站的标题数组\\nvar Window = function(tabs) {\\n  this.tabs = tabs; // 我们将数组记录在对象内部\\n};\\n\\n// 当两个窗口合并成一个窗口时\\nWindow.prototype.join = function (otherWindow) {\\n  this.tabs = this.tabs.concat(otherWindow.tabs);\\n  return this;\\n};\\n\\n// 在末尾打开一个新标签\\nWindow.prototype.tabOpen = function (tab) {\\n  this.tabs.push('new tab'); // 打开一个新的标签\\n  return this;\\n};\\n\\n// 关闭一个标签\\nWindow.prototype.tabClose = function (index) {\\n  var tabsBeforeIndex = this.tabs.splice(0, index); // 获取前面的标签\\n  var tabsAfterIndex = this.tabs.splice(index); // 获取后面的标签\\n\\n  this.tabs = tabsBeforeIndex.concat(tabsAfterIndex); // 拼接到一起\\n  return this;\\n };\\n\\n// 创建三个浏览器窗口\\nvar workWindow = new Window(['GMail', 'Inbox', 'Work mail', 'Docs', 'freeCodeCamp']); // 邮箱、文档及其他与工作相关的网站\\nvar socialWindow = new Window(['FB', 'Gitter', 'Reddit', 'Twitter', 'Medium']); // 社交网站\\nvar videoWindow = new Window(['Netflix', 'YouTube', 'Vimeo', 'Vine']); // 娱乐网站\\n\\n// 执行标签打开，关闭和其他操作\\nvar finalTabs = socialWindow\\n                    .tabOpen() // 新开一个 cat memes 的标签\\n                    .join(videoWindow.tabClose(2)) // 在娱乐网站关闭第三个标签，加入数组\\n                    .join(workWindow.tabClose(1).tabOpen());\\n\\nalert(finalTabs.tabs);\",\"head\":\"\",\"tail\":\"\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/javascript-algorithms-and-data-structures/functional-programming/avoid-mutations-and-side-effects-using-functional-programming\",\"id\":\"587d7b8e367417b2b2512b5d\"},\"slug\":\"/javascript-algorithms-and-data-structures/functional-programming/understand-the-hazards-of-using-imperative-code\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/javascript-algorithms-and-data-structures-functional-programming-understand-the-hazards-of-using-imperative-code.json\n// module id = 3918\n// module chunks = 156238568156635"],"sourceRoot":""}
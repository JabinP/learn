{"version":3,"sources":["webpack:///path---coding-interview-prep-data-structures-check-if-an-element-is-present-in-a-binary-search-tree-aad71ee0ea28f313ef9a.js","webpack:///./.cache/json/coding-interview-prep-data-structures-check-if-an-element-is-present-in-a-binary-search-tree.json"],"names":["webpackJsonp","2818","module","exports","data","challengeNode","title","description","challengeType","fields","slug","blockName","tests","text","testString","required","files","indexhtml","indexjs","key","ext","name","contents","head","tail","indexjsx","pathContext","challengeMeta","introPath","template","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,yDAAAC,aAAA,2gBAAAC,cAAA,EAAAC,QAAunBC,KAAA,gGAAAC,UAAA,kBAAAC,QAA+IC,KAAA,yCAAAC,WAAA,4MAAyQD,KAAA,4DAAAC,WAAA,kQAAkVD,KAAA,+CAAAC,WAAA,kaAAqeD,KAAA,0CAAAC,WAAA,qSAAkWC,YAAAC,OAAwBC,UAAA,KAAAC,SAA4BC,IAAA,UAAAC,IAAA,KAAAC,KAAA,QAAAC,SAAA,wRAA2UC,KAAA,GAAAC,KAAA,+/BAAihCC,SAAA,QAAmBC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,KAAAd,YAAAe,kBAAA,qGAAAC,GAAA,4BAAsMrB,KAAA","file":"path---coding-interview-prep-data-structures-check-if-an-element-is-present-in-a-binary-search-tree-aad71ee0ea28f313ef9a.js","sourcesContent":["webpackJsonp([200491616698085],{\n\n/***/ 2818:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Check if an Element is Present in a Binary Search Tree\",\"description\":[\"现在我们来进一步学习二叉树。对于查找、插入和删除这些操作，二叉查找树的平均时间复杂度是对数级的，这一点我们已经在前面的挑战中提到了。然而极端的情况下，它也可以消耗线性级的时间。\",\"那么极端的情况是什么样子的呢？试想一个由<code>10</code>、<code>12</code>、<code>17</code>、<code>25</code>这些值组成的二叉查找树。根据二叉查找树的定义，<code>12</code>会添加到<code>10</code>的右边，<code>17</code>会添加到<code>12</code>的右边，而<code>25</code>也会添加到<code>17</code>的右边，现在我们的树结构就像链表一样。那么，为了找到<code>25</code>这个值，我们就需要遍历完所有的元素，这就是最坏的情况。问题的症结在于该树结构是不平衡的。我们会在接下来的挑战逐步说明这意味着什么。\",\"挑战说明：在本次挑战中，我们来为二叉查找树添加一个功能。请编写一个<code>isPresent</code>方法，该方法接收一个整数为参数，并返回一个布尔值，用来表示这个数值是否在该二叉查找树中存在。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/coding-interview-prep/data-structures/check-if-an-element-is-present-in-a-binary-search-tree\",\"blockName\":\"Data Structures\",\"tests\":[{\"text\":\"<code>BinarySearchTree</code>数据结构应该存在。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');\"},{\"text\":\"<code>BinarySearchTree</code>应该有<code>isPresent</code>方法。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.isPresent == 'function')})(), '<code>BinarySearchTree</code>应该有<code>isPresent</code>方法。');\"},{\"text\":\"<code>isPresent</code>方法应该可以检查某个元素在树结构中是否存在。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.isPresent !== 'function') { return false; }; test.add(4); test.add(7); test.add(411); test.add(452); return ( test.isPresent(452) && test.isPresent(411) && test.isPresent(7) && !test.isPresent(100) ); })(), '<code>isPresent</code>方法应该可以检查某个元素在树结构中是否存在。');\"},{\"text\":\"<code>isPresent</code>方法应该可以处理树结构为空的情况。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.isPresent !== 'function') { return false; }; return test.isPresent(5) == false; })(), '<code>isPresent</code>方法应该可以处理树结构为空的情况。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));\\nfunction Node(value) {\\n    this.value = value;\\n    this.left = null;\\n    this.right = null;\\n}\\nfunction BinarySearchTree() {    \\n    this.root = null;\\n    // 请把你的代码写在这条注释以下\\n    // 请把你的代码写在这条注释以上\\n}\",\"head\":\"\",\"tail\":\"BinarySearchTree.prototype = {\\n    add: function(value) {\\n        var node = this.root;\\n        if (node == null) {\\n          this.root = new Node(value);\\n          return;\\n        } else {\\n            function searchTree(node) {\\n                if (value < node.value) {\\n                    if (node.left == null) {\\n                        node.left = new Node(value);\\n                        return;\\n                    } else if (node.left != null) {\\n                        return searchTree(node.left)\\n                    };\\n                } else if (value > node.value) {\\n                    if (node.right == null) {\\n                        node.right = new Node(value);\\n                        return;\\n                    } else if (node.right != null) {\\n                        return searchTree(node.right);\\n                    };\\n                } else {\\n                    return null;\\n                };\\n            };\\n            return searchTree(node);\\n        };\\n    }\\n};\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/coding-interview-prep/data-structures/find-the-minimum-and-maximum-height-of-a-binary-search-tree\",\"id\":\"587d8257367417b2b2512c7c\"},\"slug\":\"/coding-interview-prep/data-structures/check-if-an-element-is-present-in-a-binary-search-tree\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---coding-interview-prep-data-structures-check-if-an-element-is-present-in-a-binary-search-tree-aad71ee0ea28f313ef9a.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Check if an Element is Present in a Binary Search Tree\",\"description\":[\"现在我们来进一步学习二叉树。对于查找、插入和删除这些操作，二叉查找树的平均时间复杂度是对数级的，这一点我们已经在前面的挑战中提到了。然而极端的情况下，它也可以消耗线性级的时间。\",\"那么极端的情况是什么样子的呢？试想一个由<code>10</code>、<code>12</code>、<code>17</code>、<code>25</code>这些值组成的二叉查找树。根据二叉查找树的定义，<code>12</code>会添加到<code>10</code>的右边，<code>17</code>会添加到<code>12</code>的右边，而<code>25</code>也会添加到<code>17</code>的右边，现在我们的树结构就像链表一样。那么，为了找到<code>25</code>这个值，我们就需要遍历完所有的元素，这就是最坏的情况。问题的症结在于该树结构是不平衡的。我们会在接下来的挑战逐步说明这意味着什么。\",\"挑战说明：在本次挑战中，我们来为二叉查找树添加一个功能。请编写一个<code>isPresent</code>方法，该方法接收一个整数为参数，并返回一个布尔值，用来表示这个数值是否在该二叉查找树中存在。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/coding-interview-prep/data-structures/check-if-an-element-is-present-in-a-binary-search-tree\",\"blockName\":\"Data Structures\",\"tests\":[{\"text\":\"<code>BinarySearchTree</code>数据结构应该存在。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');\"},{\"text\":\"<code>BinarySearchTree</code>应该有<code>isPresent</code>方法。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.isPresent == 'function')})(), '<code>BinarySearchTree</code>应该有<code>isPresent</code>方法。');\"},{\"text\":\"<code>isPresent</code>方法应该可以检查某个元素在树结构中是否存在。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.isPresent !== 'function') { return false; }; test.add(4); test.add(7); test.add(411); test.add(452); return ( test.isPresent(452) && test.isPresent(411) && test.isPresent(7) && !test.isPresent(100) ); })(), '<code>isPresent</code>方法应该可以检查某个元素在树结构中是否存在。');\"},{\"text\":\"<code>isPresent</code>方法应该可以处理树结构为空的情况。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.isPresent !== 'function') { return false; }; return test.isPresent(5) == false; })(), '<code>isPresent</code>方法应该可以处理树结构为空的情况。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));\\nfunction Node(value) {\\n    this.value = value;\\n    this.left = null;\\n    this.right = null;\\n}\\nfunction BinarySearchTree() {    \\n    this.root = null;\\n    // 请把你的代码写在这条注释以下\\n    // 请把你的代码写在这条注释以上\\n}\",\"head\":\"\",\"tail\":\"BinarySearchTree.prototype = {\\n    add: function(value) {\\n        var node = this.root;\\n        if (node == null) {\\n          this.root = new Node(value);\\n          return;\\n        } else {\\n            function searchTree(node) {\\n                if (value < node.value) {\\n                    if (node.left == null) {\\n                        node.left = new Node(value);\\n                        return;\\n                    } else if (node.left != null) {\\n                        return searchTree(node.left)\\n                    };\\n                } else if (value > node.value) {\\n                    if (node.right == null) {\\n                        node.right = new Node(value);\\n                        return;\\n                    } else if (node.right != null) {\\n                        return searchTree(node.right);\\n                    };\\n                } else {\\n                    return null;\\n                };\\n            };\\n            return searchTree(node);\\n        };\\n    }\\n};\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/coding-interview-prep/data-structures/find-the-minimum-and-maximum-height-of-a-binary-search-tree\",\"id\":\"587d8257367417b2b2512c7c\"},\"slug\":\"/coding-interview-prep/data-structures/check-if-an-element-is-present-in-a-binary-search-tree\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/coding-interview-prep-data-structures-check-if-an-element-is-present-in-a-binary-search-tree.json\n// module id = 2818\n// module chunks = 200491616698085"],"sourceRoot":""}
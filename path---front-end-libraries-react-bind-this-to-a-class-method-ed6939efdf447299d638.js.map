{"version":3,"sources":["webpack:///path---front-end-libraries-react-bind-this-to-a-class-method-ed6939efdf447299d638.js","webpack:///./.cache/json/front-end-libraries-react-bind-this-to-a-class-method.json"],"names":["webpackJsonp","3570","module","exports","data","challengeNode","title","description","challengeType","fields","slug","blockName","tests","text","testString","required","link","raw","src","files","indexhtml","indexjs","indexjsx","key","ext","name","contents","head","tail","pathContext","challengeMeta","introPath","template","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,gCAAAC,aAAA,qmBAAohB,qXAAAC,cAAA,EAAAC,QAAyhBC,KAAA,yDAAAC,UAAA,QAAAC,QAA8FC,KAAA,uFAAAC,WAAA,mWAA8cD,KAAA,6EAAqEC,WAAA,mKAA+LD,KAAA,uGAAAC,WAAA,sqBAAgyBC,WAAcC,KAAA,KAAAC,IAAA,KAAAC,IAAA,+DAA4FF,KAAA,KAAAC,IAAA,KAAAC,IAAA,uEAAkGC,OAAWC,UAAA,KAAAC,QAAA,KAAAC,UAA4CC,IAAA,WAAAC,IAAA,MAAAC,KAAA,QAAAC,SAAA,2jBAAgnBC,KAAA,GAAAC,KAAA,wEAA0FC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,qFAAsGjB,WAAsBC,KAAA,KAAAC,IAAA,KAAAC,IAAA,+DAA4FF,KAAA,KAAAC,IAAA,KAAAC,IAAA,uEAAkGe,kBAAA,4DAAAC,GAAA,4BAAkHxB,KAAA","file":"path---front-end-libraries-react-bind-this-to-a-class-method-ed6939efdf447299d638.js","sourcesContent":["webpackJsonp([182720183700705],{\n\n/***/ 3570:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Bind 'this' to a Class Method\",\"description\":[\"除了设置和更新<code>state</code>之外，你还可以为组件类定义方法。类方法通常需要使用<code>this</code>关键字，以便它可以访问方法中类的属性（例如<code>state</code>和<code>props </code>）。有几种方法可以让你的类方法访问<code>this</code>。\",\"一种常见的方法是在构造函数中显式地绑定<code>this</code>，这样当组件初始化时，<code>this</code>就会绑定到类方法。你可能已经注意到上一个挑战使用了<code>this.handleClick = this.handleClick.bind(this)</code>用于其在构造函数中的<code>handleClick</code>方法。然后，当你在类方法中调用像<code>this.setState()</code>这样的函数时，<code>this</code>指的是这个类，而不是<code>undefined</code>。\",\"<strong>注意：</strong>&nbsp;<code>this</code>关键字是 JavaScript 中最令人困惑的方面之一，但它在 React 中扮演着重要的角色。虽然它的行为在这里是完全正常的，但是这些课程并不深入研究<code>this</code>，所以如果以上内容令你感到困惑，请参考其他课程！\",\"<hr>\",\"代码编辑器有一个带有<code>state</code>的组件，用于跟踪项目计数。它还有一个方法，允许你增加此项目计数。但是，该方法不起作用，因为它使用了未定义的<code>this</code>关键字。可以通过将<code>this</code>显式绑定到组件构造函数中的<code>addItem()</code>方法来修复它。\",\"接下来，向 render 方法中的<code>button</code>元素添加一个单击处理程序。当按钮接收到单击事件时，它应该触发<code>addItem()</code>方法。记住，传递给<code>onClick</code>处理程序的方法需要使用花括号，因为它应该直接被解释为 JavaScript。\",\"完成上述步骤后，你应该可以单击按钮并查看 HTML 中的项目计数增量。\"],\"challengeType\":6,\"fields\":{\"slug\":\"/front-end-libraries/react/bind-this-to-a-class-method\",\"blockName\":\"React\",\"tests\":[{\"text\":\"<code>MyComponent</code>应返回<code>div</code>元素，该元素按顺序包含两个元素，一个按钮和一个<code>h1</code>元素。\",\"testString\":\"assert(Enzyme.mount(React.createElement(MyComponent)).find('div').length === 1 && Enzyme.mount(React.createElement(MyComponent)).find('div').childAt(0).type() === 'button' && Enzyme.mount(React.createElement(MyComponent)).find('div').childAt(1).type() === 'h1', '<code>MyComponent</code>应返回<code>div</code>元素，该元素按顺序包含两个元素，一个按钮和一个<code>h1</code>元素。');\"},{\"text\":\"<code>MyComponent</code>的 state 应该使用键值对<code>{ itemCount: 0 }</code>进行初始化。\",\"testString\":\"assert(Enzyme.mount(React.createElement(MyComponent)).state('itemCount') === 0, '<code>MyComponent</code>的 state 应该使用键值对<code>{ itemCount: 0 }</code>进行初始化。');\"},{\"text\":\"单击<code>button</code>元素应该运行<code>addItem</code>方法，并使 state<code>itemCount</code>的计数增加<code>1</code>。\",\"testString\":\"async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); const first = () => { mockedComponent.setState({ itemCount: 0 }); return waitForIt(() => mockedComponent.state('itemCount')); }; const second = () => { mockedComponent.find('button').simulate('click'); return waitForIt(() => mockedComponent.state('itemCount')); }; const firstValue = await first(); const secondValue = await second(); assert(firstValue === 0 && secondValue === 1, '单击<code>button</code>元素应该运行<code>addItem</code>方法，并使 state<code>itemCount</code>的计数增加<code>1</code>。'); };\"}]},\"required\":[{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react@16.4.0/umd/react.production.min.js\"},{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react-dom@16.4.0/umd/react-dom.production.min.js\"}],\"files\":{\"indexhtml\":null,\"indexjs\":null,\"indexjsx\":{\"key\":\"indexjsx\",\"ext\":\"jsx\",\"name\":\"index\",\"contents\":\"class MyComponent extends React.Component {\\n  constructor(props) {\\n    super(props);\\n    this.state = {\\n      itemCount: 0\\n    };\\n    // change code below this line\\n\\n    // change code above this line\\n  }\\n  addItem() {\\n    this.setState({\\n      itemCount: this.state.itemCount + 1\\n    });\\n  }\\n  render() {\\n    return (\\n      <div>\\n        { /* change code below this line */ }\\n        <button>Click Me</button>\\n        { /* change code above this line */ }\\n        <h1>Current Item Count: {this.state.itemCount}</h1>\\n      </div>\\n    );\\n  }\\n};\",\"head\":\"\",\"tail\":\"ReactDOM.render(<MyComponent />, document.getElementById('root'))\"}}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":\"<body><div id='root'></div><div id='challenge-node'></div>${ source || '' }</body>\",\"required\":[{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react@16.4.0/umd/react.production.min.js\"},{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react-dom@16.4.0/umd/react-dom.production.min.js\"}],\"nextChallengePath\":\"/front-end-libraries/react/use-state-to-toggle-an-element\",\"id\":\"5a24c314108439a4d4036174\"},\"slug\":\"/front-end-libraries/react/bind-this-to-a-class-method\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---front-end-libraries-react-bind-this-to-a-class-method-ed6939efdf447299d638.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Bind 'this' to a Class Method\",\"description\":[\"除了设置和更新<code>state</code>之外，你还可以为组件类定义方法。类方法通常需要使用<code>this</code>关键字，以便它可以访问方法中类的属性（例如<code>state</code>和<code>props </code>）。有几种方法可以让你的类方法访问<code>this</code>。\",\"一种常见的方法是在构造函数中显式地绑定<code>this</code>，这样当组件初始化时，<code>this</code>就会绑定到类方法。你可能已经注意到上一个挑战使用了<code>this.handleClick = this.handleClick.bind(this)</code>用于其在构造函数中的<code>handleClick</code>方法。然后，当你在类方法中调用像<code>this.setState()</code>这样的函数时，<code>this</code>指的是这个类，而不是<code>undefined</code>。\",\"<strong>注意：</strong>&nbsp;<code>this</code>关键字是 JavaScript 中最令人困惑的方面之一，但它在 React 中扮演着重要的角色。虽然它的行为在这里是完全正常的，但是这些课程并不深入研究<code>this</code>，所以如果以上内容令你感到困惑，请参考其他课程！\",\"<hr>\",\"代码编辑器有一个带有<code>state</code>的组件，用于跟踪项目计数。它还有一个方法，允许你增加此项目计数。但是，该方法不起作用，因为它使用了未定义的<code>this</code>关键字。可以通过将<code>this</code>显式绑定到组件构造函数中的<code>addItem()</code>方法来修复它。\",\"接下来，向 render 方法中的<code>button</code>元素添加一个单击处理程序。当按钮接收到单击事件时，它应该触发<code>addItem()</code>方法。记住，传递给<code>onClick</code>处理程序的方法需要使用花括号，因为它应该直接被解释为 JavaScript。\",\"完成上述步骤后，你应该可以单击按钮并查看 HTML 中的项目计数增量。\"],\"challengeType\":6,\"fields\":{\"slug\":\"/front-end-libraries/react/bind-this-to-a-class-method\",\"blockName\":\"React\",\"tests\":[{\"text\":\"<code>MyComponent</code>应返回<code>div</code>元素，该元素按顺序包含两个元素，一个按钮和一个<code>h1</code>元素。\",\"testString\":\"assert(Enzyme.mount(React.createElement(MyComponent)).find('div').length === 1 && Enzyme.mount(React.createElement(MyComponent)).find('div').childAt(0).type() === 'button' && Enzyme.mount(React.createElement(MyComponent)).find('div').childAt(1).type() === 'h1', '<code>MyComponent</code>应返回<code>div</code>元素，该元素按顺序包含两个元素，一个按钮和一个<code>h1</code>元素。');\"},{\"text\":\"<code>MyComponent</code>的 state 应该使用键值对<code>{ itemCount: 0 }</code>进行初始化。\",\"testString\":\"assert(Enzyme.mount(React.createElement(MyComponent)).state('itemCount') === 0, '<code>MyComponent</code>的 state 应该使用键值对<code>{ itemCount: 0 }</code>进行初始化。');\"},{\"text\":\"单击<code>button</code>元素应该运行<code>addItem</code>方法，并使 state<code>itemCount</code>的计数增加<code>1</code>。\",\"testString\":\"async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); const first = () => { mockedComponent.setState({ itemCount: 0 }); return waitForIt(() => mockedComponent.state('itemCount')); }; const second = () => { mockedComponent.find('button').simulate('click'); return waitForIt(() => mockedComponent.state('itemCount')); }; const firstValue = await first(); const secondValue = await second(); assert(firstValue === 0 && secondValue === 1, '单击<code>button</code>元素应该运行<code>addItem</code>方法，并使 state<code>itemCount</code>的计数增加<code>1</code>。'); };\"}]},\"required\":[{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react@16.4.0/umd/react.production.min.js\"},{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react-dom@16.4.0/umd/react-dom.production.min.js\"}],\"files\":{\"indexhtml\":null,\"indexjs\":null,\"indexjsx\":{\"key\":\"indexjsx\",\"ext\":\"jsx\",\"name\":\"index\",\"contents\":\"class MyComponent extends React.Component {\\n  constructor(props) {\\n    super(props);\\n    this.state = {\\n      itemCount: 0\\n    };\\n    // change code below this line\\n\\n    // change code above this line\\n  }\\n  addItem() {\\n    this.setState({\\n      itemCount: this.state.itemCount + 1\\n    });\\n  }\\n  render() {\\n    return (\\n      <div>\\n        { /* change code below this line */ }\\n        <button>Click Me</button>\\n        { /* change code above this line */ }\\n        <h1>Current Item Count: {this.state.itemCount}</h1>\\n      </div>\\n    );\\n  }\\n};\",\"head\":\"\",\"tail\":\"ReactDOM.render(<MyComponent />, document.getElementById('root'))\"}}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":\"<body><div id='root'></div><div id='challenge-node'></div>${ source || '' }</body>\",\"required\":[{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react@16.4.0/umd/react.production.min.js\"},{\"link\":null,\"raw\":null,\"src\":\"https://unpkg.com/react-dom@16.4.0/umd/react-dom.production.min.js\"}],\"nextChallengePath\":\"/front-end-libraries/react/use-state-to-toggle-an-element\",\"id\":\"5a24c314108439a4d4036174\"},\"slug\":\"/front-end-libraries/react/bind-this-to-a-class-method\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/front-end-libraries-react-bind-this-to-a-class-method.json\n// module id = 3570\n// module chunks = 182720183700705"],"sourceRoot":""}
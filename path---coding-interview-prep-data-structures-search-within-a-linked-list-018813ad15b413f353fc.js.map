{"version":3,"sources":["webpack:///path---coding-interview-prep-data-structures-search-within-a-linked-list-018813ad15b413f353fc.js","webpack:///./.cache/json/coding-interview-prep-data-structures-search-within-a-linked-list.json"],"names":["webpackJsonp","2852","module","exports","data","challengeNode","title","description","challengeType","fields","slug","blockName","tests","text","testString","required","files","indexhtml","indexjs","key","ext","name","contents","head","tail","indexjsx","pathContext","challengeMeta","introPath","template","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,8BAAAC,aAAA,+iBAAAC,cAAA,EAAAC,QAAgoBC,KAAA,qEAAAC,UAAA,kBAAAC,QAAoHC,KAAA,oDAAAC,WAAA,2JAAmOD,KAAA,sDAAAC,WAAA,+JAAyOD,KAAA,gCAAAC,WAAA,0KAA8ND,KAAA,sCAAAC,WAAA,2LAAqPD,KAAA,wCAAAC,WAAA,6LAAwPC,YAAAC,OAAwBC,UAAA,KAAAC,SAA4BC,IAAA,UAAAC,IAAA,KAAAC,KAAA,QAAAC,SAAA,giCAAmlCC,KAAA,GAAAC,KAAA,IAAsBC,SAAA,QAAmBC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,KAAAd,YAAAe,kBAAA,qFAAAC,GAAA,4BAAsLrB,KAAA","file":"path---coding-interview-prep-data-structures-search-within-a-linked-list-018813ad15b413f353fc.js","sourcesContent":["webpackJsonp([32953750082296],{\n\n/***/ 2852:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Search within a Linked List\",\"description\":[\"现在我们来为链表添加一些更加实用的方法。例如我们可以加一个判断链表是否为空的方法，就像之前我们给<code>Stack</code>和<code>Queue</code>添加的一样。\",\"我们还应该有一个在链表中找某一个具体的元素的方法。对于任何一种数据结构，你都应该在学习时了解它们的遍历方式。现在我们来创建一个<code>indexOf</code>方法，该方法接收一个<code>element</code>作为参数并返回该元素在链表中的索引值。如果该元素不存在就返回<code>-1</code>。\",\"除此之外，我们再来写一个实现相反功能的方法：<code>elementAt</code>，该方法接收一个<code>index</code>为参数，返回对应位置的<code>element</code>。如果<code>element</code>没找到就返回<code>undefined</code>。\",\"<hr>\",\"请编写<code>isEmpty</code>方法来判断链表是否为空，<code>indexOf</code>方法返回给定元素的<code>index</code>，<code>elementAt</code>方法返回给定位置的<code>element</code>值。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/coding-interview-prep/data-structures/search-within-a-linked-list\",\"blockName\":\"Data Structures\",\"tests\":[{\"text\":\"<code>LinkedList</code>应该有<code>indexOf</code>方法。\",\"testString\":\"assert((function(){var test = new LinkedList(); return (typeof test.indexOf === 'function')}()), '<code>LinkedList</code>应该有<code>indexOf</code>方法。');\"},{\"text\":\"<code>LinkedList</code>应该有<code>elementAt</code>方法。\",\"testString\":\"assert((function(){var test = new LinkedList(); return (typeof test.elementAt === 'function')}()), '<code>LinkedList</code>应该有<code>elementAt</code>方法。');\"},{\"text\":\"<code>size</code>方法应该返回链表的长度。\",\"testString\":\"assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten'); return test.size() === 3}()), '<code>size</code>方法应该返回链表的长度。');\"},{\"text\":\"<code>indexOf</code>方法应该返回给定元素的索引值。\",\"testString\":\"assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten'); return test.indexOf('kitten') === 2}()), '<code>indexOf</code>方法应该返回给定元素的索引值。');\"},{\"text\":\"<code>elementAt</code>方法应该返回对应位置的元素值。\",\"testString\":\"assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten'); return test.elementAt(1) === 'dog'}()), '<code>elementAt</code>方法应该返回对应位置的元素值。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"function LinkedList() { \\n  var length = 0; \\n  var head = null; \\n\\n  var Node = function(element){ // {1} \\n    this.element = element; \\n    this.next = null; \\n  }; \\n\\n  this.size = function() {\\n    return length;\\n  };\\n\\n  this.head = function(){\\n    return head;\\n  };\\n\\n  this.add = function(element){\\n    var node = new Node(element);\\n    if(head === null){\\n        head = node;\\n    } else {\\n        currentNode = head;\\n\\n        while(currentNode.next){\\n            currentNode  = currentNode.next;\\n        }\\n\\n        currentNode.next = node;\\n    }\\n\\n    length++;\\n  }; \\n\\n  this.remove = function(element){\\n    var currentNode = head;\\n    var previousNode;\\n    if(currentNode.element === element){\\n        head = currentNode.next;\\n    } else {\\n        while(currentNode.element !== element) {\\n            previousNode = currentNode;\\n            currentNode = currentNode.next;\\n        }\\n\\n        previousNode.next = currentNode.next;\\n    }\\n\\n    length --;\\n  };\\n\\n  // 请把你的代码写在这条注释以下\\n\\n  // 请把你的代码写在这条注释以上\\n}\",\"head\":\"\",\"tail\":\"\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/coding-interview-prep/data-structures/remove-elements-from-a-linked-list-by-index\",\"id\":\"587d8251367417b2b2512c64\"},\"slug\":\"/coding-interview-prep/data-structures/search-within-a-linked-list\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---coding-interview-prep-data-structures-search-within-a-linked-list-018813ad15b413f353fc.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Search within a Linked List\",\"description\":[\"现在我们来为链表添加一些更加实用的方法。例如我们可以加一个判断链表是否为空的方法，就像之前我们给<code>Stack</code>和<code>Queue</code>添加的一样。\",\"我们还应该有一个在链表中找某一个具体的元素的方法。对于任何一种数据结构，你都应该在学习时了解它们的遍历方式。现在我们来创建一个<code>indexOf</code>方法，该方法接收一个<code>element</code>作为参数并返回该元素在链表中的索引值。如果该元素不存在就返回<code>-1</code>。\",\"除此之外，我们再来写一个实现相反功能的方法：<code>elementAt</code>，该方法接收一个<code>index</code>为参数，返回对应位置的<code>element</code>。如果<code>element</code>没找到就返回<code>undefined</code>。\",\"<hr>\",\"请编写<code>isEmpty</code>方法来判断链表是否为空，<code>indexOf</code>方法返回给定元素的<code>index</code>，<code>elementAt</code>方法返回给定位置的<code>element</code>值。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/coding-interview-prep/data-structures/search-within-a-linked-list\",\"blockName\":\"Data Structures\",\"tests\":[{\"text\":\"<code>LinkedList</code>应该有<code>indexOf</code>方法。\",\"testString\":\"assert((function(){var test = new LinkedList(); return (typeof test.indexOf === 'function')}()), '<code>LinkedList</code>应该有<code>indexOf</code>方法。');\"},{\"text\":\"<code>LinkedList</code>应该有<code>elementAt</code>方法。\",\"testString\":\"assert((function(){var test = new LinkedList(); return (typeof test.elementAt === 'function')}()), '<code>LinkedList</code>应该有<code>elementAt</code>方法。');\"},{\"text\":\"<code>size</code>方法应该返回链表的长度。\",\"testString\":\"assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten'); return test.size() === 3}()), '<code>size</code>方法应该返回链表的长度。');\"},{\"text\":\"<code>indexOf</code>方法应该返回给定元素的索引值。\",\"testString\":\"assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten'); return test.indexOf('kitten') === 2}()), '<code>indexOf</code>方法应该返回给定元素的索引值。');\"},{\"text\":\"<code>elementAt</code>方法应该返回对应位置的元素值。\",\"testString\":\"assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten'); return test.elementAt(1) === 'dog'}()), '<code>elementAt</code>方法应该返回对应位置的元素值。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"function LinkedList() { \\n  var length = 0; \\n  var head = null; \\n\\n  var Node = function(element){ // {1} \\n    this.element = element; \\n    this.next = null; \\n  }; \\n\\n  this.size = function() {\\n    return length;\\n  };\\n\\n  this.head = function(){\\n    return head;\\n  };\\n\\n  this.add = function(element){\\n    var node = new Node(element);\\n    if(head === null){\\n        head = node;\\n    } else {\\n        currentNode = head;\\n\\n        while(currentNode.next){\\n            currentNode  = currentNode.next;\\n        }\\n\\n        currentNode.next = node;\\n    }\\n\\n    length++;\\n  }; \\n\\n  this.remove = function(element){\\n    var currentNode = head;\\n    var previousNode;\\n    if(currentNode.element === element){\\n        head = currentNode.next;\\n    } else {\\n        while(currentNode.element !== element) {\\n            previousNode = currentNode;\\n            currentNode = currentNode.next;\\n        }\\n\\n        previousNode.next = currentNode.next;\\n    }\\n\\n    length --;\\n  };\\n\\n  // 请把你的代码写在这条注释以下\\n\\n  // 请把你的代码写在这条注释以上\\n}\",\"head\":\"\",\"tail\":\"\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/coding-interview-prep/data-structures/remove-elements-from-a-linked-list-by-index\",\"id\":\"587d8251367417b2b2512c64\"},\"slug\":\"/coding-interview-prep/data-structures/search-within-a-linked-list\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/coding-interview-prep-data-structures-search-within-a-linked-list.json\n// module id = 2852\n// module chunks = 32953750082296"],"sourceRoot":""}
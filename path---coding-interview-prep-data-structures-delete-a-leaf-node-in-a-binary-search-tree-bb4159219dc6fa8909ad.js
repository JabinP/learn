webpackJsonp([91474788922070],{2831:function(e,n){e.exports={data:{challengeNode:{title:"Delete a Leaf Node in a Binary Search Tree",description:["在接下来的三个挑战中，我们实现二叉查找树中更为复杂的操作——删除。之所以说删除操作很复杂，是因为移除节点会破坏树中已经建立好的连接。为了保证树结构的完整性，这些连接必须周密地重新建立，某些删除操作甚至可能导致树的所有节点都需要重排。对于删除树中的节点，我们可以根据要删除的节点类型，来分以下三种情况讨论：","叶子节点：要删除的节点没有子节点。","一个子节点：要删除的节点只有一个子节点。","两个子节点：要删除的节点有两个子节点。","移除叶子节点很简单，直接删除即可。删除拥有一个子节点的节点也相对简单，我们直接移除该节点，并让其父节点指向这个被删除节点的子节点即可。移除拥有两个子节点的节点就比较困难，因为我们需要让被移除节点的两个子节点重新连上被移除节点的父节点，我们会在第三节挑战当中学习如何处理这种情况。此外，在执行删除操作时，我们需要考虑一些极端情况。如果树为空该怎么处理？如果删除的是根节点又该如何处理？如果树结构中只有两个元素该怎么办？现在我们就来熟悉一下第一种情况，如何删除一个叶子节点。","挑战说明：在二叉树中创建<code>remove</code>方法，我们需要为删除操作设计内部逻辑。首先，我们在<code>remove</code>方法中需要创建一个函数，来从树中找出我们想要删除的那个节点。如果树结构当中不存在该节点，则<code>remove</code>方法应返回<code>null</code>；如果要删除的目标节点是叶子结点（无子节点），其父节点就应该指向<code>null</code>。这样做可以很高效地从树结构中删除节点。我们还需要一个方法检测某一个节点的子节点数量，因为我们需要据此决定采取哪种删除策略。","我们会在之后的两个挑战中处理后面的两个情况。一起加油！"],challengeType:1,fields:{slug:"/coding-interview-prep/data-structures/delete-a-leaf-node-in-a-binary-search-tree",blockName:"Data Structures",tests:[{text:"<code>BinarySearchTree</code>数据结构应该存在。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');"},{text:"<code>BinarySearchTree</code>应该有<code>remove</code>方法。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.remove == 'function')})(), '<code>BinarySearchTree</code>应该有<code>remove</code>方法。');"},{text:"试图移除不存在的元素时，<code>remove</code>方法应返回<code>null</code>。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; return (test.remove(100) == null); })(), '试图移除不存在的元素时，<code>remove</code>方法应返回<code>null</code>。');"},{text:"如果根节点无子节点，那么删除此节点之后应将该根节点设置为<code>null</code>。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(500); test.remove(500); return (test.inorder() == null); })(), '如果根节点无子节点，那么删除此节点之后应将该根节点设置为<code>null</code>。');"},{text:"<code>remove</code>方法应可以从树结构中删除叶子节点。",testString:"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(5); test.add(3); test.add(7); test.add(6); test.add(10); test.add(12); test.remove(3); test.remove(12); test.remove(10); return (test.inorder().join('') == '567'); })(), '<code>remove</code>方法应可以从树结构中删除叶子节点。');"}]},required:[],files:{indexhtml:null,indexjs:{key:"indexjs",ext:"js",name:"index",contents:"var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n}\n\nfunction BinarySearchTree() {\n    this.root = null;\n    // 情况 1：要删除的节点没有子节点。请把你的代码写在这条注释以下\n}",head:"",tail:"BinarySearchTree.prototype = {\n    add: function(value) {\n        var node = this.root;\n        if (node == null) {\n          this.root = new Node(value);\n          return;\n        } else {\n            function searchTree(node) {\n                if (value < node.value) {\n                    if (node.left == null) {\n                        node.left = new Node(value);\n                        return;\n                    } else if (node.left != null) {\n                        return searchTree(node.left)\n                    };\n                } else if (value > node.value) {\n                    if (node.right == null) {\n                        node.right = new Node(value);\n                        return;\n                    } else if (node.right != null) {\n                        return searchTree(node.right);\n                    };\n                } else {\n                    return null;\n                };\n            };\n            return searchTree(node);\n        };\n    },\n    inorder: function() {\n        if (this.root == null) {\n          return null;\n        } else {\n          var result = new Array();\n          function traverseInOrder(node) {\n              if (node.left != null) {\n                  traverseInOrder(node.left);\n              };\n              result.push(node.value);\n              if (node.right != null) {\n                  traverseInOrder(node.right);\n              };\n          }\n          traverseInOrder(this.root);\n          return result;\n        };\n    },    \n    isBinarySearchTree() {\n        if (this.root == null) {\n            return null;\n        } else {\n            var check = true;\n            function checkTree(node) {\n                if (node.left != null) {\n                    var left = node.left;\n                    if (left.value > node.value) {\n                        check = false;\n                    } else {\n                        checkTree(left);\n                    }\n                }\n                if (node.right != null) {\n                    var right = node.right;\n                    if (right.value < node.value) {\n                        check = false;\n                    } else {\n                        checkTree(right);\n                    };\n                };\n            };\n            checkTree(this.root);\n            return check;\n        }\n    }\n};"},indexjsx:null}}},pathContext:{challengeMeta:{introPath:"",template:null,required:[],nextChallengePath:"/coding-interview-prep/data-structures/delete-a-node-with-one-child-in-a-binary-search-tree",id:"587d8258367417b2b2512c80"},slug:"/coding-interview-prep/data-structures/delete-a-leaf-node-in-a-binary-search-tree"}}}});
//# sourceMappingURL=path---coding-interview-prep-data-structures-delete-a-leaf-node-in-a-binary-search-tree-bb4159219dc6fa8909ad.js.map
{"version":3,"sources":["webpack:///path---javascript-algorithms-and-data-structures-regular-expressions-positive-and-negative-lookahead-9b1eef76fbf3badd348e.js","webpack:///./.cache/json/javascript-algorithms-and-data-structures-regular-expressions-positive-and-negative-lookahead.json"],"names":["webpackJsonp","4003","module","exports","data","challengeNode","title","description","challengeType","fields","slug","blockName","tests","text","testString","required","files","indexhtml","indexjs","key","ext","name","contents","head","tail","indexjsx","pathContext","challengeMeta","introPath","template","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,kCAAAC,aAAA,inBAAgpB,oOAAyO,8EAAAC,cAAA,EAAAC,QAAyIC,KAAA,iGAAAC,UAAA,sBAAAC,QAAoJC,KAAA,oCAAAC,WAAA,8GAAsKD,KAAA,wCAAAC,WAAA,mFAAmJD,KAAA,wCAAAC,WAAA,mFAAmJD,KAAA,oCAAAC,WAAA,2EAAuID,KAAA,oCAAAC,WAAA,2EAAuID,KAAA,kCAAAC,WAAA,uEAAiID,KAAA,mCAAAC,WAAA,0EAAoIC,YAAAC,OAAwBC,UAAA,KAAAC,SAA4BC,IAAA,UAAAC,IAAA,KAAAC,KAAA,QAAAC,SAAA,0GAA+JC,KAAA,GAAAC,KAAA,IAAsBC,SAAA,QAAmBC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,KAAAd,YAAAe,kBAAA,qGAAAC,GAAA,4BAAsMrB,KAAA","file":"path---javascript-algorithms-and-data-structures-regular-expressions-positive-and-negative-lookahead-9b1eef76fbf3badd348e.js","sourcesContent":["webpackJsonp([130228215078182],{\n\n/***/ 4003:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Positive and Negative Lookahead\",\"description\":[\"<code>先行断言</code>是告诉 JavaScript 在字符串中向前查找的匹配模式。当你想要在同一个字符串上搜寻多个匹配模式时，这可能非常有用。\",\"有两种<code>先行断言</code>：<code>正向先行断言</code>和<code>负向先行断言</code>。\",\"<code>正向先行断言</code>会查看并确保搜索匹配模式中的元素存在，但实际上并不匹配。正向先行断言的用法是<code>(?=...)</code>，其中<code>...</code>就是需要存在但不会被匹配的部分。\",\"另一方面，<code>负向先行断言</code>会查看并确保搜索匹配模式中的元素不存在。负向先行断言的用法是<code>(?!...)</code>，其中<code>...</code>是你希望不存在的匹配模式。如果负向先行断言部分不存在，将返回匹配模式的其余部分。\",\"尽管先行断言有点儿令人困惑，但是这些示例会有所帮助。\",\"<blockquote>let quit = \\\"qu\\\";<br>let noquit = \\\"qt\\\";<br>let quRegex= /q(?=u)/;<br>let qRegex = /q(?!u)/;<br>quit.match(quRegex); // Returns [\\\"q\\\"]<br>noquit.match(qRegex); // Returns [\\\"q\\\"]</blockquote>\",\"<code>先行断言</code>的更实际用途是检查一个字符串中的两个或更多匹配模式。这里有一个简单的密码检查器，密码规则是 3 到 6 个字符且至少包含一个数字：\",\"<blockquote>let password = \\\"abc123\\\";<br>let checkPass = /(?=\\\\w{3,6})(?=\\\\D*\\\\d)/;<br>checkPass.test(password); // Returns true</blockquote>\",\"<hr>\",\"在正则表达式<code>pwRegex</code>中使用<code>先行断言</code>以匹配至少5个字符且有两个连续数字的密码。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/javascript-algorithms-and-data-structures/regular-expressions/positive-and-negative-lookahead\",\"blockName\":\"Regular Expressions\",\"tests\":[{\"text\":\"你的正则表达式应该使用两个正向<code>先行断言</code>。\",\"testString\":\"assert(pwRegex.source.match(/\\\\(\\\\?=.*?\\\\)\\\\(\\\\?=.*?\\\\)/) !== null, '你的正则表达式应该使用两个正向<code>先行断言</code>。');\"},{\"text\":\"你的正则表达式不应该匹配<code>\\\"astronaut\\\"</code>。\",\"testString\":\"assert(!pwRegex.test(\\\"astronaut\\\"), '你的正则表达式不应该匹配<code>\\\"astronaut\\\"</code>。');\"},{\"text\":\"你的正则表达式不应该匹配<code>\\\"airplanes\\\"</code>。\",\"testString\":\"assert(!pwRegex.test(\\\"airplanes\\\"), '你的正则表达式不应该匹配<code>\\\"airplanes\\\"</code>。');\"},{\"text\":\"你的正则表达式应该匹配<code>\\\"bana12\\\"</code>。\",\"testString\":\"assert(pwRegex.test(\\\"bana12\\\"), '你的正则表达式应该匹配<code>\\\"bana12\\\"</code>。');\"},{\"text\":\"你的正则表达式应该匹配<code>\\\"abc123\\\"</code>。\",\"testString\":\"assert(pwRegex.test(\\\"abc123\\\"), '你的正则表达式应该匹配<code>\\\"abc123\\\"</code>。');\"},{\"text\":\"你的正则表达式不应该匹配<code>\\\"123\\\"</code>。\",\"testString\":\"assert(!pwRegex.test(\\\"123\\\"), '你的正则表达式不应该匹配<code>\\\"123\\\"</code>。');\"},{\"text\":\"你的正则表达式不应该匹配<code>\\\"1234\\\"</code>。\",\"testString\":\"assert(!pwRegex.test(\\\"1234\\\"), '你的正则表达式不应该匹配<code>\\\"1234\\\"</code>。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"let sampleWord = \\\"astronaut\\\";\\nlet pwRegex = /change/; // 修改这一行\\nlet result = pwRegex.test(sampleWord);\",\"head\":\"\",\"tail\":\"\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/javascript-algorithms-and-data-structures/regular-expressions/reuse-patterns-using-capture-groups\",\"id\":\"587d7dba367417b2b2512ba9\"},\"slug\":\"/javascript-algorithms-and-data-structures/regular-expressions/positive-and-negative-lookahead\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---javascript-algorithms-and-data-structures-regular-expressions-positive-and-negative-lookahead-9b1eef76fbf3badd348e.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Positive and Negative Lookahead\",\"description\":[\"<code>先行断言</code>是告诉 JavaScript 在字符串中向前查找的匹配模式。当你想要在同一个字符串上搜寻多个匹配模式时，这可能非常有用。\",\"有两种<code>先行断言</code>：<code>正向先行断言</code>和<code>负向先行断言</code>。\",\"<code>正向先行断言</code>会查看并确保搜索匹配模式中的元素存在，但实际上并不匹配。正向先行断言的用法是<code>(?=...)</code>，其中<code>...</code>就是需要存在但不会被匹配的部分。\",\"另一方面，<code>负向先行断言</code>会查看并确保搜索匹配模式中的元素不存在。负向先行断言的用法是<code>(?!...)</code>，其中<code>...</code>是你希望不存在的匹配模式。如果负向先行断言部分不存在，将返回匹配模式的其余部分。\",\"尽管先行断言有点儿令人困惑，但是这些示例会有所帮助。\",\"<blockquote>let quit = \\\"qu\\\";<br>let noquit = \\\"qt\\\";<br>let quRegex= /q(?=u)/;<br>let qRegex = /q(?!u)/;<br>quit.match(quRegex); // Returns [\\\"q\\\"]<br>noquit.match(qRegex); // Returns [\\\"q\\\"]</blockquote>\",\"<code>先行断言</code>的更实际用途是检查一个字符串中的两个或更多匹配模式。这里有一个简单的密码检查器，密码规则是 3 到 6 个字符且至少包含一个数字：\",\"<blockquote>let password = \\\"abc123\\\";<br>let checkPass = /(?=\\\\w{3,6})(?=\\\\D*\\\\d)/;<br>checkPass.test(password); // Returns true</blockquote>\",\"<hr>\",\"在正则表达式<code>pwRegex</code>中使用<code>先行断言</code>以匹配至少5个字符且有两个连续数字的密码。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/javascript-algorithms-and-data-structures/regular-expressions/positive-and-negative-lookahead\",\"blockName\":\"Regular Expressions\",\"tests\":[{\"text\":\"你的正则表达式应该使用两个正向<code>先行断言</code>。\",\"testString\":\"assert(pwRegex.source.match(/\\\\(\\\\?=.*?\\\\)\\\\(\\\\?=.*?\\\\)/) !== null, '你的正则表达式应该使用两个正向<code>先行断言</code>。');\"},{\"text\":\"你的正则表达式不应该匹配<code>\\\"astronaut\\\"</code>。\",\"testString\":\"assert(!pwRegex.test(\\\"astronaut\\\"), '你的正则表达式不应该匹配<code>\\\"astronaut\\\"</code>。');\"},{\"text\":\"你的正则表达式不应该匹配<code>\\\"airplanes\\\"</code>。\",\"testString\":\"assert(!pwRegex.test(\\\"airplanes\\\"), '你的正则表达式不应该匹配<code>\\\"airplanes\\\"</code>。');\"},{\"text\":\"你的正则表达式应该匹配<code>\\\"bana12\\\"</code>。\",\"testString\":\"assert(pwRegex.test(\\\"bana12\\\"), '你的正则表达式应该匹配<code>\\\"bana12\\\"</code>。');\"},{\"text\":\"你的正则表达式应该匹配<code>\\\"abc123\\\"</code>。\",\"testString\":\"assert(pwRegex.test(\\\"abc123\\\"), '你的正则表达式应该匹配<code>\\\"abc123\\\"</code>。');\"},{\"text\":\"你的正则表达式不应该匹配<code>\\\"123\\\"</code>。\",\"testString\":\"assert(!pwRegex.test(\\\"123\\\"), '你的正则表达式不应该匹配<code>\\\"123\\\"</code>。');\"},{\"text\":\"你的正则表达式不应该匹配<code>\\\"1234\\\"</code>。\",\"testString\":\"assert(!pwRegex.test(\\\"1234\\\"), '你的正则表达式不应该匹配<code>\\\"1234\\\"</code>。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"let sampleWord = \\\"astronaut\\\";\\nlet pwRegex = /change/; // 修改这一行\\nlet result = pwRegex.test(sampleWord);\",\"head\":\"\",\"tail\":\"\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/javascript-algorithms-and-data-structures/regular-expressions/reuse-patterns-using-capture-groups\",\"id\":\"587d7dba367417b2b2512ba9\"},\"slug\":\"/javascript-algorithms-and-data-structures/regular-expressions/positive-and-negative-lookahead\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/javascript-algorithms-and-data-structures-regular-expressions-positive-and-negative-lookahead.json\n// module id = 4003\n// module chunks = 130228215078182"],"sourceRoot":""}
{"version":3,"sources":["webpack:///path---javascript-algorithms-and-data-structures-functional-programming-avoid-mutations-and-side-effects-using-functional-programming-34da7b0c9bf975a67642.js","webpack:///./.cache/json/javascript-algorithms-and-data-structures-functional-programming-avoid-mutations-and-side-effects-using-functional-programming.json"],"names":["webpackJsonp","3903","module","exports","data","challengeNode","title","description","challengeType","fields","slug","blockName","tests","text","testString","required","files","indexhtml","indexjs","key","ext","name","contents","head","tail","indexjsx","pathContext","challengeMeta","introPath","template","nextChallengePath","id"],"mappings":"AAAAA,cAAc,gBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,gEAAAC,aAAA,0jBAAAC,cAAA,EAAAC,QAA6qBC,KAAA,kIAAAC,UAAA,yBAAAC,QAAwLC,KAAA,2DAAAC,WAAA,4FAA2KD,KAAA,+DAAAC,WAAA,6FAA+KC,YAAAC,OAAwBC,UAAA,KAAAC,SAA4BC,IAAA,UAAAC,IAAA,KAAAC,KAAA,QAAAC,SAAA,0LAAoOC,KAAA,GAAAC,KAAA,IAA+BC,SAAA,QAAmBC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,KAAAd,YAAAe,kBAAA,8HAAAC,GAAA,4BAA+NrB,KAAA","file":"path---javascript-algorithms-and-data-structures-functional-programming-avoid-mutations-and-side-effects-using-functional-programming-34da7b0c9bf975a67642.js","sourcesContent":["webpackJsonp([7284448460238],{\n\n/***/ 3903:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Avoid Mutations and Side Effects Using Functional Programming\",\"description\":[\"如果你还没想通，上一个挑战的问题出在<code>tabClose()</code>函数里的<code>splice</code>。不幸的是，<code>splice</code>修改了调用它的原始数组，所以第二次调用它时是基于修改后的数组，才给出了意料之外的结果。\",\"这是一个小例子，还有更广义的定义——你在变量，数组或对象上调用一个函数，这个函数会改变对象中的变量或其他东西。\",\"函数式编程的核心原则之一是不改变任何东西。变化会导致错误。如果一个函数不改变传入的参数、全局变量等数据，那么它造成问题的可能性就会小很多。\",\"前面的例子没有任何复杂的操作，但是<code>splice</code>方法改变了原始数组，导致 bug 产生。\",\"回想一下，在函数式编程中，改变或变更叫做<code>mutation</code>，这种改变的结果叫做“副作用”（<code>side effect</code>）。理想情况下，函数应该是不会产生任何副作用的<code>pure function</code>。\",\"让我们尝试掌握这个原则：不要改变代码中的任何变量或对象。\",\"<hr>\",\"填写<code>incrementer</code>函数的代码，使其返回全局变量<code>fixedValue</code>的值增加 1。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/javascript-algorithms-and-data-structures/functional-programming/avoid-mutations-and-side-effects-using-functional-programming\",\"blockName\":\"Functional Programming\",\"tests\":[{\"text\":\"<code>incrementer</code>函数不能改变<code>fixedValue</code>的值。\",\"testString\":\"assert(fixedValue === 4, '你的<code>incrementer</code>函数不能改变<code>fixedValue</code>的值。');\"},{\"text\":\"<code>incrementer</code>函数应返回比<code>fixedValue</code>变量更大的值。\",\"testString\":\"assert(newValue === 5, '<code>incrementer</code>函数应返回比<code>fixedValue</code>变量更大的值。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"// 全局变量\\nvar fixedValue = 4;\\n\\nfunction incrementer () {\\n  // 请在本行以下添加你的代码\\n  \\n  \\n  // 请在本行以上添加你的代码\\n}\\n\\nvar newValue = incrementer(); // 应等于 5\\nconsole.log(fixedValue); // 应打印 4\",\"head\":\"\",\"tail\":\"\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/javascript-algorithms-and-data-structures/functional-programming/pass-arguments-to-avoid-external-dependence-in-a-function\",\"id\":\"587d7b8e367417b2b2512b5e\"},\"slug\":\"/javascript-algorithms-and-data-structures/functional-programming/avoid-mutations-and-side-effects-using-functional-programming\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---javascript-algorithms-and-data-structures-functional-programming-avoid-mutations-and-side-effects-using-functional-programming-34da7b0c9bf975a67642.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Avoid Mutations and Side Effects Using Functional Programming\",\"description\":[\"如果你还没想通，上一个挑战的问题出在<code>tabClose()</code>函数里的<code>splice</code>。不幸的是，<code>splice</code>修改了调用它的原始数组，所以第二次调用它时是基于修改后的数组，才给出了意料之外的结果。\",\"这是一个小例子，还有更广义的定义——你在变量，数组或对象上调用一个函数，这个函数会改变对象中的变量或其他东西。\",\"函数式编程的核心原则之一是不改变任何东西。变化会导致错误。如果一个函数不改变传入的参数、全局变量等数据，那么它造成问题的可能性就会小很多。\",\"前面的例子没有任何复杂的操作，但是<code>splice</code>方法改变了原始数组，导致 bug 产生。\",\"回想一下，在函数式编程中，改变或变更叫做<code>mutation</code>，这种改变的结果叫做“副作用”（<code>side effect</code>）。理想情况下，函数应该是不会产生任何副作用的<code>pure function</code>。\",\"让我们尝试掌握这个原则：不要改变代码中的任何变量或对象。\",\"<hr>\",\"填写<code>incrementer</code>函数的代码，使其返回全局变量<code>fixedValue</code>的值增加 1。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/javascript-algorithms-and-data-structures/functional-programming/avoid-mutations-and-side-effects-using-functional-programming\",\"blockName\":\"Functional Programming\",\"tests\":[{\"text\":\"<code>incrementer</code>函数不能改变<code>fixedValue</code>的值。\",\"testString\":\"assert(fixedValue === 4, '你的<code>incrementer</code>函数不能改变<code>fixedValue</code>的值。');\"},{\"text\":\"<code>incrementer</code>函数应返回比<code>fixedValue</code>变量更大的值。\",\"testString\":\"assert(newValue === 5, '<code>incrementer</code>函数应返回比<code>fixedValue</code>变量更大的值。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"// 全局变量\\nvar fixedValue = 4;\\n\\nfunction incrementer () {\\n  // 请在本行以下添加你的代码\\n  \\n  \\n  // 请在本行以上添加你的代码\\n}\\n\\nvar newValue = incrementer(); // 应等于 5\\nconsole.log(fixedValue); // 应打印 4\",\"head\":\"\",\"tail\":\"\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/javascript-algorithms-and-data-structures/functional-programming/pass-arguments-to-avoid-external-dependence-in-a-function\",\"id\":\"587d7b8e367417b2b2512b5e\"},\"slug\":\"/javascript-algorithms-and-data-structures/functional-programming/avoid-mutations-and-side-effects-using-functional-programming\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/javascript-algorithms-and-data-structures-functional-programming-avoid-mutations-and-side-effects-using-functional-programming.json\n// module id = 3903\n// module chunks = 7284448460238"],"sourceRoot":""}
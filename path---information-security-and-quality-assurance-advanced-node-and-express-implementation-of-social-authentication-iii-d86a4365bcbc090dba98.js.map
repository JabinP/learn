{"version":3,"sources":["webpack:///path---information-security-and-quality-assurance-advanced-node-and-express-implementation-of-social-authentication-iii-d86a4365bcbc090dba98.js","webpack:///./.cache/json/information-security-and-quality-assurance-advanced-node-and-express-implementation-of-social-authentication-iii.json"],"names":["webpackJsonp","3657","module","exports","data","challengeNode","title","guideUrl","description","challengeType","fields","blockName","slug","tests","text","testString","pathContext","challengeMeta","introPath","template","required","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,8CAAAC,SAAA,KAAAC,aAAA,mbAA2f,kjBAAujB,mcAAAC,cAAA,EAAAC,QAAueC,UAAA,4BAAAC,KAAA,oHAAAC,QAA6KC,KAAA,kBAAAC,WAAA,mYAAwaC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,KAAAC,YAAAC,kBAAA,+FAAAC,GAAA,4BAAgMV,KAAA","file":"path---information-security-and-quality-assurance-advanced-node-and-express-implementation-of-social-authentication-iii-d86a4365bcbc090dba98.js","sourcesContent":["webpackJsonp([127618460310458],{\n\n/***/ 3657:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Implementation of Social Authentication III\",\"guideUrl\":null,\"description\":[\"注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-socialauth/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-socialauth/'>GitHub</a> 上克隆。\",\"验证策略的最后一部分是处理从 GitHub 返回的个人信息。如果用户存在，我们就需要从数据库中读取用户数据并在 profile 页面加载；否则，我们需要把用户信息添加到数据库。GitHub 在用户信息中为我们提供了独一无二的 <em>id</em>，我们可以通过序列化的 id 在数据库中搜索用户（已实现）。以下是这个逻辑的实现示例，我们应该把它传到新策略的第二个参数，就是目前<code>console.log(profile);</code>的下方：\",\"<pre>db.collection('socialusers').findAndModify(\\n    {id: profile.id},\\n    {},\\n    {$setOnInsert:{\\n        id: profile.id,\\n        name: profile.displayName || 'John Doe',\\n        photo: profile.photos[0].value || '',\\n        email: profile.emails[0].value || 'No public email',\\n        created_on: new Date(),\\n        provider: profile.provider || ''\\n    },$set:{\\n        last_login: new Date()\\n    },$inc:{\\n        login_count: 1\\n    }},\\n    {upsert:true, new: true},\\n    (err, doc) => {\\n        return cb(null, doc.value);\\n    }\\n);</pre>\",\"<code>findAndModify</code>的作用是在数据库中查询对象并更新，如果对象不存在，我们也可以<code>upsert</code>（注，upsert 可以理解为 update + insert）它，然后我们可以在回调方法里获取到插入数据后的新对象。在这个例子中，我们会把 last_login 设置成为 now，而且总会为 login_count 加 1。只有在插入一个新对象（新用户）时，我们才会初始化这些字段。另外，还需要注意默认值的使用。有时返回的用户信息可能不全，可能是因为用户没有填写，也可能是因为用户选择不公开一部分信息。在这种情况下，我们需要进行相应的处理，以防我们的 app 报错。\",\"你现在应该可以登录你的应用了，试试吧。完成上述要求后，你就可以在左边提交你的页面链接。如果运行出错，你可以在 <a href='https://glitch.com/#!/project/guttural-birch'>here</a> 这里检查这个迷你项目的完成代码。\"],\"challengeType\":2,\"fields\":{\"blockName\":\"Advanced Node and Express\",\"slug\":\"/information-security-and-quality-assurance/advanced-node-and-express/implementation-of-social-authentication-iii\",\"tests\":[{\"text\":\"GitHub 策略应配置完成。\",\"testString\":\"getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /GitHubStrategy[^]*db.collection/gi, '应在当前 GitHub 策略中调用数据库方法，查找用户。'); assert.match(data, /GitHubStrategy[^]*socialusers/gi, '策略应使用 \\\"socialusers\\\" collection。'); assert.match(data, /GitHubStrategy[^]*return cb/gi, '策略应返回回调方法 \\\"cb\\\"'); }, xhr => { throw new Error(xhr.statusText); })\"}]}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/information-security-and-quality-assurance/advanced-node-and-express/set-up-the-environment\",\"id\":\"589a8eb3f9fc0f352b528e72\"},\"slug\":\"/information-security-and-quality-assurance/advanced-node-and-express/implementation-of-social-authentication-iii\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---information-security-and-quality-assurance-advanced-node-and-express-implementation-of-social-authentication-iii-d86a4365bcbc090dba98.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Implementation of Social Authentication III\",\"guideUrl\":null,\"description\":[\"注意，本项目在<a href='https://glitch.com/#!/import/github/freeCodeCamp/boilerplate-socialauth/'>这个 Glitch 项目</a>的基础上进行开发，你也可以从 <a href='https://github.com/freeCodeCamp/boilerplate-socialauth/'>GitHub</a> 上克隆。\",\"验证策略的最后一部分是处理从 GitHub 返回的个人信息。如果用户存在，我们就需要从数据库中读取用户数据并在 profile 页面加载；否则，我们需要把用户信息添加到数据库。GitHub 在用户信息中为我们提供了独一无二的 <em>id</em>，我们可以通过序列化的 id 在数据库中搜索用户（已实现）。以下是这个逻辑的实现示例，我们应该把它传到新策略的第二个参数，就是目前<code>console.log(profile);</code>的下方：\",\"<pre>db.collection('socialusers').findAndModify(\\n    {id: profile.id},\\n    {},\\n    {$setOnInsert:{\\n        id: profile.id,\\n        name: profile.displayName || 'John Doe',\\n        photo: profile.photos[0].value || '',\\n        email: profile.emails[0].value || 'No public email',\\n        created_on: new Date(),\\n        provider: profile.provider || ''\\n    },$set:{\\n        last_login: new Date()\\n    },$inc:{\\n        login_count: 1\\n    }},\\n    {upsert:true, new: true},\\n    (err, doc) => {\\n        return cb(null, doc.value);\\n    }\\n);</pre>\",\"<code>findAndModify</code>的作用是在数据库中查询对象并更新，如果对象不存在，我们也可以<code>upsert</code>（注，upsert 可以理解为 update + insert）它，然后我们可以在回调方法里获取到插入数据后的新对象。在这个例子中，我们会把 last_login 设置成为 now，而且总会为 login_count 加 1。只有在插入一个新对象（新用户）时，我们才会初始化这些字段。另外，还需要注意默认值的使用。有时返回的用户信息可能不全，可能是因为用户没有填写，也可能是因为用户选择不公开一部分信息。在这种情况下，我们需要进行相应的处理，以防我们的 app 报错。\",\"你现在应该可以登录你的应用了，试试吧。完成上述要求后，你就可以在左边提交你的页面链接。如果运行出错，你可以在 <a href='https://glitch.com/#!/project/guttural-birch'>here</a> 这里检查这个迷你项目的完成代码。\"],\"challengeType\":2,\"fields\":{\"blockName\":\"Advanced Node and Express\",\"slug\":\"/information-security-and-quality-assurance/advanced-node-and-express/implementation-of-social-authentication-iii\",\"tests\":[{\"text\":\"GitHub 策略应配置完成。\",\"testString\":\"getUserInput => $.get(getUserInput('url')+ '/_api/server.js') .then(data => { assert.match(data, /GitHubStrategy[^]*db.collection/gi, '应在当前 GitHub 策略中调用数据库方法，查找用户。'); assert.match(data, /GitHubStrategy[^]*socialusers/gi, '策略应使用 \\\"socialusers\\\" collection。'); assert.match(data, /GitHubStrategy[^]*return cb/gi, '策略应返回回调方法 \\\"cb\\\"'); }, xhr => { throw new Error(xhr.statusText); })\"}]}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/information-security-and-quality-assurance/advanced-node-and-express/set-up-the-environment\",\"id\":\"589a8eb3f9fc0f352b528e72\"},\"slug\":\"/information-security-and-quality-assurance/advanced-node-and-express/implementation-of-social-authentication-iii\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/information-security-and-quality-assurance-advanced-node-and-express-implementation-of-social-authentication-iii.json\n// module id = 3657\n// module chunks = 127618460310458"],"sourceRoot":""}
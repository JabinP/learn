{"version":3,"sources":["webpack:///path---coding-interview-prep-data-structures-find-the-minimum-and-maximum-height-of-a-binary-search-tree-0d80ba67681d58e72d6b.js","webpack:///./.cache/json/coding-interview-prep-data-structures-find-the-minimum-and-maximum-height-of-a-binary-search-tree.json"],"names":["webpackJsonp","2835","module","exports","data","challengeNode","title","description","challengeType","fields","slug","blockName","tests","text","testString","required","files","indexhtml","indexjs","key","ext","name","contents","head","tail","indexjsx","pathContext","challengeMeta","introPath","template","nextChallengePath","id"],"mappings":"AAAAA,cAAc,iBAERC,KACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,eAAiBC,MAAA,8DAAAC,aAAA,wqBAAAC,cAAA,EAAAC,QAAyxBC,KAAA,qGAAAC,UAAA,kBAAAC,QAAoJC,KAAA,yCAAAC,WAAA,4MAAyQD,KAAA,gEAAAC,WAAA,0QAA8VD,KAAA,gEAAAC,WAAA,0QAA8VD,KAAA,6DAAAC,WAAA,oQAAqVD,KAAA,0CAAAC,WAAA,qZAAmdD,KAAA,0CAAAC,WAAA,qZAAmdD,KAAA,mFAAAC,WAAA,mVAA0bD,KAAA,0DAAAC,WAAA,yZAAseC,YAAAC,OAAwBC,UAAA,KAAAC,SAA4BC,IAAA,UAAAC,IAAA,KAAAC,KAAA,QAAAC,SAAA,oRAAuUC,KAAA,GAAAC,KAAA,+/BAAihCC,SAAA,QAAmBC,aAAgBC,eAAiBC,UAAA,GAAAC,SAAA,KAAAd,YAAAe,kBAAA,wFAAAC,GAAA,4BAAyLrB,KAAA","file":"path---coding-interview-prep-data-structures-find-the-minimum-and-maximum-height-of-a-binary-search-tree-0d80ba67681d58e72d6b.js","sourcesContent":["webpackJsonp([95488792226242],{\n\n/***/ 2835:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"challengeNode\":{\"title\":\"Find the Minimum and Maximum Height of a Binary Search Tree\",\"description\":[\"在上一个挑战中我们提到了树结构不平衡的情况。为了理解平衡的概念，我们来了解一下树的另一个概念：高度（height）。树的高度表示从根节点到叶子结点的距离。如果一个树有很多分支，那么不同的路径（即从根节点到一个子节点的线路）就会有不同的高度。然而，对于一个给定的树，高度一定会有确切的最大值和最小值。如果树是平衡的，最大值和最小值的差值不会超过 1。这意味着在平衡树中，所有的叶子结点都处在同一层级，或者至多只相差一个层级。\",\"树的平衡性这个概念十分重要，因为它直接决定树操作的效率高低。例如在上一节挑战当中，我们提到了不平衡树的最坏情况，此时时间复杂度也会达到最高。自平衡树通常用在拥有动态数据集的树结构当中。常见的平衡树有 AVL 树，红黑树以及 B-trees。当因为插入或删除数据导致这些树结构不平衡时，它们都有内部逻辑处理，让树变得平衡。\",\"注意：深度（depth）是一个与高度类似的概念，它指的是某一个节点（注意，不一定是叶子节点）和根节点之间的距离。\",\"挑战说明：请给二叉树编写两个方法：<code>findMinHeight</code>和<code>findMaxHeight</code>。这两个方法应该分别返回二叉树的最小高度和最大高度。如果树为空，则两个方法都应返回 -1。最后，为树结构添加<code>isBalanced</code>方法，该方法根据树结构是否平衡返回<code>true</code>或<code>false</code>。你可以使用前两个方法来编写<code>isBalanced</code>方法。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/coding-interview-prep/data-structures/find-the-minimum-and-maximum-height-of-a-binary-search-tree\",\"blockName\":\"Data Structures\",\"tests\":[{\"text\":\"<code>BinarySearchTree</code>数据结构应该存在。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');\"},{\"text\":\"<code>BinarySearchTree</code>应该有<code>findMinHeight</code>方法。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.findMinHeight == 'function')})(), '<code>BinarySearchTree</code>应该有<code>findMinHeight</code>方法。');\"},{\"text\":\"<code>BinarySearchTree</code>应该有<code>findMaxHeight</code>方法。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.findMaxHeight == 'function')})(), '<code>BinarySearchTree</code>应该有<code>findMaxHeight</code>方法。');\"},{\"text\":\"<code>BinarySearchTree</code>应该有<code>isBalanced</code>方法。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.isBalanced == 'function')})(), '<code>BinarySearchTree</code>应该有<code>isBalanced</code>方法。');\"},{\"text\":\"<code>findMinHeight</code>方法应返回树的最小高度值。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMinHeight !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return (test.findMinHeight() == 1); })(), '<code>findMinHeight</code>方法应返回树的最小高度值。');\"},{\"text\":\"<code>findMaxHeight</code>方法应返回树的最大高度值。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMaxHeight !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return (test.findMaxHeight() == 5); })(), '<code>findMaxHeight</code>方法应返回树的最大高度值。');\"},{\"text\":\"当树为空时，<code>findMaxHeight</code>和<code>findMinHeight</code>方法应返回<code>-1</code>。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMaxHeight !== 'function') { return false; }; return (test.findMaxHeight() == -1); })(), '当树为空时，<code>findMaxHeight</code>和<code>findMinHeight</code>方法应返回<code>-1</code>。');\"},{\"text\":\"当树是平衡状态时，<code>isBalanced</code>方法应返回<code>true</code>。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.isBalanced !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return test.isBalanced(); })(), '当树是平衡状态时，<code>isBalanced</code>方法应返回<code>true</code>。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));\\nfunction Node(value) {\\n    this.value = value;\\n    this.left = null;\\n    this.right = null;\\n}\\nfunction BinarySearchTree() {\\n    this.root = null;\\n    // 请把你的代码写在这条注释以下\\n    // 请把你的代码写在这条注释以上\\n}\",\"head\":\"\",\"tail\":\"BinarySearchTree.prototype = {\\n    add: function(value) {\\n        var node = this.root;\\n        if (node == null) {\\n          this.root = new Node(value);\\n          return;\\n        } else {\\n            function searchTree(node) {\\n                if (value < node.value) {\\n                    if (node.left == null) {\\n                        node.left = new Node(value);\\n                        return;\\n                    } else if (node.left != null) {\\n                        return searchTree(node.left)\\n                    };\\n                } else if (value > node.value) {\\n                    if (node.right == null) {\\n                        node.right = new Node(value);\\n                        return;\\n                    } else if (node.right != null) {\\n                        return searchTree(node.right);\\n                    };\\n                } else {\\n                    return null;\\n                };\\n            };\\n            return searchTree(node);\\n        };\\n    }\\n};\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/coding-interview-prep/data-structures/use-depth-first-search-in-a-binary-search-tree\",\"id\":\"587d8257367417b2b2512c7d\"},\"slug\":\"/coding-interview-prep/data-structures/find-the-minimum-and-maximum-height-of-a-binary-search-tree\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---coding-interview-prep-data-structures-find-the-minimum-and-maximum-height-of-a-binary-search-tree-0d80ba67681d58e72d6b.js","module.exports = {\"data\":{\"challengeNode\":{\"title\":\"Find the Minimum and Maximum Height of a Binary Search Tree\",\"description\":[\"在上一个挑战中我们提到了树结构不平衡的情况。为了理解平衡的概念，我们来了解一下树的另一个概念：高度（height）。树的高度表示从根节点到叶子结点的距离。如果一个树有很多分支，那么不同的路径（即从根节点到一个子节点的线路）就会有不同的高度。然而，对于一个给定的树，高度一定会有确切的最大值和最小值。如果树是平衡的，最大值和最小值的差值不会超过 1。这意味着在平衡树中，所有的叶子结点都处在同一层级，或者至多只相差一个层级。\",\"树的平衡性这个概念十分重要，因为它直接决定树操作的效率高低。例如在上一节挑战当中，我们提到了不平衡树的最坏情况，此时时间复杂度也会达到最高。自平衡树通常用在拥有动态数据集的树结构当中。常见的平衡树有 AVL 树，红黑树以及 B-trees。当因为插入或删除数据导致这些树结构不平衡时，它们都有内部逻辑处理，让树变得平衡。\",\"注意：深度（depth）是一个与高度类似的概念，它指的是某一个节点（注意，不一定是叶子节点）和根节点之间的距离。\",\"挑战说明：请给二叉树编写两个方法：<code>findMinHeight</code>和<code>findMaxHeight</code>。这两个方法应该分别返回二叉树的最小高度和最大高度。如果树为空，则两个方法都应返回 -1。最后，为树结构添加<code>isBalanced</code>方法，该方法根据树结构是否平衡返回<code>true</code>或<code>false</code>。你可以使用前两个方法来编写<code>isBalanced</code>方法。\"],\"challengeType\":1,\"fields\":{\"slug\":\"/coding-interview-prep/data-structures/find-the-minimum-and-maximum-height-of-a-binary-search-tree\",\"blockName\":\"Data Structures\",\"tests\":[{\"text\":\"<code>BinarySearchTree</code>数据结构应该存在。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');\"},{\"text\":\"<code>BinarySearchTree</code>应该有<code>findMinHeight</code>方法。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.findMinHeight == 'function')})(), '<code>BinarySearchTree</code>应该有<code>findMinHeight</code>方法。');\"},{\"text\":\"<code>BinarySearchTree</code>应该有<code>findMaxHeight</code>方法。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.findMaxHeight == 'function')})(), '<code>BinarySearchTree</code>应该有<code>findMaxHeight</code>方法。');\"},{\"text\":\"<code>BinarySearchTree</code>应该有<code>isBalanced</code>方法。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.isBalanced == 'function')})(), '<code>BinarySearchTree</code>应该有<code>isBalanced</code>方法。');\"},{\"text\":\"<code>findMinHeight</code>方法应返回树的最小高度值。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMinHeight !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return (test.findMinHeight() == 1); })(), '<code>findMinHeight</code>方法应返回树的最小高度值。');\"},{\"text\":\"<code>findMaxHeight</code>方法应返回树的最大高度值。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMaxHeight !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return (test.findMaxHeight() == 5); })(), '<code>findMaxHeight</code>方法应返回树的最大高度值。');\"},{\"text\":\"当树为空时，<code>findMaxHeight</code>和<code>findMinHeight</code>方法应返回<code>-1</code>。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMaxHeight !== 'function') { return false; }; return (test.findMaxHeight() == -1); })(), '当树为空时，<code>findMaxHeight</code>和<code>findMinHeight</code>方法应返回<code>-1</code>。');\"},{\"text\":\"当树是平衡状态时，<code>isBalanced</code>方法应返回<code>true</code>。\",\"testString\":\"assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.isBalanced !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return test.isBalanced(); })(), '当树是平衡状态时，<code>isBalanced</code>方法应返回<code>true</code>。');\"}]},\"required\":[],\"files\":{\"indexhtml\":null,\"indexjs\":{\"key\":\"indexjs\",\"ext\":\"js\",\"name\":\"index\",\"contents\":\"var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));\\nfunction Node(value) {\\n    this.value = value;\\n    this.left = null;\\n    this.right = null;\\n}\\nfunction BinarySearchTree() {\\n    this.root = null;\\n    // 请把你的代码写在这条注释以下\\n    // 请把你的代码写在这条注释以上\\n}\",\"head\":\"\",\"tail\":\"BinarySearchTree.prototype = {\\n    add: function(value) {\\n        var node = this.root;\\n        if (node == null) {\\n          this.root = new Node(value);\\n          return;\\n        } else {\\n            function searchTree(node) {\\n                if (value < node.value) {\\n                    if (node.left == null) {\\n                        node.left = new Node(value);\\n                        return;\\n                    } else if (node.left != null) {\\n                        return searchTree(node.left)\\n                    };\\n                } else if (value > node.value) {\\n                    if (node.right == null) {\\n                        node.right = new Node(value);\\n                        return;\\n                    } else if (node.right != null) {\\n                        return searchTree(node.right);\\n                    };\\n                } else {\\n                    return null;\\n                };\\n            };\\n            return searchTree(node);\\n        };\\n    }\\n};\"},\"indexjsx\":null}}},\"pathContext\":{\"challengeMeta\":{\"introPath\":\"\",\"template\":null,\"required\":[],\"nextChallengePath\":\"/coding-interview-prep/data-structures/use-depth-first-search-in-a-binary-search-tree\",\"id\":\"587d8257367417b2b2512c7d\"},\"slug\":\"/coding-interview-prep/data-structures/find-the-minimum-and-maximum-height-of-a-binary-search-tree\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/coding-interview-prep-data-structures-find-the-minimum-and-maximum-height-of-a-binary-search-tree.json\n// module id = 2835\n// module chunks = 95488792226242"],"sourceRoot":""}
{
  "name": "Redux",
  "order": 6,
  "time": "5 hours",
  "helpRoom": "Help",
  "required": [
    {
      "src": "https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js"
    },
    {
      "src": "https://cdnjs.cloudflare.com/ajax/libs/redux-thunk/2.2.0/redux-thunk.min.js"
    }
  ],
  "challenges": [
    {
      "id": "5a24c314108439a4d403614b",
      "title": "Create a Redux Store",
      "releasedOn": "December 25, 2017",
      "description": [
        "Redux 是一个状态管理框架，可以与包括 React 在内的许多不同的 Web 技术一起使用。",
        "在 Redux 中，有一个状态对象负责应用程序的整个状态， 这意味着如果你有一个包含十个组件且每个组件都有自己的本地状态的 React 项目，那么这个项目的整个状态将通过 Redux <code>store</code>被定义为单个状态对象， 这是学习 Redux 时要理解的第一个重要原则：Redux store 是应用程序状态的唯一真实来源。",
        "这也意味着，如果你的应用程序想要更新状态，只能通过 Redux store 执行，单向数据流可以更轻松地对应用程序中的状态进行监测管理。",
        "<hr>",
        "Redux <code>store</code>是一个保存和管理应用程序状态的<code>state</code>，你可以使用 Redux 对象中的<code>createStore()</code>来创建一个 redux <code>store</code>，此方法将<code>reducer</code>函数作为必需参数，<code>reducer</code>函数将在后面的挑战中介绍,该函数已在代码编辑器中为你定义，它只需将<code>state</code>作为参数并返回一个<code>state</code>即可。",
        "声明一个<code>store</code>变量并把它分配给<code>createStore()</code>方法，然后把<code>reducer</code>作为一个参数传入即可。",
        "注意: 编辑器中的代码使用ES6默认参数语法将 state 的值初始化为<code>5</code>， 如果你不熟悉默认参数，你可以参考<a target=\"_blank\" href=\"http://beta.freecodecamp.com/en/challenges/es6/set-default-parameters-for-your-functions\">ES6全部课程</a>，它里面涵盖了这个内容。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const reducer = (state = 5) => {",
            "  return state;",
            "}",
            "",
            "//Redux 方法可以从 Redux 对象获得",
            "//例如: Redux.createStore()",
            "//在这里定义一个 store",
            "",
            ""
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "redux store 应当存在",
          "testString": "assert(typeof store.getState === 'function', 'redux store 应当存在');"
        },
        {
          "text": "redux store 的 state 的值为 5",
          "testString": "assert(store.getState()=== 5, 'redux store 的 state 的值为 5');"
        }
      ],
      "solutions": [
        "const reducer = (state = 5) => {\n  return state;\n}\n\n//Redux 方法可以从 Redux 对象获得\n// 例如: Redux.createStore()\n// 在这里定义一个 store:\n\nconst store = Redux.createStore(reducer);"
      ],
      "challengeType": 6,
      "isRequired": false,
      "redux": true
    },
    {
      "id": "5a24c314108439a4d403614c",
      "title": "Get State from the Redux Store",
      "releasedOn": "December 25, 2017",
      "description": [
        "Redux store 对象提供了几种允许你与之交互的方法，你可以使用<code>getState()</code>方法检索 Redux store 对象中保存的当前的<code>state</code>。",
        "在代码编辑器中可以将上一个挑战中的代码更简洁地重写，在<code>store</code>中使用<code>store.getState()</code>检索<code>state</code>，并将其分配给新变量<code>currentState</code>。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const store = Redux.createStore(",
            "  (state = 5) => state",
            ");",
            "",
            "//更改此行下方的代码",
            ""
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "redux store 的 state 应该有一个初始值 5。",
          "testString": "assert(store.getState()===5, 'redux store 的 state 应该有一个初始值 5。');"
        },
        {
          "text": "应该存在一个变量<code>currentState</code>，并为其分配 Redux store 的当前状态。",
          "testString": "getUserInput => assert(currentState === 5 && getUserInput('index').includes('store.getState()'), '应该存在一个变量<code>currentState</code>，并为其分配 Redux store 的当前状态。');"
        }
      ],
      "solutions": [
        "const store = Redux.createStore(\n  (state = 5) => state\n);\n\n// 更改此行下方的代码\nconst currentState = store.getState();"
      ],
      "challengeType": 6,
      "isRequired": false,
      "redux": true
    },
    {
      "id": "5a24c314108439a4d403614d",
      "title": "Define a Redux Action",
      "releasedOn": "December 25, 2017",
      "description": [
        "由于 Redux 是一个状态管理框架，因此更新状态是其核心任务之一。在 Redux 中，所有状态更新都由 dispatch action 触发，action 只是一个 JavaScript 对象，其中包含有关已发生的 action 事件的信息， Redux store 接收这些 action 对象，然后更新相应的状态。有时，Redux action 也会携带一些数据。例如，在用户登录后携带用户名，虽然数据是可选的，但 action 必须带有<code>type</code>属性，该属性指定发生 action 的类型。",
        "我们可以将 Redux action 视为信使，将有关应用程序中发生的事件信息提供给 Redux store，然后 store 根据发生的 action 进行状态的更新。",
        "<hr>",
        "编写 Redux action 就像声明具有 type 属性的对象一样简单，声明一个对象<code>action</code>并为它设置一个属性<code>type</code>，并将他的值设置成字符串<code>'LOGIN'</code>。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "//在此处定义 action",
            ""
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "应该有一个 action 对象",
          "testString": "assert((function() { return typeof action === 'object' })(), '应该有一个 action 对象');"
        },
        {
          "text": "该 action 的值应该为<code>LOGIN</code>。",
          "testString": "assert((function() { return action.type === 'LOGIN' })(), '该 action 的值应该为<code>LOGIN</code>。');"
        }
      ],
      "solutions": [
        "const action = {\n  type: 'LOGIN'\n}"
      ],
      "challengeType": 6,
      "isRequired": false,
      "redux": true
    },
    {
      "id": "5a24c314108439a4d403614e",
      "title": "Define an Action Creator",
      "releasedOn": "December 25, 2017",
      "description": [
        "创建 action 后要将 action 发送到 Redux store，以便它可以更新其状态。在 Redux 中，你可以定义动作创建器来完成此任务，action creator 只是一个返回动作的 JavaScript 函数，换句话说，action creator 创建表示动作事件的对象。",
        "<hr>",
        "定义名为<code>actionCreator()</code>的函数，该函数在调用时返回<code>action</code>对象。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const action = {",
            "  type: 'LOGIN'",
            "}",
            "//在此处定义 action creator",
            ""
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "函数<code>actionCreator</code>应该存在。",
          "testString": "assert(typeof actionCreator === 'function', ' 函数<code>actionCreator</code>应该存在。');"
        },
        {
          "text": "运行<code>actionCreator</code>函数应返回 action 对象。",
          "testString": "assert(typeof action === 'object', ' 运行<code>actionCreator</code>函数应返回 action 对象。');"
        },
        {
          "text": "返回的 action 应具有值为<code>LOGIN</code>的键值类型。",
          "testString": "assert(action.type === 'LOGIN', '返回的 action 应具有值为<code>LOGIN</code>的键值类型。');"
        }
      ],
      "solutions": [
        "const action = {\n  type: 'LOGIN'\n}\n// 在此处定义 action creator:\nconst actionCreator = () => {\n  return action;\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "redux": true
    },
    {
      "id": "5a24c314108439a4d403614f",
      "title": "Dispatch an Action Event",
      "releasedOn": "December 25, 2017",
      "description": [
        "<code>dispatch</code>方法用于将 action 分派给 Redux store，调用<code>store.dispatch()</code>将从 action creator 返回的值发送回 store。",
        "action creator 返回一个具有 type 属性的对象，该属性指定已发生的 action，然后，该方法将 action 对象 dispatch 到 Redux store，根据之前的挑战示例，以下内容是等效的，并且都 dispatch 类型为<code>LOGIN</code>的 action：",
        "<blockquote>store.dispatch(actionCreator());<br>store.dispatch({ type: 'LOGIN' });</blockquote>",
        "<hr>",
        "代码编辑器中的 Redux store 具有初始化状态对象{login:'false'}，还有一个名为<code>loginAction()</code>的 action creator，它返回类型为<code>LOGIN</code>的 action，然后通过调用<code>dispatch</code>方法将<code>LOGIN</code>的 action dispatch 给 Redux store，并传递<code>loginAction()</code>创建的 action。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const store = Redux.createStore(",
            "  (state = {login: false}) => state",
            ");",
            "",
            "const loginAction = () => {",
            "  return {",
            "    type: 'LOGIN'",
            "  }",
            "};",
            "",
            "//在这里 dispatch action",
            ""
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "调用函数<code>loginAction</code>应该返回一个对象{type:'LOGIN'}。",
          "testString": "assert(loginAction().type === 'LOGIN', '调用函数<code>loginAction</code>应该返回一个对象{type:\\'LOGIN\\'}。');"
        },
        {
          "text": "store 应该初始化一个对象{login:false}。",
          "testString": "assert(store.getState().login === false, 'store 应该初始化一个对象{login:false}。');"
        },
        {
          "text": "<code>store.dispatch()</code>方法应该被用于 dispatch 一个类型为<code>LOGIN</code>的 action。",
          "testString": "getUserInput => assert((function() {  let noWhiteSpace = getUserInput('index').replace(/\\s/g,''); return noWhiteSpace.includes('store.dispatch(loginAction())') || noWhiteSpace.includes('store.dispatch({type: \\'LOGIN\\'})') === true })(), '<code>store.dispatch()</code>方法应该被用于 dispatch 一个类型为<code>LOGIN</code>的 action。');"
        }
      ],
      "solutions": [
        "const store = Redux.createStore(\n  (state = {login: false}) => state\n);\n\nconst loginAction = () => {\n  return {\n    type: 'LOGIN'\n  }\n};\n\n// Dispatch the action here:\nstore.dispatch(loginAction());"
      ],
      "challengeType": 6,
      "isRequired": false,
      "redux": true
    },
    {
      "id": "5a24c314108439a4d4036150",
      "title": "Handle an Action in the Store",
      "releasedOn": "December 25, 2017",
      "description": [
        "在一个 action 被创建并 dispatch 之后，Redux store需要知道如何响应该操作。这是<code>reducer</code>函数的工作。Redux 中的 Reducers 负责响应 action 然后进行状态的修改。<code>reducer</code>将<code>state</code>和<code>action</code>作为参数，并且它总是返回一个新的<code>state</code>。我们要知道这是 reducer 的<strong>唯一</strong>的作用。它没有任何其他的作用; 它永远不会调用 API 接口，它永远不会有任何潜在的副作用。reducer 只是一个接受状态和动作，然后返回新状态的纯函数。",
        "Redux 的另一个关键原则是<code>state</code>是只读的。换句话说，<code>reducer</code>函数必须<strong>始终</strong>返回一个新的<code>state</code>，并且永远不会直接修改状态。 Redux 不强制改变状态，但是，你需要在你的reducer函数的代码中强制执行它，你将在以后的挑战中练习这一点。",
        "<hr>",
        "代码编辑器中具有前面的示例以及一个<code>reducer</code>函数。你需要完善<code>reducer</code>函数的内容，使得它如果收到类型为<code>'LOGIN'</code>的action，它将返回一个将<code>login</code>设置为<code>true</code>的 state 对象。 否则，它就返回当前的<code>state</code>。请注意，当前<code>state</code>和dispatch的<code>action</code>将被传递给reducer，因此你可以使用<code>action.type</code>直接获取action的类型。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const defaultState = {",
            "  login: false",
            "};",
            "",
            "const reducer = (state = defaultState, action) => {",
            "  //修改此行下方的代码",
            "",
            "  //修改此行上方的代码",
            "};",
            "",
            "const store = Redux.createStore(reducer);",
            "",
            "const loginAction = () => {",
            "  return {",
            "    type: 'LOGIN'",
            "  }",
            "};"
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "调用<code>loginAction</code>函数应该返回一个对象{type:'LOGIN'}。",
          "testString": "assert(loginAction().type === 'LOGIN', '调用<code>loginAction</code>函数应该返回一个对象{type:\\'LOGIN\\'}。');"
        },
        {
          "text": "store 应该初始化一个对象{login:false}。",
          "testString": "assert(store.getState().login === false, 'store 应该初始化一个对象{login:false}。');"
        },
        {
          "text": "dispatch <code>loginAction</code>后应将 store 中 state 的<code>login</code>值更新为<code>true</code>。",
          "testString": "assert((function() {  const initialState = store.getState(); store.dispatch(loginAction()); const afterState = store.getState(); return initialState.login === false && afterState.login === true })(), 'dispatch <code>loginAction</code>后应将 store 中 state 的<code>login</code>值更新为<code>true</code>。');"
        },
        {
          "text": "如果 action 的类型不是<code>LOGIN</code>，那么 store 应返回当前的 state。",
          "testString": "assert((function() { store.dispatch({type: '__TEST__ACTION__'}); let afterTest = store.getState(); return typeof afterTest === 'object' && afterTest.hasOwnProperty('login') })(), '如果 action 的类型不是<code>LOGIN</code>，那么 store 应返回当前的 state。');"
        }
      ],
      "solutions": [
        "const defaultState = {\n  login: false\n};\n\nconst reducer = (state = defaultState, action) => {\n\n  if (action.type === 'LOGIN') {\n    return {login: true}\n  }\n\n  else {\n    return state\n  }\n\n};\n\nconst store = Redux.createStore(reducer);\n\nconst loginAction = () => {\n  return {\n    type: 'LOGIN'\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "redux": true
    },
    {
      "id": "5a24c314108439a4d4036151",
      "title": "Use a Switch Statement to Handle Multiple Actions",
      "releasedOn": "December 25, 2017",
      "description": [
        "你可以告诉 Redux store 如何处理多种 action 类型。比如你正在 Redux store 中进行用户身份验证。如果你希望用户在登录和注销时具有状态的响应。你可以使用具有<code>authenticated</code>属性的单个的 state 对象。你还需要使用 action creators 创建与用户登录和用户注销相对应的 action，以及 action 对象本身。",
        "<hr>",
        "代码编辑器为你创建了 store，actions 和 action creators。通过编写<code>reducer</code>函数来处理多个身份验证操作。可以在<code>reducer</code>通过使用 JavaScript 中的<code>switch</code>响应不同的 action 事件。这是编写 Redux reducer 时的标准模式，switch 语句选择<code>action.type</code>中的一个值并返回相应的身份验证状态。",
        "<strong>注意：</strong>&nbsp;此时，不要担心 state 的不变性，因为在这个示例中它很小而且很简单。所以对于每个操作你都可以返回一个新对象;例如，<code>{authenticated:true}</code>。另外，不要忘记在 switch 语句中写一个<code>default</code> case，返回当前的<code>state</code>。这是很重要的因为一旦你的程序有多个 reducer，当一个 action 被 dispatch 时它们都会运行，即使 action 与该 reducer 无关。在这种情况下，你要确保返回当前的<code>state</code>"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const defaultState = {",
            "  authenticated: false",
            "};",
            "",
            "const authReducer = (state = defaultState, action) => {",
            "//修改此行下方的代码",
            "",
            "//修改此行上方的代码",
            "};",
            "",
            "const store = Redux.createStore(authReducer);",
            "",
            "const loginUser = () => {",
            "  return {",
            "    type: 'LOGIN'",
            "  }",
            "};",
            "",
            "const logoutUser = () => {",
            "  return {",
            "    type: 'LOGOUT'",
            "  }",
            "};"
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "调用<code>loginUser</code>函数应该返回一个{type:'LOGIN'}对象。",
          "testString": "assert(loginUser().type === 'LOGIN', '调用<code>loginUser</code>函数应该返回一个{type:\\'LOGIN\\'}对象。');"
        },
        {
          "text": "调用<code>logoutUser</code>函数应该返回一个{type:'LOGOUT'}对象。",
          "testString": "assert(logoutUser().type === 'LOGOUT', '调用<code>logoutUser</code>函数应该返回一个{type:\\'LOGOUT\\'}对象。');"
        },
        {
          "text": "store 应该设置一个初始化对象{authenticated:false}。",
          "testString": "assert(store.getState().authenticated === false, 'store 应该设置一个初始化对象{authenticated:false}。');"
        },
        {
          "text": "dispatch <code>loginUser</code>应该将 store 中的 state 的<code>authenticated</code>值更新为<code>true</code>。",
          "testString": "assert((function() {  const initialState = store.getState(); store.dispatch(loginUser()); const afterLogin = store.getState(); return initialState.authenticated === false && afterLogin.authenticated === true })(), 'dispatch <code>loginUser</code>应该将 store 中的 state 的<code>authenticated</code>值更新为<code>true</code>。');"
        },
        {
          "text": "dispatch <code>logoutUser</code>应该将 store 中的 state 的<code>authenticated</code>值更新为<code>false</code>。",
          "testString": "assert((function() {  store.dispatch(loginUser()); const loggedIn = store.getState(); store.dispatch(logoutUser()); const afterLogout = store.getState(); return loggedIn.authenticated === true && afterLogout.authenticated === false  })(), 'dispatch <code>logoutUser</code>应该将 store 中的 state 的<code>authenticated</code>值更新为<code>false</code>。');"
        },
        {
          "text": "<code>authReducer</code>函数应该使用<code>switch</code>语句处理多个 action 类型。",
          "testString": "getUserInput => assert( getUserInput('index').toString().includes('switch') && getUserInput('index').toString().includes('case') && getUserInput('index').toString().includes('default'), '<code>authReducer</code>函数应该使用<code>switch</code>语句处理多个 action 类型。');"
        }
      ],
      "solutions": [
        "const defaultState = {\n  authenticated: false\n};\n\nconst authReducer = (state = defaultState, action) => {\n\n  switch (action.type) {\n\n    case 'LOGIN':\n      return {\n        authenticated: true\n      }\n\n    case 'LOGOUT':\n      return {\n        authenticated: false\n      }\n\n    default:\n      return state;\n\n  }\n\n};\n\nconst store = Redux.createStore(authReducer);\n\nconst loginUser = () => {\n  return {\n    type: 'LOGIN'\n  }\n};\n\nconst logoutUser = () => {\n  return {\n    type: 'LOGOUT'\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "redux": true
    },
    {
      "id": "5a24c314108439a4d4036152",
      "title": "Use const for Action Types",
      "releasedOn": "December 25, 2017",
      "description": [
        "在使用 Redux 时的一个常见做法是将操作类型指定为只读，然后在任何使用它们的地方引用这些常量。你可以通过将 action types 使用<code>const</代码>声明重构你正在使用的代码。",
        "<hr>",
        "将<code>LOGIN</code>和<code>LOGOUT</code>声明为<code>const</code>类型的值，并为它们分别分配字符串<code>'LOGIN'</code>和<code>'LOGOUT'</code>。然后，编辑<code>authReducer()</code>和 action creators 来引用这些常量而不是字符串值。",
        "<strong>注意：</strong>＆nbsp;通常以全部大写形式写出常量，这也是 Redux 的标准做法。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "//修改此行下方的代码",
            "",
            "//修改此行上方的代码",
            "",
            "const defaultState = {",
            "  authenticated: false",
            "};",
            "",
            "const authReducer = (state = defaultState, action) => {",
            "",
            "  switch (action.type) {",
            "",
            "    case 'LOGIN':",
            "      return {",
            "        authenticated: true",
            "      }",
            "",
            "    case 'LOGOUT':",
            "      return {",
            "        authenticated: false",
            "      }",
            "",
            "    default:",
            "      return state;",
            "",
            "  }",
            "",
            "};",
            "",
            "const store = Redux.createStore(authReducer);",
            "",
            "const loginUser = () => {",
            "  return {",
            "    type: 'LOGIN'",
            "  }",
            "};",
            "",
            "const logoutUser = () => {",
            "  return {",
            "    type: 'LOGOUT'",
            "  }",
            "};"
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "调用<code>loginUser</code>函数应该返回一个{type:'LOGIN'}对象。",
          "testString": "assert(loginUser().type === 'LOGIN', '调用<code>loginUser</code>函数应该返回一个{type:\\'LOGIN\\'}对象。');"
        },
        {
          "text": "调用<code>logoutUser</code>函数应该返回一个{type:'LOGOUT'}对象。",
          "testString": "assert(logoutUser().type === 'LOGOUT', '调用<code>logoutUser</code>函数应该返回一个{type:\\'LOGOUT\\'}对象。');"
        },
        {
          "text": "store 应该初始化一个对象{login：false}。",
          "testString": "assert(store.getState().authenticated === false, 'store 应该初始化一个对象{login：false}。');"
        },
        {
          "text": "dispatch <code>loginUser</code>以后应将 store 中的 state 的<code>login</code>值更新为<code>true</code>。",
          "testString": "assert((function() {  const initialState = store.getState(); store.dispatch(loginUser()); const afterLogin = store.getState(); return initialState.authenticated === false && afterLogin.authenticated === true })(), 'dispatch <code>loginUser</code>以后应将 store 中的 state 的<code>login</code>值更新为<code>true</code>。');"
        },
        {
          "text": "dispatch <code>logoutUser</code>应将 store 中的 state 的<code>login</code>值更新为<code>false</code>。",
          "testString": "assert((function() {  store.dispatch(loginUser()); const loggedIn = store.getState(); store.dispatch(logoutUser()); const afterLogout = store.getState(); return loggedIn.authenticated === true && afterLogout.authenticated === false })(), 'dispatch <code>logoutUser</code>应将 store 中的 state 的<code>login</code>值更新为<code>false</code>。');"
        },
        {
          "text": "<code>authReducer</code>函数应该使用 switch 语句处理多个 action 类型。",
          "testString": "getUserInput => assert((function() { return typeof authReducer === 'function' && getUserInput('index').toString().includes('switch') && getUserInput('index').toString().includes('case') && getUserInput('index').toString().includes('default') })(), '<code>authReducer</code>函数应该使用 switch 语句处理多个 action 类型。');"
        },
        {
          "text": "应该使用<code>const LOGIN='LOGIN'</code>和<code>const LOGOUT='LOGOUT'</code>的方式声明<code>LOGIN</code>和<code>LOGOUT</code>。",
          "testString": "getUserInput => assert((function() {  const noWhiteSpace = getUserInput('index').toString().replace(/\\s/g,''); return (noWhiteSpace.includes('constLOGIN=\\'LOGIN\\'') || noWhiteSpace.includes('constLOGIN=\"LOGIN\"')) && (noWhiteSpace.includes('constLOGOUT=\\'LOGOUT\\'') || noWhiteSpace.includes('constLOGOUT=\"LOGOUT\"')) })(), '应该使用<code>const LOGIN=\\'LOGIN\\'</code>和<code>const LOGOUT=\\'LOGOUT\\'</code>的方式声明<code>LOGIN</code>和<code>LOGOUT</code>。');"
        },
        {
          "text": "action creator 和 reducer 中应该引用<code>LOGIN</code>和<code>LOGOUT</code>常量。",
          "testString": "getUserInput => assert((function() { const noWhiteSpace = getUserInput('index').toString().replace(/\\s/g,''); return noWhiteSpace.includes('caseLOGIN:') && noWhiteSpace.includes('caseLOGOUT:') && noWhiteSpace.includes('type:LOGIN') && noWhiteSpace.includes('type:LOGOUT') })(), 'action creator 和 reducer 中应该引用<code>LOGIN</code>和<code>LOGOUT</code>常量。');"
        }
      ],
      "solutions": [
        "const LOGIN = 'LOGIN';\nconst LOGOUT = 'LOGOUT';\n\nconst defaultState = {\n  authenticated: false\n};\n\nconst authReducer = (state = defaultState, action) => {\n\n  switch (action.type) {\n\n    case LOGIN:\n      return {\n        authenticated: true\n      }\n\n    case LOGOUT:\n      return {\n        authenticated: false\n      }\n\n    default:\n      return state;\n\n  }\n\n};\n\nconst store = Redux.createStore(authReducer);\n\nconst loginUser = () => {\n  return {\n    type: LOGIN\n  }\n};\n\nconst logoutUser = () => {\n  return {\n    type: LOGOUT\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "redux": true
    },
    {
      "id": "5a24c314108439a4d4036153",
      "title": "Register a Store Listener",
      "releasedOn": "December 25, 2017",
      "description": [
        "在 Redux <code>store</code>对象上访问数据的另一种方法是<code>store.subscribe()</code>。这允许你将监听器函数订阅到 store，只要一个 action 被 dispatch 就会调用它们。这个方法的一个简单用途是为你的 store 订阅一个函数，它只是在每次收到一个 action 并且更新 store 时记录一条消息。",
        "<hr>",
        "编写一个回调函数，每次 store 收到一个 action 时，它会递增全局变量<code>count</code>，并将此函数传递给<code>store.subscribe()</code>方法。你将会看到<code>store.dispatch()</code>连续三次被调用，每次都直接传入一个 action 对象。观察 dispatch action 之间的控制台输出，看看是否发生了更新。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "head": [
            "count = 0;"
          ],
          "contents": [
            "const ADD = 'ADD';",
            "",
            "const reducer = (state = 0, action) => {",
            "  switch(action.type) {",
            "    case ADD:",
            "      return state + 1;",
            "    default:",
            "      return state;",
            "  }",
            "};",
            "",
            "const store = Redux.createStore(reducer);",
            "",
            "//用于计数的全局变量：",
            "let count = 0;",
            "",
            "//修改此行下方的代码",
            "",
            "//修改此行上方的代码",
            "",
            "store.dispatch({type: ADD});",
            "console.log(count);",
            "store.dispatch({type: ADD});",
            "console.log(count);",
            "store.dispatch({type: ADD});",
            "console.log(count);"
          ],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "在 store 上 dispatch <code>ADD</code> action 应该使计数器增加<code>1</code>。",
          "testString": "assert((function() { const initialState = store.getState(); store.dispatch({ type: 'ADD' }); const newState = store.getState(); return newState === (initialState + 1); })(), '在 store 上 dispatch <code>ADD</code> action 应该使计数器增加<code>1</code>。');"
        },
        {
          "text": "应该有一个监听函数<code>store.subscribe</code>订阅 store。",
          "testString": "getUserInput => assert(getUserInput('index').includes('store.subscribe('), '应该有一个监听函数<code>store.subscribe</code>订阅 store。');"
        },
        {
          "text": "在更新 store 时，<code>store.subscribe</code>应该在回调中使全局变量<code>count</code>增加。",
          "testString": "assert(store.getState() === count, '在更新 store 时，<code>store.subscribe</code>应该在回调中使全局变量<code>count</code>增加。');"
        }
      ],
      "solutions": [
        "const ADD = 'ADD';\n\nconst reducer = (state = 0, action) => {\n  switch(action.type) {\n    case ADD:\n      return state + 1;\n    default:\n      return state;\n  }\n};\n\nconst store = Redux.createStore(reducer);\n let count = 0; \n// change code below this line\n\nstore.subscribe( () =>\n { \n count++; \n } \n);\n\n// change code above this line\n\nstore.dispatch({type: ADD});\nstore.dispatch({type: ADD});\nstore.dispatch({type: ADD});"
      ],
      "challengeType": 6,
      "isRequired": false,
      "redux": true
    },
    {
      "id": "5a24c314108439a4d4036154",
      "title": "Combine Multiple Reducers",
      "releasedOn": "December 25, 2017",
      "description": [
        "当你应用程序的状态开始变得越来越复杂时，将状态划分为多个部分可能是个更好的选择。相反，请记住 Redux 的第一个原则：所有应用程序状态都保存在 store 中的一个简单的 state 对象中。因此，Redux 提供 reducer 组合作为复杂状态模型的解决方案。定义多个 reducer 来处理应用程序状态的不同部分，然后将这些 reducer 组合成一个 root reducer。然后将 root reducer 传递给 Redux <code>createStore()</code>方法。",
        "为了让我们将可以将多个 reducer 组合在一起，Redux 提供了<code>combineReducers()</code>方法。该方法接受一个对象作为参数，在该参数中定义一个将键与特定reducer函数关联的属性。 Redux将使用你给的键值作为关联状态的名称。",
        "通常情况下，当它们在某种程度上是独一无二的，为每个应用程序的 state 创建一个减少器是一个很好的做法。例如，在一个带有用户身份验证的记笔记应用程序中，一个 reducer 可以处理身份验证而另一个处理用户提交的文本和注释。对于这样的应用程序，我们可能会编写<code>combineReducers()</code>方法，如下所示：",
        "<blockquote>const rootReducer = Redux.combineReducers({<br>&nbsp;&nbsp;auth: authenticationReducer,<br>&nbsp;&nbsp;notes: notesReducer<br>});</blockquote>",
        "现在，<code>notes</code>键将包含与我们的注释相关联的所有状态，并由我们的<code>notesReducer</code>处理。这就是如何组合多个 reducer 来管理更复杂的应用程序状态，在此示例中，Redux store 中保存的状态将是一个包含<code>auth</code>和<code>notes</code>属性的简单对象。",
        "<hr>",
        "代码编辑器中提供了<code>counterReducer()</code>和<code>authReducer()</code>函数以及 Redux store。使用<code>Redux.combineReducers()</code>方法编写完成<code>rootReducer()</code>函数。将<code>counterReducer</code>分配给一个叫做<code>count</code>的键，将<code>authReducer</code>分配给一个叫做<code>auth</code>的键。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const INCREMENT = 'INCREMENT';",
            "const DECREMENT = 'DECREMENT';",
            "",
            "const counterReducer = (state = 0, action) => {",
            "  switch(action.type) {",
            "    case INCREMENT:",
            "      return state + 1;",
            "    case DECREMENT:",
            "      return state - 1;",
            "    default:",
            "      return state;",
            "  }",
            "};",
            "",
            "const LOGIN = 'LOGIN';",
            "const LOGOUT = 'LOGOUT';",
            "",
            "const authReducer = (state = {authenticated: false}, action) => {",
            "  switch(action.type) {",
            "    case LOGIN:",
            "      return {",
            "        authenticated: true",
            "      }",
            "    case LOGOUT:",
            "      return {",
            "        authenticated: false",
            "      }",
            "    default:",
            "      return state;",
            "  }",
            "};",
            "",
            "const rootReducer = //在这里定义 root reducer",
            "",
            "const store = Redux.createStore(rootReducer);",
            ""
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "<code>counterReducer</code>应该递增和递减<code>state</code>。",
          "testString": "assert((function() { const initalState = store.getState().count; store.dispatch({type: INCREMENT}); store.dispatch({type: INCREMENT}); const firstState = store.getState().count; store.dispatch({type: DECREMENT}); const secondState = store.getState().count; return firstState === initalState + 2 && secondState === firstState - 1  })(), '<code>counterReducer</code>应该递增和递减<code>state</code>。');"
        },
        {
          "text": "<code>authenticated</code>的<code>state</code>值应该在<code>true</code>和<code>false</code>之间切换。",
          "testString": "assert((function() {  store.dispatch({type: LOGIN}); const loggedIn = store.getState().auth.authenticated; store.dispatch({type: LOGOUT}); const loggedOut = store.getState().auth.authenticated; return loggedIn === true && loggedOut === false  })(), '<code>authenticated</code>的<code>state</code>值应该在<code>true</code>和<code>false</code>之间切换。');"
        },
        {
          "text": "store <code>state</code>应该有两个 key：一个是<code>count</code>，它包含一个数字。另一个<code>auth</code>，它包含一个对象。<code>auth</code>对象应该具有<code>authenticated</code>的属性，该属性的值应该为布尔值。",
          "testString": "assert((function() { const state = store.getState(); return typeof state.auth === 'object' && typeof state.auth.authenticated === 'boolean' && typeof state.count === 'number' })(), 'store <code>state</code>应该有两个 key：一个是<code>count</code>，它包含一个数字。另一个<code>auth</code>，它包含一个对象。<code>auth</code>对象应该具有<code>authenticated</code>的属性，该属性的值应该为布尔值。');"
        },
        {
          "text": "<code>rootReducer</code>应该是一个合并了<code>counterReducer</code>和<code>authReducer</code>的函数。",
          "testString": "getUserInput => assert((function() {  const noWhiteSpace = getUserInput('index').replace(/\\s/g,''); return typeof rootReducer === 'function' && noWhiteSpace.includes('Redux.combineReducers')  })(), '<code>rootReducer</code>应该是一个合并了<code>counterReducer</code>和<code>authReducer</code>的函数。');"
        }
      ],
      "solutions": [
        "const INCREMENT = 'INCREMENT';\nconst DECREMENT = 'DECREMENT';\n\nconst counterReducer = (state = 0, action) => {\n  switch(action.type) {\n    case INCREMENT:\n      return state + 1;\n    case DECREMENT:\n      return state - 1;\n    default:\n      return state;\n  }\n};\n\nconst LOGIN = 'LOGIN';\nconst LOGOUT = 'LOGOUT';\n\nconst authReducer = (state = {authenticated: false}, action) => {\n  switch(action.type) {\n    case LOGIN:\n      return {\n        authenticated: true\n      }\n    case LOGOUT:\n      return {\n        authenticated: false\n      }\n    default:\n      return state;\n  }\n};\n\nconst rootReducer = Redux.combineReducers({\n  count: counterReducer,\n  auth: authReducer\n});\n\nconst store = Redux.createStore(rootReducer);"
      ],
      "challengeType": 6,
      "isRequired": false,
      "redux": true
    },
    {
      "id": "5a24c314108439a4d4036155",
      "title": "Send Action Data to the Store",
      "releasedOn": "December 25, 2017",
      "description": [
        "到目前为止，你已经学会了如何将 action dispatch 给 Redux store，但到目前为止，这些 action 并未包含除 <code>type</code>之外的任何信息。你还可以发送特定数据和 action 一起。事实上，这是非常常见的，因为 action 通常源于一些用户交互，并且往往会携带一些数据，Redux store经常需要知道这些数据。",
        "<hr>",
        "在代码编辑器中定义了一个基础的<code>notesReducer()</code>和<code>addNoteText()</code> action creator。完成<code>addNoteText()</code>函数的主体，这样它就会返回一个<code>action</code>对象。该对象应该包含一个<code>type</code>属性，其值为<code>ADD_NOTE</code>，还有一个<code>text</code>属性通过 action creator 将值设置为<code>note</code>。当你调用 action creator 时，你需要传入可以访问该对象的特定注释信息。",
        "接下来，完成在<code>notesReducer()</code>中编写的<code>switch</code>语句。你需要添加一个处理<code>addNoteText()</code>操作的选项。 只要存在<code>ADD_NOTE</code>类型的 action，就应该触发 case，并且它应该在传入的<code>action</code>上返回<code>tex</code>属性作为新的<code>state</code>",
        "这个 action 将在代码底部发送。一旦完成后，运行代码并观察控制台。这就是将特定于 action 的数据发送到 store 并在更新 store <code>state</code>时使用它所需的全部内容。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const ADD_NOTE = 'ADD_NOTE';",
            "",
            "const notesReducer = (state = 'Initial State', action) => {",
            "  switch(action.type) {",
            "    //修改此行下方的代码",
            "",
            "    //修改此行上方的代码",
            "    default:",
            "      return state;",
            "  }",
            "};",
            "",
            "const addNoteText = (note) => {",
            "  //修改此行下方的代码",
            "",
            "  //修改此行上方的代码",
            "};",
            "",
            "const store = Redux.createStore(notesReducer);",
            "",
            "console.log(store.getState());",
            "store.dispatch(addNoteText('Hello!'));",
            "console.log(store.getState());"
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "action creator <code>addNoteText</code>应该返回一个包含<code>type</code>和<code>text</code>的对象。",
          "testString": "assert((function() { const addNoteFn = addNoteText('__TEST__NOTE'); return addNoteFn.type === ADD_NOTE && addNoteFn.text === '__TEST__NOTE' })(), 'action creator <code>addNoteText</code>应该返回一个包含<code>type</code>和<code>text</code>的对象。');"
        },
        {
          "text": "dispatch 一个 action creator 是<code>addNoteText</code>的action<code>ADD_NOTE</code>，应将<code>state</code>更新为 action creator 传递的字符串。",
          "testString": "assert((function() { const initialState = store.getState(); store.dispatch(addNoteText('__TEST__NOTE')); const newState = store.getState(); return initialState !== newState && newState === '__TEST__NOTE' })(), 'dispatch 一个 action creator 是<code>addNoteText</code>的action<code>ADD_NOTE</code>，应将<code>state</code>更新为 action creator 传递的字符串。');"
        }
      ],
      "solutions": [
        "const ADD_NOTE = 'ADD_NOTE';\n\nconst notesReducer = (state = 'Initial State', action) => {\n  switch(action.type) {\n    // change code below this line\n    case ADD_NOTE:\n      return action.text;\n    // change code above this line\n    default:\n      return state;\n  }\n};\n\nconst addNoteText = (note) => {\n  // change code below this line\n  return {\n    type: ADD_NOTE,\n    text: note\n  }\n  // change code above this line\n};\n\nconst store = Redux.createStore(notesReducer);\n\nconsole.log(store.getState());\nstore.dispatch(addNoteText('Hello Redux!'));\nconsole.log(store.getState());"
      ],
      "challengeType": 6,
      "isRequired": false,
      "redux": true
    },
    {
      "id": "5a24c314108439a4d4036156",
      "title": "Use Middleware to Handle Asynchronous Actions",
      "releasedOn": "December 25, 2017",
      "description": [
        "到目前为止，这些挑战已经避免讨论异步操作，但它们是 Web 开发中不可避免的一部分。在某些时候，你需要在 Redux 应用程序中调用异步端点，那么如何处理这些类型的请求？Redux 中间件专为此目的而设计，称为 Redux Thunk 中间件。这里简要介绍如何在 Redux 中使用它。",
        "如果要使用 Redux Thunk 中间件，请将其作为参数传递给<code>Redux.applyMiddleware()</code>。然后将此函数作为第二个可选参数提供给<code>createStore()</code>函数，看一下编辑器底部的代码，然后，要创建一个异步的 action，你需要在 action creator 中返回一个以<code>dispatch</code>为参数的函数。在这个函数中，你可以 dispatch  action 并执行异步请求。",
        "在此示例中，使用<code>setTimeout()</code>调用模拟异步请求。通常在执行异步行为之前 dispatch action，以便应用程序状态知道正在请求某些数据（例如，这个状态可以显示加载图标）。然后，一旦收到数据，就会发送另一个 action，这个 action 完成的时间将作为数据的一个有效值。",
        "请记住，你正在通过将<code>dispatch</code>作为参数传递给这个特殊的 action creator。你用于 dispatch 你的 action 时只需将 action 直接传递给 dispatch，中间件就可以处理其余的部分。",
        "<hr>",
        "在<code>handleAsync()</code>的 action creator 中编写两个 dispatch 事件。在<code>setTimeout()</code>（模拟 API 调用）之前 dispatch<code>requesData()</code>。然后在收到（模拟）数据后，dispatch<code>receivedData()</code>action，传入这些数据。现在你知道如何处理 Redux 中的异步操作，其他所有操作都继续像以前一样。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const REQUESTING_DATA = 'REQUESTING_DATA'",
            "const RECEIVED_DATA = 'RECEIVED_DATA'",
            "",
            "const requestingData = () => { return {type: REQUESTING_DATA} }",
            "const receivedData = (data) => { return {type: RECEIVED_DATA, users: data.users} }",
            "",
            "const handleAsync = () => {",
            "  return function(dispatch) {",
            "    //在这里 dispatch 请求的 action",
            "",
            "    setTimeout(function() {",
            "      let data = {",
            "        users: ['Jeff', 'William', 'Alice']",
            "      }",
            "      //在这里 dispatch 接收到的数据 action",
            "",
            "    }, 2500);",
            "  }",
            "};",
            "",
            "const defaultState = {",
            "  fetching: false,",
            "  users: []",
            "};",
            "",
            "const asyncDataReducer = (state = defaultState, action) => {",
            "  switch(action.type) {",
            "    case REQUESTING_DATA:",
            "      return {",
            "        fetching: true,",
            "        users: []",
            "      }",
            "    case RECEIVED_DATA:",
            "      return {",
            "        fetching: false,",
            "        users: action.users",
            "      }",
            "    default:",
            "      return state;",
            "  }",
            "};",
            "",
            "const store = Redux.createStore(",
            "  asyncDataReducer,",
            "  Redux.applyMiddleware(ReduxThunk.default)",
            ");"
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "<code>requesData</code> action creator 应返回类型和值都为<code>REQUESTING_DATA</code>的对象。",
          "testString": "assert(requestingData().type === REQUESTING_DATA, '<code>requesData</code> action creator 应返回类型和值都为<code>REQUESTING_DATA</code>的对象。');"
        },
        {
          "text": "<code>receivedData</code> action creator 应返回类型和值都等于<code>RECEIVED_DATA</code>的对象。",
          "testString": "assert(receivedData('data').type === RECEIVED_DATA, '<code>receivedData</code> action creator 应返回类型和值都等于<code>RECEIVED_DATA</code>的对象。');"
        },
        {
          "text": "<code>asyncDataReducer</code>必须是个函数。",
          "testString": "assert(typeof asyncDataReducer === 'function', '<code>asyncDataReducer</code>必须是个函数。');"
        },
        {
          "text": "分发 requestedData 后 action creator 应该将 store 中的<code>state</code>的 fetching 的值更新为 <code>true</code>。",
          "testString": "assert((function() { const initialState = store.getState(); store.dispatch(requestingData()); const reqState = store.getState(); return initialState.fetching === false && reqState.fetching === true })(), '分发 requestedData 后 action creator 应该将 store 中的<code>state</code>的 fetching 的值更新为 <code>true</code>。');"
        },
        {
          "text": "如果要 dispatch <code>handleAsync</code> 应先 dispatch 数据请求的 action，然后在收到请求结果后再 dispatch 接收的数据 action。",
          "testString": "assert((function() { const noWhiteSpace = handleAsync.toString().replace(/\\s/g,''); return noWhiteSpace.includes('dispatch(requestingData())') === true && noWhiteSpace.includes('dispatch(receivedData(data))') === true })(), '如果要 dispatch <code>handleAsync</code> 应先 dispatch 数据请求的 action，然后在收到请求结果后再 dispatch 接收的数据 action。');"
        }
      ],
      "solutions": [
        "const REQUESTING_DATA = 'REQUESTING_DATA'\nconst RECEIVED_DATA = 'RECEIVED_DATA'\n\nconst requestingData = () => { return {type: REQUESTING_DATA} }\nconst receivedData = (data) => { return {type: RECEIVED_DATA, users: data.users} }\n\nconst handleAsync = () => {\n  return function(dispatch) {\n    dispatch(requestingData());\n    setTimeout(function() {\n      let data = {\n        users: ['Jeff', 'William', 'Alice']\n      }\n      dispatch(receivedData(data));\n    }, 2500);\n  }\n};\n\nconst defaultState = {\n  fetching: false,\n  users: []\n};\n\nconst asyncDataReducer = (state = defaultState, action) => {\n  switch(action.type) {\n    case REQUESTING_DATA:\n      return {\n        fetching: true,\n        users: []\n      }\n    case RECEIVED_DATA:\n      return {\n        fetching: false,\n        users: action.users\n      }\n    default:\n      return state;\n  }\n};\n\nconst store = Redux.createStore(\n  asyncDataReducer,\n  Redux.applyMiddleware(ReduxThunk.default)\n);"
      ],
      "challengeType": 6,
      "isRequired": false,
      "redux": true
    },
    {
      "id": "5a24c314108439a4d4036157",
      "title": "Write a Counter with Redux",
      "releasedOn": "December 25, 2017",
      "description": [
        "现在你已经了解了 Redux 的所有核心原则！你已经了解了如何创建 action 和动 action creator，创建 Redux store，通过 store dispatch action，以及使用纯粹的 reducer 设计状态更新。你甚至已经看到过如何使用 reducer 组合管理复杂状态并处理异步操作。这些例子很简单，但这些概念是 Redux 的核心原则。如果你理解它们，你就可以开始构建自己的 Redux 应用了。接下来的挑战包括关于<code>state</code>不变性的一些细节，但是，这里是对你到目前为止学到的所有内容的回顾。",
        "<hr>",
        "在本课程中，你将从头开始使用 Redux 实现一个简单的计数器。基本知识在代码编辑器中提供，但你必须完成详细的内容！使用提供给你的名称并定义<code>incAction</code>和<code>decActio</code> action creator <code>counterReducer()</code>，<code>INCREMENT</code>和<code>DECREMENT</code> action 类型，最后是 Redux <code>store</code>。一旦完成，你应该能够 dispatch <code>INCREMENT</code>或<code>DECREMENT</code>动作来增加或减少<code>store</code>中保存的状态。开始构建你的第一个 Redux 应用程序吧，祝你好运！"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const INCREMENT = null; //为增量 action 类型定义一个常量",
            "const DECREMENT = null; //为减量 action 类型定义一个常量",
            "",
            "const counterReducer = null; //定义计数器，它将根据收到的action增加或减少状态",
            "",
            "const incAction = null; //定义一个用于递增的 action creator",
            "",
            "const decAction = null; //定义一个用于递减的 action creator",
            "",
            "const store = null; //在这里定义一个 Redux store，传递你的 reducer"
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "action creator <code>incAction</code>应返回一个 action 对象{type:'INCREMENT'}。",
          "testString": "assert(incAction().type ===INCREMENT, 'action creator <code>incAction</code>应返回一个 action 对象{type:'INCREMENT'}。');"
        },
        {
          "text": "action creator <code>decAction</code>应返回一个 action 对象{type:'DECREMENT'}。",
          "testString": "assert(decAction().type === DECREMENT, 'action creator <code>decAction</code>应返回一个 action 对象{type:'DECREMENT'}。');"
        },
        {
          "text": "Redux store 应该将<code>state</code>初始化为 0。",
          "testString": "assert(store.getState() === 0, 'Redux store 应该将<code>state</code>初始化为 0。');"
        },
        {
          "text": "在 Redux store 上 dispatch <code>incAction</code>应该将<code>state</code>增加 1。",
          "testString": "assert((function() { const initialState = store.getState(); store.dispatch(incAction()); const incState = store.getState(); return initialState + 1 === incState })(), 'Redux store 上 dispatch <code>incAction</code>应该将<code>state</code>增加 1。');"
        },
        {
          "text": "在 Redux store 上 dispatch <code>decAction</code>应该将<code>state</code>减少 1。",
          "testString": "assert((function() { const initialState = store.getState(); store.dispatch(decAction()); const decState = store.getState(); return initialState - 1 === decState })(), '在 Redux store 上 dispatch <code>decAction</code>应该将<code>state</code>减少 1。');"
        },
        {
          "text": "<code>counterReducer</code>必须是一个函数。",
          "testString": "assert(typeof counterReducer === 'function', '<code>counterReducer</code>必须是一个函数。');"
        }
      ],
      "solutions": [
        "const INCREMENT = 'INCREMENT';\nconst DECREMENT = 'DECREMENT';\n\nconst counterReducer = (state = 0, action) => {\n  switch(action.type) {\n    case INCREMENT:\n      return state + 1;\n    case DECREMENT:\n      return state - 1;\n    default:\n      return state;\n  }\n};\n\nconst incAction = () => {\n  return {\n    type: INCREMENT\n  }\n};\n\nconst decAction = () => {\n  return {\n    type: DECREMENT\n  }\n};\n\nconst store = Redux.createStore(counterReducer);"
      ],
      "challengeType": 6,
      "isRequired": false,
      "redux": true
    },
    {
      "id": "5a24c314108439a4d4036158",
      "title": "Never Mutate State",
      "releasedOn": "December 25, 2017",
      "description": [
        "这些最后的挑战描述了在 Redux 中强制执行状态不变性关键原则的几种方法。不可变状态意味着你永远不会直接修改状态，而是返回一个新的状态副本。",
        "如果你拍摄 Redux 应用程序状态的快照，你会看到类似<code>state 1</ code>，<code>state 2</code>，<code>state 3</code>，<code>state 4</code>，<code>...</code>等等，每个状态可能与最后一个状态相似，但每个状态都是一个独特的数据。事实上，这种不变性是什么提供了你可能听说过的时间旅行调试等功能。",
        "Redux 并没有积极地在其 store 或者 reducer 中强制执行状态不变性，责任落在程序员身上。幸运的是，JavaScript （尤其是ES6） 提供了一些有用的工具，可以用来强制执行状态的不变性，无论是<code>string</code>，<code>number</code>，<code>array</code>或<code>object</code>。请注意，字符串和数字是原始值，并且本质上是不可变的。换句话说，3 总是 3，你不能改变数字 3 的值。然而，<code>array</code>或<code>object</code>是可变的。实际上，你的状态可能包括<code>array</code>或<code>object</code>，因为它们在表示许多类型信息的数据结构时非常有用。",
        "<hr>",
        "代码编辑器中有一个<code>store</code>和<code>reducer</code>，用于管理待办事项。完成在 reducer 中编写<code>ADD_TO_DO</code>的情况，使用标准 JavaScript 或 ES6 可以通过几种方法来实现这一目标。看看是否可以找到一种方法来返回一个新数组，其中来自<code>action.todo</code>的项目添加到数组的末尾。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const ADD_TO_DO = 'ADD_TO_DO';",
            "",
            "//一个字符串列表表示要做的任务",
            "const todos = [",
            "  'Go to the store',",
            "  'Clean the house',",
            "  'Cook dinner',",
            "  'Learn to code',",
            "];",
            "",
            "const immutableReducer = (state = todos, action) => {",
            "  switch(action.type) {",
            "    case ADD_TO_DO:",
            "      //不要在这里改变 state，否则测试将失败",
            "      return",
            "    default:",
            "      return state;",
            "  }",
            "};",
            "",
            "//一个 todo 的例子是 'Learn React'，",
            "const addToDo = (todo) => {",
            "  return {",
            "    type: ADD_TO_DO,",
            "    todo",
            "  }",
            "}",
            "",
            "const store = Redux.createStore(immutableReducer);"
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "Redux store 应该在代码编辑器中存在并使用名字为<code>todos</code>的数组进行状态初始化。",
          "testString": "assert((function() { const todos = [ 'Go to the store', 'Clean the house', 'Cook dinner', 'Learn to code' ]; const initialState = store.getState(); return Array.isArray(initialState) && initialState.join(',') === todos.join(','); })(), 'Redux store 应该在代码编辑器中存在并使用名字为<code>todos</code>的数组进行状态初始化。');"
        },
        {
          "text": "<code>addToDo</code>和<code>immutableReducer</code>都应该是函数。",
          "testString": "assert(typeof addToDo === 'function' && typeof immutableReducer === 'function', '<code>addToDo</code>和<code>immutableReducer</code>都应该是函数。');"
        },
        {
          "text": "在 Redux store 上 dispatch 一个类型为<code>ADD_TO_DO</code>的aciton应该添加一个<code>todo</code>项，并且不应该改变 state。",
          "testString": "assert((function() { const initialState = store.getState(); const isFrozen = DeepFreeze(initialState); store.dispatch(addToDo('__TEST__TO__DO__')); const finalState = store.getState(); const expectedState = [ 'Go to the store', 'Clean the house', 'Cook dinner', 'Learn to code', '__TEST__TO__DO__' ]; return( isFrozen && DeepEqual(finalState, expectedState)); })(), '在 Redux store 上 dispatch 一个类型为<code>ADD_TO_DO</code>的aciton应该添加一个<code>todo</code>项，并且不应该改变 state。');"
        }
      ],
      "solutions": [
        "const ADD_TO_DO = 'ADD_TO_DO';\n\n// A list of strings representing tasks to do:\nconst todos = [\n  'Go to the store',\n  'Clean the house',\n  'Cook dinner',\n  'Learn to code',\n];\n\nconst immutableReducer = (state = todos, action) => {\n  switch(action.type) {\n    case ADD_TO_DO:\n      return state.concat(action.todo);\n    default:\n      return state;\n  }\n};\n\n// an example todo argument would be 'Learn React',\nconst addToDo = (todo) => {\n  return {\n    type: ADD_TO_DO,\n    todo\n  }\n}\n\nconst store = Redux.createStore(immutableReducer);"
      ],
      "challengeType": 6,
      "isRequired": false,
      "redux": true
    },
    {
      "id": "5a24c314108439a4d4036159",
      "title": "Use the Spread Operator on Arrays",
      "releasedOn": "December 25, 2017",
      "description": [
        "ES6 中有助于在 Redux 中强制执行状态不变性的一个解决方案是扩展运算符：<code>...</code>。扩展运算符具有很多的应用，其中一种非常适合通过一个已有的数组生成一个新数组。这是相对较新的，但常用的语法。例如，如果你有一个数组<code>myArray</code>并写：",
        "<code>let newArray = [...myArray];</code>",
        "<code>newArray</code>现在是<code>myArray</code>的克隆。两个数组仍然在内存中单独存在。如果你执行像<code>newArray.push(5)</code>这样的突变，<code>myArray</code>不会改变。<code>...</code>有效<i>将<code>myArray</code>中的值<i>传播到新数组中。要克隆数组但在新数组中添加其他值，可以编写<code>[... myArray，'new value']</code>。这将返回一个由<code>中的值组成的新数组。</code>myArray</code>和字符串<code>'new value'</code>作为最后一个值。扩展语法可以像这样在数组组合中多次使用，但重要的是要注意它只做一个浅拷贝这就是说，它只为一维数组提供了不可变的数组操作。",
        "<hr>",
        "添加待办事项时，使用 spread 运算符返回新的状态副本。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const immutableReducer = (state = ['Do not mutate state!'], action) => {",
            "  switch(action.type) {",
            "    case 'ADD_TO_DO':",
            "      //不要在这里改变 state 否则测试会失败。",
            "      return",
            "    default:",
            "      return state;",
            "  }",
            "};",
            "",
            "const addToDo = (todo) => {",
            "  return {",
            "    type: 'ADD_TO_DO',",
            "    todo",
            "  }",
            "}",
            "",
            "const store = Redux.createStore(immutableReducer);"
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "Redux store 应该存在并初始化一个<code>[Do not mutate state！]</code>的状态。",
          "testString": "assert((function() { const initialState = store.getState(); return ( Array.isArray(initialState) === true && initialState[0] === 'Do not mutate state!'); })(), 'Redux store 应该存在并初始化一个<code>[Do not mutate state！]</code>的状态。');"
        },
        {
          "text": "<code>addToDo</code>和<code>immutableReducer</code>都应该是一个函数。",
          "testString": "assert(typeof addToDo === 'function' && typeof immutableReducer === 'function', '<code>addToDo</code>和<code>immutableReducer</code>都应该是一个函数。');"
        },
        {
          "text": "在 Redux store 上 dispatch 一个类型为<code>ADD_TO_DO</code> aciton 应该添加一个<code>todo</code>项，并且不应该改变 state。",
          "testString": "assert((function() { const initialState = store.getState(); const isFrozen = DeepFreeze(initialState); store.dispatch(addToDo('__TEST__TO__DO__')); const finalState = store.getState(); const expectedState = [ 'Do not mutate state!', '__TEST__TO__DO__' ]; return( isFrozen && DeepEqual(finalState, expectedState)); })(), '在 Redux store 上 dispatch 一个类型为<code>ADD_TO_DO</code> aciton 应该添加一个<code>todo</code>项，并且不应该改变 state。');"
        },
        {
          "text": "应使用扩展运算符返回新的 state。",
          "testString": "getUserInput => assert(getUserInput('index').includes('...state'), '应使用扩展运算符返回新的 state。');"
        }
      ],
      "solutions": [
        "const immutableReducer = (state = ['Do not mutate state!'], action) => {\n  switch(action.type) {\n    case 'ADD_TO_DO':\n      return [\n        ...state,\n        action.todo\n      ];\n    default:\n      return state;\n  }\n};\n\nconst addToDo = (todo) => {\n  return {\n    type: 'ADD_TO_DO',\n    todo\n  }\n}\n\nconst store = Redux.createStore(immutableReducer);"
      ],
      "challengeType": 6,
      "isRequired": false,
      "redux": true
    },
    {
      "id": "5a24c314108439a4d403615a",
      "title": "Remove an Item from an Array",
      "releasedOn": "December 25, 2017",
      "description": [
        "是时候练习从数组中删除项目了。扩展运算符也可以在这里使用。其他有用的JavaScript方法包括<code>slice()</code>和<code>concat()</code>。",
        "<hr>",
        "reducer 和 action creator 被修改为根据项目的索引从数组中删除一个项目。完成编写 reducer 以便返回一个新的状态数组，并删除特定索引处的项目。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const immutableReducer = (state = [0,1,2,3,4,5], action) => {",
            "  switch(action.type) {",
            "    case 'REMOVE_ITEM':",
            "      //不要在这里改变 state 否则测试会失败。",
            "      return",
            "    default:",
            "      return state;",
            "  }",
            "};",
            "",
            "const removeItem = (index) => {",
            "  return {",
            "    type: 'REMOVE_ITEM',",
            "    index",
            "  }",
            "}",
            "",
            "const store = Redux.createStore(immutableReducer);"
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "Redux store 应该存在并初始化一个<code>[0,1,2,3,4,5]</code>的状态。",
          "testString": "assert((function() { const initialState = store.getState(); return (Array.isArray(initialState) === true && DeepEqual(initialState, [0, 1, 2, 3, 4, 5])); })(), 'Redux store 应该存在并初始化一个<code>[0,1,2,3,4,5]</code>的状态。');"
        },
        {
          "text": "<code>removeItem</code>和<code>immutableReducer</code>都应该是一个函数。",
          "testString": "assert(typeof removeItem === 'function' && typeof immutableReducer === 'function', '<code>removeItem</code>和<code>immutableReducer</code>都应该是一个函数。');"
        },
        {
          "text": "dispatch <code>removeItem</code> action creator 应该从 state 中删除项目，不应该改变 state。",
          "testString": "assert((function() { const initialState = store.getState(); const isFrozen = DeepFreeze(initialState); store.dispatch(removeItem(3)); const state_1 = store.getState(); store.dispatch(removeItem(2)); const state_2 = store.getState(); store.dispatch(removeItem(0)); store.dispatch(removeItem(0)); store.dispatch(removeItem(0)); const state_3 = store.getState(); return isFrozen && DeepEqual(state_1, [0, 1, 2, 4, 5]) && DeepEqual(state_2, [0, 1, 4, 5]) && DeepEqual(state_3, [5]); })(), 'dispatch <code>removeItem</code> action creator 应该从 state 中删除项目，不应该改变 state。');"
        }
      ],
      "solutions": [
        "const immutableReducer = (state = [0,1,2,3,4,5], action) => {\n  switch(action.type) {\n    case 'REMOVE_ITEM':\n      return [\n        ...state.slice(0, action.index),\n        ...state.slice(action.index + 1)\n      ];\n    default:\n      return state;\n  }\n};\n\nconst removeItem = (index) => {\n  return {\n    type: 'REMOVE_ITEM',\n    index\n  }\n}\n\nconst store = Redux.createStore(immutableReducer);"
      ],
      "challengeType": 6,
      "isRequired": false,
      "redux": true
    },
    {
      "id": "5a24c314108439a4d403615b",
      "title": "Copy an Object with Object.assign",
      "releasedOn": "December 25, 2017",
      "description": [
        "最后几个挑战适用于数组，但是当状态是<code>object</code>时，有一些方法可以帮助强制执行状态不变性。处理对象的一个方法是<code>Object.assign()</code>。<code> Object.assign()</code>获取目标对象和源对象，并将源对象中的属性映射到目标对象。任何匹配的属性都会被源对象中的属性覆盖。通常用于通过传递一个空对象作为第一个参数，然后是要用复制的对象来制作对象的浅表副本。这是一个例子：",
        "<code>const newObject = Object.assign({}, obj1, obj2);</code>",
        "这会创建<code>newObject</code>作为新的<code>object</code>，其中包含<code>obj1</code>和<code>obj2</code>中当前存在的属性。",
        "<hr>",
        "Redux 状态和 action 被修改为处理<code>state</code>的<code>对象</code>。编辑代码以返回一个新的<code>state</code>对象，用于类型的 action<code>ONLINE</code>，它将<code>status</code>属性设置为字符串<code>online</code>。尝试使用<code>Object.assign()</code>来完成挑战。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const defaultState = {",
            "  user: 'CamperBot',",
            "  status: 'offline',",
            "  friends: '732,982',",
            "  community: 'freeCodeCamp'",
            "};",
            "",
            "const immutableReducer = (state = defaultState, action) => {",
            "  switch(action.type) {",
            "    case 'ONLINE':",
            "      //不要在这里改变 state 否则测试会失败。",
            "      return",
            "    default:",
            "      return state;",
            "  }",
            "};",
            "",
            "const wakeUp = () => {",
            "  return {",
            "    type: 'ONLINE'",
            "  }",
            "};",
            "",
            "const store = Redux.createStore(immutableReducer);"
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "Redux store 应该存在并使用与第 1 行声明的<code>defaultState</code>对象相同的状态进行初始化。",
          "testString": "assert((function() { const expectedState = { user: 'CamperBot', status: 'offline', friends: '732,982', community: 'freeCodeCamp' }; const initialState = store.getState(); return DeepEqual(expectedState, initialState); })(), 'Redux store 应该存在并使用与第 1 行声明的<code>defaultState</code>对象相同的状态进行初始化。');"
        },
        {
          "text": "<code>wakeUp</code>和<code>immutableReducer</code>都应该是函数。",
          "testString": "assert(typeof wakeUp === 'function' && typeof immutableReducer === 'function', '<code>wakeUp</code>和<code>immutableReducer</code>都应该是函数。');"
        },
        {
          "text": "dispatch 一个类型为<code>ONLINE</code>的 action 应该将状态<code>status</code>更新为<code>online</code>，并且不应该改变状态。",
          "testString": "assert((function() { const initialState = store.getState(); const isFrozen = DeepFreeze(initialState); store.dispatch({type: 'ONLINE'}); const finalState = store.getState(); const expectedState = { user: 'CamperBot', status: 'online', friends: '732,982', community: 'freeCodeCamp' }; return isFrozen && DeepEqual(finalState, expectedState); })(), 'dispatch 一个类型为<code>ONLINE</code>的 action 应该将状态<code>status</code>更新为<code>online</code>，并且不应该改变状态。');"
        },
        {
          "text": "<code>Object.assign</code>应该被用于返回一个新状态。",
          "testString": "getUserInput => assert(getUserInput('index').includes('Object.assign'), '<code>Object.assign</code>应该被用于返回一个新状态。');"
        }
      ],
      "solutions": [
        "const defaultState = {\n  user: 'CamperBot',\n  status: 'offline',\n  friends: '732,982',\n  community: 'freeCodeCamp'\n};\n\nconst immutableReducer = (state = defaultState, action) => {\n  switch(action.type) {\n    case 'ONLINE':\n      return Object.assign({}, state, {\n        status: 'online'\n      });\n    default:\n      return state;\n  }\n};\n\nconst wakeUp = () => {\n  return {\n    type: 'ONLINE'\n  }\n};\n\nconst store = Redux.createStore(immutableReducer);"
      ],
      "challengeType": 6,
      "isRequired": false,
      "redux": true
    }
  ]
}

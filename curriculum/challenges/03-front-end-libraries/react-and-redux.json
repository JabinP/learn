{
  "name": "React and Redux",
  "order": 7,
  "time": "5 hours",
  "helpRoom": "Help",
  "required": [
    {
      "src": "https://unpkg.com/react@16.4.0/umd/react.production.min.js"
    },
    {
      "src": "https://unpkg.com/react-dom@16.4.0/umd/react-dom.production.min.js"
    },
    {
      "src": "https://cdnjs.cloudflare.com/ajax/libs/redux/3.7.2/redux.min.js"
    },
    {
      "src": "https://cdnjs.cloudflare.com/ajax/libs/react-redux/5.0.7/react-redux.min.js"
    }
  ],
  "template": "<body><div id='root'></div>${ source || '' }</body>",
  "challenges": [
    {
      "id": "5a24c314108439a4d4036141",
      "title": "Getting Started with React Redux",
      "releasedOn": "December 25, 2017",
      "description": [
        "这一系列挑战介绍的是 Redux 和 React 的配合，我们先来回顾一下这两种技术的关键原则是什么。React 是提供数据的视图库，能以高效、可预测的方式渲染视图。Redux 是状态管理框架，可用于简化 APP 应用状态的管理。在 React Redux app 应用中，通常可创建单一的 Redux store 来管理整个应用的状态。React 组件仅订阅 store 中与其角色相关的数据，你可直接从 React 组件中分发 actions 以触发 store 对象的更新。",
        "React 组件可以在本地管理自己的状态，但是对于复杂的应用来说，它的状态最好是用 Redux 保存在单一位置，有特定本地状态的独立组件例外。最后一点是，Redux 没有内置的 React，需要安装<code>react-redux</code>包，通过这个方式把 Redux 的<code>state</code>和<code>dispatch</code>作为<code>props</code>传给组件。",
        "在接下来的挑战中，先要创建一个可输入新文本消息的 React 组件，添加这些消息到数组里，在视图上显示数组。接着，创建 Redux store 和 actions 来管理消息数组的状态。最后，使用<code>react-redux</code>连接 Redux store 和组件，从而将本地状态提取到 Redux store 中。",
        "<hr>",
        "创建<code>DisplayMessages</code>组件，把构造函数添加到此组件中，使用含两个属性的状态初始化该组件，这两个属性为：input（设置为空字符串），<code>messages</code>（设置为空数组）。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class DisplayMessages extends React.Component {",
            "// 请在本行以下添加你的代码",
            "",
            "// 请在本行以上添加你的代码",
            "  render() {",
            "    return <div />",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<DisplayMessages />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>DisplayMessages</code>组件应渲染空的<code>div</code>元素。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(DisplayMessages)); return mockedComponent.find('div').text() === '' })(), '<code>DisplayMessages</code>组件应渲染空的<code>div</code>元素。');"
        },
        {
          "text": "<code>DisplayMessages</code>组件的构造函数应调用<code>super</code>，传入<code>props</code>。",
          "testString": "getUserInput => assert((function() { const noWhiteSpace = getUserInput('index').replace(/\\s/g,''); return noWhiteSpace.includes('constructor(props)') && noWhiteSpace.includes('super(props'); })(), '<code>DisplayMessages</code>组件的构造函数应调用<code>super</code>，传入<code>props</code>。');"
        },
        {
          "text": "<code>DisplayMessages</code>组件的初始状态应是<code>{input: \"\", messages: []}</code>。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(DisplayMessages)); const initialState = mockedComponent.state(); return typeof initialState === 'object' && initialState.input === '' && Array.isArray(initialState.messages) && initialState.messages.length === 0; })(), '<code>DisplayMessages</code>组件的初始状态应是<code>{input: \"\", messages: []}</code>。');"
        }
      ],
      "solutions": [
        "class DisplayMessages extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      input: '',\n      messages: []\n    }\n  }\n  render() {\n    return <div/>\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036142",
      "title": "Manage State Locally First",
      "releasedOn": "December 25, 2017",
      "description": [
        "这一关的任务是完成<code>DisplayMessages</code>组件的创建。",
        "<hr>",
        "首先，在<code>render()</code>方法中，让组件渲染<code>input</code>、<code>button</code>、<code>ul</code>三个元素。<code>input</code>元素的改变会触发<code>handleChange()</code>方法。此外，<code>input</code>元素会渲染组件状态中<code>input</code>的值。点击按钮<code>button</code>需触发<code>submitMessage()</code>方法。",
        "接着，写出这两种方法。<code>handleChange()</code>方法会更新<code>input</code>为用户正在输入的内容。<code>submitMessage()</code>方法把当前存储在<code>input</code>的消息与本地状态的<code>messages</code>数组连接起来，并清除<code>input</code>的值。",
        "最后，在<code>ul</code>中展示<code>messages</code>数组，其中每个元素内容需放到<code>li</code>元素内。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class DisplayMessages extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      input: '',",
            "      messages: []",
            "    }",
            "  }",
            "// 请把 handleChange()、submitMessage() 写在这里",
            "",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h2>键入新 Message</h2>",
            "        { /* 在此渲染 input、button、ul*/ }",
            "",
            "        { /* 请在本行以上添加你的代码 */ }",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<DisplayMessages />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>DisplayMessages</code>组件的初始状态应是<code>{ input: \"\", messages: [] }</code>。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(DisplayMessages)); const initialState = mockedComponent.state(); return ( typeof initialState === 'object' && initialState.input === '' && initialState.messages.length === 0); })(), '<code>DisplayMessages</code>组件的初始状态应是<code>{ input: \"\", messages: [] }</code>。');"
        },
        {
          "text": "<code>DisplayMessages</code>组件应渲染含<code>h2</code>、<code>button</code>、<code>ul</code>、<code>li</code>四个子元素的<code>div</code>。",
          "testString": "async () => { const mockedComponent = Enzyme.mount(React.createElement(DisplayMessages)); const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 100)); const state = () => { mockedComponent.setState({messages: ['__TEST__MESSAGE']}); return waitForIt(() => mockedComponent )}; const updated = await state(); assert(updated.find('div').length === 1 && updated.find('h2').length === 1 && updated.find('button').length === 1 && updated.find('ul').length === 1, '<code>DisplayMessages</code>组件应渲染含<code>h2</code>、<code>button</code>、<code>ul</code>、<code>li</code>四个子元素的<code>div</code>。'); }; "
        },
        {
          "text": "<code>input</code>元素应渲染本地状态中的<code>input</code>值。",
          "testString": "async () => { const mockedComponent = Enzyme.mount(React.createElement(DisplayMessages)); const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 100)); const causeChange = (c, v) => c.find('input').simulate('change', { target: { value: v }}); const testValue = '__TEST__EVENT__INPUT'; const changed = () => { causeChange(mockedComponent, testValue); return waitForIt(() => mockedComponent )}; const updated = await changed(); assert(updated.find('input').props().value === testValue, '<code>input</code>元素应渲染本地状态中的<code>input</code>值。'); }; "
        },
        {
          "text": "调用<code>handleChange</code>方法时应更新状态中的<code>input</code>值为当前输入。",
          "testString": "async () => { const mockedComponent = Enzyme.mount(React.createElement(DisplayMessages)); const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 100)); const causeChange = (c, v) => c.find('input').simulate('change', { target: { value: v }}); const initialState = mockedComponent.state(); const testMessage = '__TEST__EVENT__MESSAGE__'; const changed = () => { causeChange(mockedComponent, testMessage); return waitForIt(() => mockedComponent )}; const afterInput = await changed(); assert(initialState.input === '' && afterInput.state().input === '__TEST__EVENT__MESSAGE__', '调用<code>handleChange</code>方法时应更新状态中的<code>input</code>值为当前输入。');  }; "
        },
        {
          "text": "单击<code>Add message</code>按钮应调用<code>submitMessage</code>方法，添加当前<code>输入</code>到状态中的<code>消息</code>数组。",
          "testString": "async () => { const mockedComponent = Enzyme.mount(React.createElement(DisplayMessages)); const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 100)); const causeChange = (c, v) => c.find('input').simulate('change', { target: { value: v }}); const initialState = mockedComponent.state(); const testMessage_1 = '__FIRST__MESSAGE__'; const firstChange = () => { causeChange(mockedComponent, testMessage_1); return waitForIt(() => mockedComponent )}; const firstResult = await firstChange(); const firstSubmit = () => { mockedComponent.find('button').simulate('click'); return waitForIt(() => mockedComponent )}; const afterSubmit_1 = await firstSubmit(); const submitState_1 = afterSubmit_1.state(); const testMessage_2 = '__SECOND__MESSAGE__'; const secondChange = () => { causeChange(mockedComponent, testMessage_2); return waitForIt(() => mockedComponent )}; const secondResult = await secondChange(); const secondSubmit = () => { mockedComponent.find('button').simulate('click'); return waitForIt(() => mockedComponent )}; const afterSubmit_2 = await secondSubmit(); const submitState_2 = afterSubmit_2.state(); assert(initialState.messages.length === 0 && submitState_1.messages.length === 1 && submitState_2.messages.length === 2 && submitState_2.messages[1] === testMessage_2, '单击<code>Add message</code>按钮应调用<code>submitMessage</code>方法，添加当前<code>输入</code>到状态中的<code>消息</code>数组。'); }; "
        },
        {
          "text": "<code>submitMessage</code>方法应清除当前输入。",
          "testString": "async () => { const mockedComponent = Enzyme.mount(React.createElement(DisplayMessages)); const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 100)); const causeChange = (c, v) => c.find('input').simulate('change', { target: { value: v }}); const initialState = mockedComponent.state(); const testMessage = '__FIRST__MESSAGE__'; const firstChange = () => { causeChange(mockedComponent, testMessage); return waitForIt(() => mockedComponent )}; const firstResult = await firstChange(); const firstState = firstResult.state(); const firstSubmit = () => { mockedComponent.find('button').simulate('click'); return waitForIt(() => mockedComponent )}; const afterSubmit = await firstSubmit(); const submitState = afterSubmit.state(); assert(firstState.input === testMessage && submitState.input === '', '<code>submitMessage</code>方法应清除当前输入。'); }; "
        }
      ],
      "solutions": [
        "class DisplayMessages extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      input: '',\n      messages: []\n    }\n this.handleChange = this.handleChange.bind(this); \n   this.submitMessage = this.submitMessage.bind(this);  \n }\n  handleChange(event) {\n    this.setState({\n      input: event.target.value\n    });\n  }\n  submitMessage() {\n    const currentMessage = this.state.input;\n    this.setState({\n      input: '',\n      messages: this.state.messages.concat(currentMessage)\n    });\n  }\n  render() {\n    return (\n      <div>\n        <h2>Type in a new Message:</h2>\n        <input\n          value={this.state.input}\n          onChange={this.handleChange}/><br/>\n        <button onClick={this.submitMessage}>Submit</button>\n        <ul>\n          {this.state.messages.map( (message, idx) => {\n              return (\n                 <li key={idx}>{message}</li>\n              )\n            })\n          }\n        </ul>\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "reactRedux": true
    },
    {
      "id": "5a24c314108439a4d4036143",
      "title": "Extract State Logic to Redux",
      "releasedOn": "December 25, 2017",
      "description": [
        "完成 React 组件后，我们需要把在本地<code>状态</code>执行的逻辑移到 Redux 中，这是为小规模 React 应用添加 Redux 的第一步。该应用的唯一功能是把用户的新消息添加到无序列表中。下面我们用简单的示例来演示 React 和 Redux 之间的配合。",
        "<hr>",
        "首先，定义 action 的类型 'ADD'，将其设置为常量<code>ADD</code>。接着，定义创建 action 的函数<code>addMessage()</code>，用该函数创建添加消息的 action，把<code>message</code>传给创建 action 的函数并返回包含该消息的<code>action</code>",
        "接着，创建名为<code>messageReducer()</code>的 reducer 方法，为这些消息处理状态。初始状态应为空数组。reducer 向状态中的消息数组添加消息，或返回当前状态。最后，创建 Redux store 并传给 reducer。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "// 请在此处定义 ADD、addMessage()、messageReducer()、store：",
            ""
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "应存在一个值为字符串<code>ADD</code>的常量<code>ADD</code>。",
          "testString": "assert(ADD === 'ADD', '应存在一个值为字符串<code>ADD</code>的常量<code>ADD</code>。');"
        },
        {
          "text": "创建 action 的函数<code>addMessage</code>应返回<code>type</code>等于<code>ADD</code>的对象，其返回的消息即被传入的消息。",
          "testString": "assert((function() { const addAction = addMessage('__TEST__MESSAGE__'); return addAction.type === ADD && addAction.message === '__TEST__MESSAGE__'; })(), '创建 action 的函数<code>addMessage</code>应返回<code>type</code>等于<code>ADD</code>的对象，其返回的消息即被传入的消息。');"
        },
        {
          "text": "<code>messageReducer</code>应是一个函数。",
          "testString": "assert(typeof messageReducer === 'function', '<code>messageReducer</code>应是一个函数。');"
        },
        {
          "text": "存在一个 store 且其初始状态为空数组。",
          "testString": "assert((function() { const initialState = store.getState(); return typeof store === 'object' && initialState.length === 0; })(), '存在一个 store 且其初始状态为空数组。');"
        },
        {
          "text": "分发<code>addMessage</code>到 store 应添加新消息到状态中消息数组。",
          "testString": "assert((function() { const initialState = store.getState(); const isFrozen = DeepFreeze(initialState); store.dispatch(addMessage('__A__TEST__MESSAGE')); const addState = store.getState(); return (isFrozen && addState[0] === '__A__TEST__MESSAGE'); })(), '分发<code>addMessage</code>到 store 应添加新消息到状态中消息数组。');"
        },
        {
          "text": "<code>messageReducer</code>被其它任何 actions 调用时应返回当前状态。",
          "testString": "assert((function() { const addState = store.getState(); store.dispatch({type: 'FAKE_ACTION'}); const testState = store.getState(); return (addState === testState); })(), '<code>messageReducer</code>被其它任何 actions 调用时应返回当前状态。');"
        }
      ],
      "solutions": [
        "const ADD = 'ADD';\n\nconst addMessage = (message) => {\n  return {\n    type: ADD,\n    message\n  }\n};\n\nconst messageReducer = (state = [], action) => {\n  switch (action.type) {\n    case ADD:\n      return [\n        ...state,\n        action.message\n      ];\n    default:\n      return state;\n  }\n};\n\nconst store = Redux.createStore(messageReducer);"
      ],
      "challengeType": 6,
      "isRequired": false,
      "reactRedux": true
    },
    {
      "id": "5a24c314108439a4d4036144",
      "title": "Use Provider to Connect Redux to React",
      "releasedOn": "December 25, 2017",
      "description": [
        "在上一挑战中，你创建了 Redux store 和 action，分别用于处理消息数组和添加新消息。下一步要为 React 提供访问 Redux store 及发起更新所需的 actions。<code>react-redux</code>包可帮助我们完成这些任务。",
        "React Redux 提供的 API 有两个关键的功能：<code>Provider</code>和<code>connect</code>。你会在另一个挑战中学<code>connect</code>。<code>Provider</code>是 React Redux 包装 React 应用的 wrapper 组件，它允许你访问整个组件树中的 Redux<code>store</code>及<code>dispatch（分发）</code>方法。<code>Provider</code>需要两个 props：Redux store 和 APP 应用的子组件。用于 APP 组件的<code>Provider</code>可这样定义：",
        "<blockquote>&lt;Provider store={store}&gt;<br>&nbsp;&nbsp;&lt;App/&gt;<br>&lt;/Provider&gt;</blockquote>",
        "<hr>",
        "此时，编辑器上显示的是过去几个挑战中所有代码，包括 Redux store、actions、<code>DisplayMessages</code>组件。新出现的代码是底部的<code>AppWrapper</code>组件，这个顶级组件可用于渲染<code>ReactRedux</code>的<code>Provider</code>，并把 Redux 的 store 作为 props 传入。接着，渲染<code>DisplayMessages</code>为子组件。完成这些任务后，你会看到 React 组件渲染到页面上。",
        "<strong>注意：</strong>&nbsp;React Redux 在此可作全局变量，因此你可通过点号表示法访问 Provider。利用这一点，编辑器上的代码把<code>Provider</code>设置为常量，便于你在<code>AppWrapper</code>渲染方法中使用。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "// Redux 代码：",
            "const ADD = 'ADD';",
            "",
            "const addMessage = (message) => {",
            "  return {",
            "    type: ADD,",
            "    message",
            "  }",
            "};",
            "",
            "const messageReducer = (state = [], action) => {",
            "  switch (action.type) {",
            "    case ADD:",
            "      return [",
            "        ...state,",
            "        action.message",
            "      ];",
            "    default:",
            "      return state;",
            "  }",
            "};",
            "",
            "",
            "",
            "const store = Redux.createStore(messageReducer);",
            "",
            "// React 代码：",
            "",
            "class DisplayMessages extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      input: '',",
            "      messages: []",
            "    }",
            "    this.handleChange = this.handleChange.bind(this);",
            "    this.submitMessage = this.submitMessage.bind(this);",
            "  }",
            "  handleChange(event) {",
            "    this.setState({",
            "      input: event.target.value",
            "    });",
            "  }",
            "  submitMessage() {",
            "    const currentMessage = this.state.input;",
            "    this.setState({",
            "      input: '',",
            "      messages: this.state.messages.concat(currentMessage)",
            "    });",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h2>Type in a new Message:</h2>",
            "        <input",
            "          value={this.state.input}",
            "          onChange={this.handleChange}/><br/>",
            "        <button onClick={this.submitMessage}>Submit</button>",
            "        <ul>",
            "          {this.state.messages.map( (message, idx) => {",
            "              return (",
            "                 <li key={idx}>{message}</li>",
            "              )",
            "            })",
            "          }",
            "        </ul>",
            "      </div>",
            "    );",
            "  }",
            "};",
            "",
            "const Provider = ReactRedux.Provider;",
            "",
            "class AppWrapper extends React.Component {",
            "  // 在此渲染 Provider",
            "",
            "  // 请在本行以上添加你的代码",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<AppWrapper />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>AppWrapper</code>应渲染。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); return mockedComponent.find('AppWrapper').length === 1; })(), '<code>AppWrapper</code>应渲染。');"
        },
        {
          "text": "<code>Provider</code>组件应传入相当于 Redux store 的<code>store</code>参数。",
          "testString": "getUserInput => assert((function() { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); return getUserInput('index').replace(/\\s/g,'').includes('<Providerstore={store}>'); })(), '<code>Provider</code>组件应传入相当于 Redux store 的<code>store</code>参数。');"
        },
        {
          "text": "<code>DisplayMessages</code>应渲染为<code>AppWrapper</code>的子组件。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); return mockedComponent.find('AppWrapper').find('DisplayMessages').length === 1; })(), '<code>DisplayMessages</code>应渲染为<code>AppWrapper</code>的子组件。');"
        },
        {
          "text": "<code>DisplayMessages</code>组件应渲染 h2、input、button、<code>ul</code>四个元素。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); return mockedComponent.find('div').length === 1 && mockedComponent.find('h2').length === 1 && mockedComponent.find('button').length === 1 && mockedComponent.find('ul').length === 1; })(), '<code>DisplayMessages</code>组件应渲染 h2、input、button、<code>ul</code>四个元素。');"
        }
      ],
      "solutions": [
        "// Redux Code:\nconst ADD = 'ADD';\n\nconst addMessage = (message) => {\n  return {\n    type: ADD,\n    message\n  }\n};\n\nconst messageReducer = (state = [], action) => {\n  switch (action.type) {\n    case ADD:\n      return [\n        ...state,\n        action.message\n      ];\n    default:\n      return state;\n  }\n};\n\nconst store = Redux.createStore(messageReducer);\n\n// React Code:\n\nclass DisplayMessages extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      input: '',\n      messages: []\n    }\n this.handleChange = this.handleChange.bind(this); \n this.submitMessage = this.submitMessage.bind(this); \n }\n  handleChange(event) {\n    this.setState({\n      input: event.target.value\n    });\n  }\n  submitMessage() {\n    const currentMessage = this.state.input;\n    this.setState({\n      input: '',\n      messages: this.state.messages.concat(currentMessage)\n    });\n  }\n  render() {\n    return (\n      <div>\n        <h2>Type in a new Message:</h2>\n        <input\n          value={this.state.input}\n          onChange={this.handleChange}/><br/>\n        <button onClick={this.submitMessage}>Submit</button>\n        <ul>\n          {this.state.messages.map( (message, idx) => {\n              return (\n                 <li key={idx}>{message}</li>\n              )\n            })\n          }\n        </ul>\n      </div>\n    );\n  }\n};\n\nconst Provider = ReactRedux.Provider;\n\nclass AppWrapper extends React.Component {\n  // change code below this line\n  render() {\n    return (\n      <Provider store = {store}>\n        <DisplayMessages/>\n      </Provider>\n    );\n  }\n  // change code above this line\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "reactRedux": true
    },
    {
      "id": "5a24c314108439a4d4036145",
      "title": "Map State to Props",
      "releasedOn": "December 25, 2017",
      "description": [
        "<code>Provider</code>可向 React 组件提供<code>state</code>和<code>dispatch</code>，但你必须确切地指定所需要的 state 和 actions，以确保每个组件只能访问所需的 state。完成这个任务，你需要创建两个函数：<code>mapStateToProps()</code>、<code>mapDispatchToProps()</code>。",
        "在这两个函数中，声明 state 中函数所要访问的部分及需要 dispatch 的创建 action 的函数。完成这些，我们就可以迎接下一个挑战，学习如何使用 React Redux 的<code>connect</code>方法来把函数连接到组件了。",
        "<strong>注意：</strong>&nbsp;在幕后，React Redux 用<code>store.subscribe()</code>方法来实现<code>mapStateToProps()</code>。",
        "<hr>",
        "创建<code>mapStateToProps()</code>函数，以<code>state</code>为参数，然后返回一个对象，该对象把 state 映射到特定属性名上，这些属性能通过<code>props</code>访问组件。由于此示例把 app 应用的整个状态保存在单一数组中，你可把整个状态传给组件。在返回的对象中创建<code>messages</code>属性，并设置为<code>state</code>。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const state = [];",
            "",
            "// 请在本行以下添加你的代码",
            ""
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "常量<code>state</code>应为空数组。",
          "testString": "assert(Array.isArray(state) && state.length === 0, '常量<code>state</code>应为空数组。');"
        },
        {
          "text": "<code>mapStateToProps</code>应为函数。",
          "testString": "assert(typeof mapStateToProps === 'function', '<code>mapStateToProps</code>应为函数。');"
        },
        {
          "text": "<code>mapStateToProps</code>应返还一个对象。",
          "testString": "assert(typeof mapStateToProps() === 'object', '<code>mapStateToProps</code><code>mapStateToProps</code>应返还一个对象。');"
        },
        {
          "text": "把 state 数组传入<code>mapStateToProps</code>后应返回赋值给<code>messages</code>键的数组。",
          "testString": "assert(mapStateToProps(['messages']).messages.pop() === 'messages', '把 state 数组传入<code>mapStateToProps</code>后应返回赋值给<code>messages</code>键的数组。');"
        }
      ],
      "solutions": [
        "const state = [];\n\n// change code below this line\n\nconst mapStateToProps = (state) => {\n  return {\n    messages: state\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "reactRedux": true
    },
    {
      "id": "5a24c314108439a4d4036146",
      "title": "Map Dispatch to Props",
      "releasedOn": "December 25, 2017",
      "description": [
        "<code>mapDispatchToProps()</code>函数可为 React 组件提供特定的创建 action 的函数，以便组件可 dispatch actions，从而更改 Redux store 中的数据。该函数的结构跟上一挑战中的<code>mapStateToProps()</code>函数相似，它返回一个对象，把 dispatch actions 映射到属性名上，该属性名成为<code>props</code>。然而，每个属性都返回一个用 action creator 及与 action 相关的所有数据调用<code>dispatch</code>的函数，而不是返回<code>state</code>的一部分。你可以访问<code>dispatch</code>，因为在定义函数时，我们以参数形式把它传入<code>mapDispatchToProps()</code>了，这跟<code>state</code>传入<code>mapDispatchToProps()</code>是一样的。在幕后，React Redux 用 Redux 的<code>store.dispatch()</code>来管理这些含<code>mapDispatchToProps()</code>的dispatches，这跟它使用<code>store.subscribe()</code>来订阅映射到<code>state</code>的组件的方式类似。",
        "例如，创建 action 的函数<code>loginUser()</code>把<code>username</code>作为 action payload，<code>mapDispatchToProps()</code>返回给创建 action 的函数的对象如下：",
        "<blockquote>{<br>&nbsp;&nbsp;submitLoginUser: function(username) {<br>&nbsp;&nbsp;&nbsp;&nbsp;dispatch(loginUser(username));<br>&nbsp;&nbsp;}<br>}</blockquote>",
        "<hr>",
        "编辑器上提供的是创建 action 的函数<code>addMessage()</code>。写出接收<code>dispatch</code>为参数的函数<code>mapDispatchToProps()</code>，返回一个 dispatch 函数对象，其属性为<code>submitNewMessage</code>。该函数在 dispatch <code>addMessage()</code>时为新消息提供一个参数。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const addMessage = (message) => {",
            "  return {",
            "    type: 'ADD',",
            "    message: message",
            "  }",
            "};",
            "",
            "// 请在本行以下添加你的代码",
            ""
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "<code>addMessage</code>应返回含<code>type</code>和<code>message</code>两个键的对象。",
          "testString": "assert((function() { const addMessageTest = addMessage(); return ( addMessageTest.hasOwnProperty('type') && addMessageTest.hasOwnProperty('message')); })(), '<code>addMessage</code>应返回含<code>type</code>和<code>message</code>两个键的对象。');"
        },
        {
          "text": "<code>mapDispatchToProps</code>应为函数。",
          "testString": "assert(typeof mapDispatchToProps === 'function', '<code>mapDispatchToProps</code>应为函数。');"
        },
        {
          "text": "<code>mapDispatchToProps</code>应返回一个对象。",
          "testString": "assert(typeof mapDispatchToProps() === 'object', '<code>mapDispatchToProps</code>应返回一个对象。');"
        },
        {
          "text": "从<code>mapDispatchToProps</code>通过<code>submitNewMessage</code>分发<code>addMessage</code>，应向 dispatch 函数返回一条消息。",
          "testString": "assert((function() { let testAction; const dispatch = (fn) => { testAction = fn; }; let dispatchFn = mapDispatchToProps(dispatch); dispatchFn.submitNewMessage('__TEST__MESSAGE__'); return (testAction.type === 'ADD' && testAction.message === '__TEST__MESSAGE__'); })(), '从<code>mapDispatchToProps</code>通过<code>submitNewMessage</code>分发<code>addMessage</code>，应向 dispatch 函数返回一条消息。');"
        }
      ],
      "solutions": [
        "const addMessage = (message) => {\n  return {\n    type: 'ADD',\n    message: message\n  }\n};\n\n// change code below this line\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    submitNewMessage: function(message) {\n      dispatch(addMessage(message));\n    }\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "reactRedux": true
    },
    {
      "id": "5a24c314108439a4d4036147",
      "title": "Connect Redux to React",
      "releasedOn": "December 25, 2017",
      "description": [
        "既然写了<code>mapStateToProps()</code>、<code>mapDispatchToProps()</code>两个函数，现在你可以用它们来把<code>state</code>和<code>dispatch</code>映射到 React 组件的<code>props</code>了。React Redux 的<code>connect</code>方法可以完成这个任务。此方法有<code>mapStateToProps()</code>、<code>mapDispatchToProps()</code>两个可选参数，它们是可选的，原因是你的组件可能仅需要访问<code>状态</code>但不需要分发任何 actions，反之亦然。",
        "为了使用此方法，需要传入函数参数并在调用时传入组件。这种语法有些不寻常，如下所示：",
        "<code>connect(mapStateToProps, mapDispatchToProps)(MyComponent)</code>",
        "<strong>注意：</strong>&nbsp;如果要省略<code>connect</code>方法中的某个参数，则应当用<code>null</code>替换这个参数。",
        "<hr>",
        "在编辑器上有两个函数：<code>mapStateToProps()</code>、<code>mapDispatchToProps()</code>，还有一个叫<code>Presentational</code>的 React 组件。用<code>ReactRedux</code>全局对象中的<code>connect</code>方法将此组件连接到 Redux，并立即在<code>Presentational</code>组件中调用，把结果赋值给一个名为<code>ConnectedComponent</code>的代表已连接组件的新常量。大功告成！你已成功把 React 连接到 Redux！尝试更改任何一个<code>connect</code>参数为<code>null</code>并观察测试结果。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const addMessage = (message) => {",
            "  return {",
            "    type: 'ADD',",
            "    message: message",
            "  }",
            "};",
            "",
            "const mapStateToProps = (state) => {",
            "  return {",
            "    messages: state",
            "  }",
            "};",
            "",
            "const mapDispatchToProps = (dispatch) => {",
            "  return {",
            "    submitNewMessage: (message) => {",
            "      dispatch(addMessage(message));",
            "    }",
            "  }",
            "};",
            "",
            "class Presentational extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  render() {",
            "    return <h3>This is a Presentational Component</h3>",
            "  }",
            "};",
            "",
            "const connect = ReactRedux.connect;",
            "// 请在本行以下添加你的代码",
            ""
          ],
          "tail": [
            "",
            "const store = Redux.createStore(",
            "  (state = '__INITIAL__STATE__', action) => state",
            ");",
            "class AppWrapper extends React.Component {",
            "  render() {",
            "    return (",
            "      <ReactRedux.Provider store = {store}>",
            "        <ConnectedComponent/>",
            "      </ReactRedux.Provider>",
            "    );",
            "  }",
            "};",
            "ReactDOM.render(<AppWrapper />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "应渲染<code>Presentational</code>组件。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); return mockedComponent.find('Presentational').length === 1; })(), '应渲染<code>Presentational</code>组件。');"
        },
        {
          "text": "<code>Presentational</code>组件应通过<code>connect</code>接收一个<code>messages</code>属性。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); const props = mockedComponent.find('Presentational').props(); return props.messages === '__INITIAL__STATE__'; })(), '<code>Presentational</code>组件应通过<code>connect</code>接收一个<code>messages</code>属性。');"
        },
        {
          "text": "<code>Presentational</code>组件应通过<code>connect</code>接收一个<code>submitNewMessage</code>属性。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); const props = mockedComponent.find('Presentational').props(); return typeof props.submitNewMessage === 'function'; })(), '<code>Presentational</code>组件应通过<code>connect</code>接收一个<code>submitNewMessage</code>属性。');"
        }
      ],
      "solutions": [
        "const addMessage = (message) => {\n  return {\n    type: 'ADD',\n    message: message\n  }\n};\n\nconst mapStateToProps = (state) => {\n  return {\n    messages: state\n  }\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    submitNewMessage: (message) => {\n      dispatch(addMessage(message));\n    }\n  }\n};\n\nclass Presentational extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return <h3>This is a Presentational Component</h3>\n  }\n};\n\nconst connect = ReactRedux.connect;\n// change code below this line\n\nconst ConnectedComponent = connect(mapStateToProps, mapDispatchToProps)(Presentational); \n"
      ],
      "challengeType": 6,
      "isRequired": false,
      "reactRedux": true
    },
    {
      "id": "5a24c314108439a4d4036148",
      "title": "Connect Redux to the Messages App",
      "releasedOn": "December 25, 2017",
      "description": [
        "知道<code>connect</code>怎么实现 React 和 Redux 的连接后，我们可以在 React 组件中应用上面学到的内容。",
        "在上一课，连接到 Redux 的组件命名为<code>Presentational</code>，这个命名不是任意的，这样的术语通常是指未直接连接到 Redux 的 React 组件，他们只负责执行接收 props 的函数来实现 UI 的呈现。与上一挑战相比，本挑战需要把容器组件连接到 Redux。这些组件通常负责把 actions 分派给 store，且经常给子组件传入 store state 属性。",
        "<hr>",
        "到目前为止，我们的编辑器上已包含了整个章节的代码，唯一不同的是，React 组件被重新命名为<code>Presentational</code>，即展示层组件。创建一个新组件，保存在名为<code>Container</code>的常量中。这个常量用<code>connect</code>把<code>Presentational</code>组件和 Redux 连接起来。然后，在<code>AppWrapper</code>中渲染 React Redux 的<code>Provider</code>组件，给<code>Provider</code>传入 Redux<code>store</code>属性并渲染<code>Container</code>为子组件。完成这些，消息 app 应用会再次渲染页面。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "// Redux:",
            "const ADD = 'ADD';",
            "",
            "const addMessage = (message) => {",
            "  return {",
            "    type: ADD,",
            "    message: message",
            "  }",
            "};",
            "",
            "const messageReducer = (state = [], action) => {",
            "  switch (action.type) {",
            "    case ADD:",
            "      return [",
            "        ...state,",
            "        action.message",
            "      ];",
            "    default:",
            "      return state;",
            "  }",
            "};",
            "",
            "const store = Redux.createStore(messageReducer);",
            "",
            "// React:",
            "class Presentational extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      input: '',",
            "      messages: []",
            "    }",
            "    this.handleChange = this.handleChange.bind(this);",
            "    this.submitMessage = this.submitMessage.bind(this);",
            "  }",
            "  handleChange(event) {",
            "    this.setState({",
            "      input: event.target.value",
            "    });",
            "  }",
            "  submitMessage() {",
            "    const currentMessage = this.state.input;",
            "    this.setState({",
            "      input: '',",
            "      messages: this.state.messages.concat(currentMessage)",
            "    });",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h2>Type in a new Message:</h2>",
            "        <input",
            "          value={this.state.input}",
            "          onChange={this.handleChange}/><br/>",
            "        <button onClick={this.submitMessage}>Submit</button>",
            "        <ul>",
            "          {this.state.messages.map( (message, idx) => {",
            "              return (",
            "                 <li key={idx}>{message}</li>",
            "              )",
            "            })",
            "          }",
            "        </ul>",
            "      </div>",
            "    );",
            "  }",
            "};",
            "",
            "// React-Redux:",
            "const mapStateToProps = (state) => {",
            "  return { messages: state }",
            "};",
            "",
            "const mapDispatchToProps = (dispatch) => {",
            "  return {",
            "    submitNewMessage: (newMessage) => {",
            "       dispatch(addMessage(newMessage))",
            "    }",
            "  }",
            "};",
            "",
            "const Provider = ReactRedux.Provider;",
            "const connect = ReactRedux.connect;",
            "",
            "// 在此定义 Container 组件：",
            "",
            "",
            "class AppWrapper extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  render() {",
            "    // 完成返回声明：",
            "    return (null);",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<AppWrapper />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>AppWrapper</code>应渲染该页面。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); return mockedComponent.find('AppWrapper').length === 1; })(), '<code>AppWrapper</code>应渲染该页面。');"
        },
        {
          "text": "<code>Presentational</code>组件应渲染<code>h2</code>、<code>input</code>、<code>button</code>、<code>ul</code>四个元素。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); return mockedComponent.find('Presentational').length === 1; })(), '<code>Presentational</code>组件应渲染<code>h2</code>、<code>input</code>、<code>button</code>、<code>ul</code>四个元素。');"
        },
        {
          "text": "<code>Presentational</code>组件应渲染<code>h2</code>、<code>input</code>、<code>button</code>、<code>ul</code>四个元素。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); const PresentationalComponent = mockedComponent.find('Presentational'); return ( PresentationalComponent.find('div').length === 1 && PresentationalComponent.find('h2').length === 1 && PresentationalComponent.find('button').length === 1 && PresentationalComponent.find('ul').length === 1 ); })(), '<code>Presentational</code>组件应渲染<code>h2</code>、<code>input</code>、<code>button</code>、<code>ul</code>四个元素。');"
        },
        {
          "text": "<code>Presentational</code>组件应接收 Redux store 的<code>消息</code>属性。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); const PresentationalComponent = mockedComponent.find('Presentational'); const props = PresentationalComponent.props(); return Array.isArray(props.messages); })(), '<code>Presentational</code>组件应接收 Redux store 的<code>消息</code>属性。');"
        },
        {
          "text": "<code>Presentational</code>组件应接收创建 action 的函数<code>submitMessage</code>属性。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); const PresentationalComponent = mockedComponent.find('Presentational'); const props = PresentationalComponent.props(); return typeof props.submitNewMessage === 'function'; })(), '<code>Presentational</code>组件应接收创建 action 的函数<code>submitMessage</code>属性。');"
        }
      ],
      "solutions": [
        "// Redux:\nconst ADD = 'ADD';\n\nconst addMessage = (message) => {\n  return {\n    type: ADD,\n    message: message\n  }\n};\n\nconst messageReducer = (state = [], action) => {\n  switch (action.type) {\n    case ADD:\n      return [\n        ...state,\n        action.message\n      ];\n    default:\n      return state;\n  }\n};\n\nconst store = Redux.createStore(messageReducer);\n\n// React:\nclass Presentational extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      input: '',\n      messages: []\n    }\n this.handleChange = this.handleChange.bind(this); \n this.submitMessage = this.submitMessage.bind(this); \n  }\n  handleChange(event) {\n    this.setState({\n      input: event.target.value\n    });\n  }\n  submitMessage() {\n    const currentMessage = this.state.input;\n    this.setState({\n      input: '',\n      messages: this.state.messages.concat(currentMessage)\n    });\n  }\n  render() {\n    return (\n      <div>\n        <h2>Type in a new Message:</h2>\n        <input\n          value={this.state.input}\n          onChange={this.handleChange}/><br/>\n        <button onClick={this.submitMessage}>Submit</button>\n        <ul>\n          {this.state.messages.map( (message, idx) => {\n              return (\n                 <li key={idx}>{message}</li>\n              )\n            })\n          }\n        </ul>\n      </div>\n    );\n  }\n};\n\n// React-Redux:\nconst mapStateToProps = (state) => {\n  return { messages: state }\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    submitNewMessage: (newMessage) => {\n       dispatch(addMessage(newMessage))\n    }\n  }\n};\n\nconst Provider = ReactRedux.Provider;\nconst connect = ReactRedux.connect;\n\n// define the Container component here:\nconst Container = connect(mapStateToProps, mapDispatchToProps)(Presentational);\n\nclass AppWrapper extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    // complete the return statement:\n    return (\n      <Provider store={store}>\n        <Container/>\n      </Provider>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "reactRedux": true
    },
    {
      "id": "5a24c314108439a4d4036149",
      "title": "Extract Local State into Redux",
      "releasedOn": "December 25, 2017",
      "description": [
        "胜利就在眼前了！请回顾一下为管理 React messages app 的状态写的 Redux 代码。现在有了连接好的 Redux，你还要从<code>Presentational</code>组件中提取状态管理到 Redux，在<code>Presentational</code>组件内处理本地状态。",
        "<hr>",
        "在<code>Presentational</code>组件中，先删除本地<code>state</code>中的<code>messages</code>属性，被删的 messages 将由 Redux 管理。接着，修改<code>submitMessage()</code>方法，使该方法从<code>this.props</code>那里分发<code>submitNewMessage()</code>；从本地<code>state</code>中传入当前消息输入作为参数。因本地状态删除了<code>messages</code>属性，所以在调用<code>this.setState()</code>时也要删除该属性。最后，修改<code>render()</code>方法，使其所映射的消息是从<code>props</code>接收的，而不是<code>state</code>",
        "完成这些更改后，我们的应用会实现 Redux 管理应用的状态，但它继续运行着相同的功能。此示例还阐明了组件获得本地状态的方式，即在自己的状态中继续跟踪用户本地输入。由此可见，Redux 为 React 提供了很有用的状态管理框架。先前，你仅使用 React 的本地状态也实现了相同的结果，这在应付简单的应用时通常是可行的。但是，随着应用变得越来越大，越来越复杂，应用的状态管理也变得非常困难，Redux 就是为解决这样的问题而诞生的。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "// Redux:",
            "const ADD = 'ADD';",
            "",
            "const addMessage = (message) => {",
            "  return {",
            "    type: ADD,",
            "    message: message",
            "  }",
            "};",
            "",
            "const messageReducer = (state = [], action) => {",
            "  switch (action.type) {",
            "    case ADD:",
            "      return [",
            "        ...state,",
            "        action.message",
            "      ];",
            "    default:",
            "      return state;",
            "  }",
            "};",
            "",
            "const store = Redux.createStore(messageReducer);",
            "",
            "// React:",
            "const Provider = ReactRedux.Provider;",
            "const connect = ReactRedux.connect;",
            "",
            "// 请在本行以下添加你的代码",
            "class Presentational extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      input: '',",
            "      messages: []",
            "    }",
            "    this.handleChange = this.handleChange.bind(this);",
            "    this.submitMessage = this.submitMessage.bind(this);",
            "  }",
            "  handleChange(event) {",
            "    this.setState({",
            "      input: event.target.value",
            "    });",
            "  }",
            "  submitMessage() {",
            "    this.setState({",
            "      input: '',",
            "      messages: this.state.messages.concat(this.state.input)",
            "    });",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h2>Type in a new Message:</h2>",
            "        <input",
            "          value={this.state.input}",
            "          onChange={this.handleChange}/><br/>",
            "        <button onClick={this.submitMessage}>Submit</button>",
            "        <ul>",
            "          {this.state.messages.map( (message, idx) => {",
            "              return (",
            "                 <li key={idx}>{message}</li>",
            "              )",
            "            })",
            "          }",
            "        </ul>",
            "      </div>",
            "    );",
            "  }",
            "};",
            "// 请在本行以上添加你的代码",
            "",
            "const mapStateToProps = (state) => {",
            "  return {messages: state}",
            "};",
            "",
            "const mapDispatchToProps = (dispatch) => {",
            "  return {",
            "    submitNewMessage: (message) => {",
            "      dispatch(addMessage(message))",
            "    }",
            "  }",
            "};",
            "",
            "const Container = connect(mapStateToProps, mapDispatchToProps)(Presentational);",
            "",
            "class AppWrapper extends React.Component {",
            "  render() {",
            "    return (",
            "      <Provider store={store}>",
            "        <Container/>",
            "      </Provider>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<AppWrapper />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>AppWrapper</code>应该渲染该页面。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); return mockedComponent.find('AppWrapper').length === 1; })(), '<code>AppWrapper</code>应该渲染该页面。');"
        },
        {
          "text": "<code>Presentational</code>组件应渲染<code>h2</code>、<code>input</code>、<code>button</code>、<code>ul</code>四个元素。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); return mockedComponent.find('Presentational').length === 1; })(), '<code>Presentational</code>组件应渲染<code>h2</code>、<code>input</code>、<code>button</code>、<code>ul</code>四个元素。');"
        },
        {
          "text": "<code>Presentational</code>组件应接收 Redux store 的<code>消息</code>属性。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); const PresentationalComponent = mockedComponent.find('Presentational'); const props = PresentationalComponent.props(); return Array.isArray(props.messages); })(), '<code>Presentational</code>组件应接收 Redux store 的<code>消息</code>属性。');"
        },
        {
          "text": "<code>Presentational</code>组件应接收创建 action 的函数<code>submitMessage</code>属性。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); const PresentationalComponent = mockedComponent.find('Presentational'); const props = PresentationalComponent.props(); return typeof props.submitNewMessage === 'function'; })(), '<code>Presentational</code>组件应接收创建 action 的函数<code>submitMessage</code>属性。');"
        },
        {
          "text": "<code>Presentational</code>组件的状态应包含一个初始化为空字符串的input属性。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); const PresentationalState = mockedComponent.find('Presentational').instance().state; return typeof PresentationalState.input === 'string' && Object.keys(PresentationalState).length === 1; })(), '<code>Presentational</code>组件的状态应包含一个初始化为空字符串的input属性。');"
        },
        {
          "text": "键入<code>input</code>元素应更新<code>Presentational</code>组件的状态。",
          "testString": "async () => { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); const testValue = '__MOCK__INPUT__'; const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 100)); const causeChange = (c, v) => c.find('input').simulate('change', { target: { value: v }}); let initialInput = mockedComponent.find('Presentational').find('input'); const changed = () => { causeChange(mockedComponent, testValue); return waitForIt(() => mockedComponent )}; const updated = await changed(); const updatedInput = updated.find('Presentational').find('input'); assert(initialInput.props().value === '' && updatedInput.props().value === '__MOCK__INPUT__', '键入<code>input</code>元素应更新<code>Presentational</code>组件的状态。'); }; "
        },
        {
          "text": "在<code>Presentational</code>组件上 dispatch <code>submitMessage</code>应更新 Redux store 并清除本地状态中的输入。",
          "testString": "async () => { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 100)); let beforeProps = mockedComponent.find('Presentational').props(); const testValue = '__TEST__EVENT__INPUT__'; const causeChange = (c, v) => c.find('input').simulate('change', { target: { value: v }}); const changed = () => { causeChange(mockedComponent, testValue); return waitForIt(() => mockedComponent )}; const clickButton = () => { mockedComponent.find('button').simulate('click'); return waitForIt(() => mockedComponent )}; const afterChange = await changed(); const afterChangeInput = afterChange.find('input').props().value; const afterClick = await clickButton(); const afterProps = mockedComponent.find('Presentational').props(); assert(beforeProps.messages.length === 0 && afterChangeInput === testValue && afterProps.messages.pop() === testValue && afterClick.find('input').props().value === '', '在<code>Presentational</code>组件上 dispatch <code>submitMessage</code>应更新 Redux store 并清除本地状态中的输入。'); }; "
        },
        {
          "text": "<code>Presentational</code>组件应渲染 Redux store 中的<code>messages</code>",
          "testString": "async () => { const mockedComponent = Enzyme.mount(React.createElement(AppWrapper)); const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 100)); let beforeProps = mockedComponent.find('Presentational').props(); const testValue = '__TEST__EVENT__INPUT__'; const causeChange = (c, v) => c.find('input').simulate('change', { target: { value: v }}); const changed = () => { causeChange(mockedComponent, testValue); return waitForIt(() => mockedComponent )}; const clickButton = () => { mockedComponent.find('button').simulate('click'); return waitForIt(() => mockedComponent )}; const afterChange = await changed(); const afterChangeInput = afterChange.find('input').props().value; const afterClick = await clickButton(); const afterProps = mockedComponent.find('Presentational').props(); assert(beforeProps.messages.length === 0 && afterChangeInput === testValue && afterProps.messages.pop() === testValue && afterClick.find('input').props().value === '' && afterClick.find('ul').childAt(0).text() === testValue, '<code>Presentational</code>组件应渲染 Redux store 中的<code>messages</code>'); }; "
        }
      ],
      "solutions": [
        "// Redux:\nconst ADD = 'ADD';\n\nconst addMessage = (message) => {\n  return {\n    type: ADD,\n    message: message\n  }\n};\n\nconst messageReducer = (state = [], action) => {\n  switch (action.type) {\n    case ADD:\n      return [\n        ...state,\n        action.message\n      ];\n    default:\n      return state;\n  }\n};\n\nconst store = Redux.createStore(messageReducer);\n\n// React:\nconst Provider = ReactRedux.Provider;\nconst connect = ReactRedux.connect;\n\n// Change code below this line\nclass Presentational extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      input: ''\n    }\n this.handleChange = this.handleChange.bind(this); \n this.submitMessage = this.submitMessage.bind(this); \n  }\n  handleChange(event) {\n    this.setState({\n      input: event.target.value\n    });\n  }\n  submitMessage() {\n    this.props.submitNewMessage(this.state.input);\n    this.setState({\n      input: ''\n    });\n  }\n  render() {\n    return (\n      <div>\n        <h2>Type in a new Message:</h2>\n        <input\n          value={this.state.input}\n          onChange={this.handleChange}/><br/>\n        <button onClick={this.submitMessage}>Submit</button>\n        <ul>\n          {this.props.messages.map( (message, idx) => {\n              return (\n                 <li key={idx}>{message}</li>\n              )\n            })\n          }\n        </ul>\n      </div>\n    );\n  }\n};\n// Change code above this line\n\nconst mapStateToProps = (state) => {\n  return {messages: state}\n};\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    submitNewMessage: (message) => {\n      dispatch(addMessage(message))\n    }\n  }\n};\n\nconst Container = connect(mapStateToProps, mapDispatchToProps)(Presentational);\n\nclass AppWrapper extends React.Component {\n  render() {\n    return (\n      <Provider store={store}>\n        <Container/>\n      </Provider>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "reactRedux": true
    },
    {
      "id": "5a24c314108439a4d403614a",
      "title": "Moving Forward From Here",
      "releasedOn": "December 25, 2017",
      "description": [
        "恭喜你完成了 React 和 Redux 的所有课程！在继续前进前，还有一点值得我们注意。通常，我们不会在这样的编辑器中编写 React 应用代码。如果你在自己的计算机上使用 npm 和文件系统，这个挑战可让你一瞥 React 应用的语法之貌。除了使用<code>import</code>语句（这些语句引入了各挑战中提供的所有依赖关系），其代码看起来类似。“管理包（含 npm）”这一节更详细地介绍了 npm。",
        "最后，写 React 和 Redux 的代码通常需要一些配置，且很快会变得复杂起来。如果你想在自己的机器上尝试写代码，点击链接<a id='CRA' target ='_blank' href='https://github.com/facebookincubator/create-react-app'>创建 React App </a>可获取已配置好的现成代码。",
        "另一种做法是在 CodePen 中启用 Babel 作为 JavaScript 预处理器，将 React 和 ReactDOM 添加为外部 JavaScript 资源，在那里编写应用。",
        "<hr>",
        "把<code>'Now I know React and Redux!'</code>这一消息输出到控制台。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "// 从'react'导入 React",
            "// 从'react-dom'导入 ReactDOM",
            "// 从'react-redux'导入{ Provider, connect }",
            "// 从'redux'导入{ createStore, combineReducers, applyMiddleware }",
            "// 从'redux-thunk'导入 thunk",
            "",
            "// 从'./redux/reducers'导入 rootReducer",
            "// 从'./components/App'导入 App",
            "",
            "// const store = createStore(",
            "//   rootReducer,",
            "//   applyMiddleware(thunk)",
            "// );",
            "",
            "// ReactDOM.render(",
            "//   <Provider store={store}>",
            "//     <App/>",
            "//   </Provider>,",
            "//   document.getElementById('root')",
            "// );",
            "",
            "// 请在本行以下添加你的代码",
            ""
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "<code>Now I know React and Redux!</code>这一消息应输出到控制台。",
          "testString": "assert(editor.getValue().includes('console.log(\"Now I know React and Redux!\")') || editor.getValue().includes('console.log(\\'Now I know React and Redux!\\')'), '<code>Now I know React and Redux!</code>这一消息应输出到控制台。');"
        }
      ],
      "solutions": [
        "console.log('Now I know React and Redux!');"
      ],
      "challengeType": 6,
      "isRequired": false,
      "reactRedux": true
    }
  ]
}
{
  "name": "Data Structures",
  "order": 2,
  "time": "",
  "helpRoom": "HelpJavaScript",
  "challenges": [
    {
      "id": "587d8253367417b2b2512c6a",
      "title": "Typed Arrays",
      "description": [
        "数组是一种 JavaScript 对象，它能存储各种数据类型的元素。",
        "<code>var complexArr = [1, 5, \"2\", \"Word\", {\"name\": \"James\"}];</code>",
        "通常浏览器会自动地为数组分配合适的内存空间，同时内存大小也会随着你增删元素而发生变化。",
        "然而，在一些对性能有较高要求以及存在不同数据类型的场景下，我们需要更精确地给数组分配内存空间。",
        "<dfn>Typed arrays</dfn>就是解决这类问题的一种方案。我们可以精确地给一个数组分配内存空间。下面的表格列出了这种数组能够存放的数据类型以及不同数据类型所占据的字节数。",
        "<table class='table table-striped'><tr><th>类型</th><th>元素所占字节数</th></tr><tr><td><code>Int8Array</code></td><td>1</td></tr><tr><td><code>Uint8Array</code></td><td>1</td></tr><tr><td><code>Uint8ClampedArray</code></td><td>1</td></tr><tr><td><code>Int16Array</code></td><td>2</td></tr><tr><td><code>Uint16Array</code></td><td>2</td></tr><tr><td><code>Int32Array</code></td><td>4</td></tr><tr><td><code>Uint32Array</code></td><td>4</td></tr><tr><td><code>Float32Array</code></td><td>4</td></tr><tr><td><code>Float64Array</code></td><td>8</td></tr></table>",
        "创建这类数组有两种方式，一种是直接创建，如下代码创建了一个长度为 3 的 <code>Int16Array</code>：",
        "<blockquote>var i8 = new Int16Array(3);<br>console.log(i8);<br>// 输出 [0, 0, 0]</blockquote>",
        "我们也可以通过创建<dfn>buffer</dfn>的方式来决定一个数组要容纳多少元素（以 bytes 为单位）。",
        "<strong>注意：</strong><br>使用<code>ArrayBuffer</code>创建<code>Typed array</code>时，我们需要传入一个表示<code>ArrayBuffer</code>大小的数字。由于其单位为字节，因此它必须是偶数：",
        "<blockquote>// 用另一种方式创建和上面相同的 Int16Array<br>var byteSize = 6; // 必须是 2 的倍数<br>var buffer = new ArrayBuffer(byteSize);<br>var i8View = new Int16Array(buffer);<br>buffer.byteLength; // 输出 6<br>i8View.byteLength; // 输出 6<br>console.log(i8View); // 输出 [0, 0, 0]</blockquote>",
        "<dfn>Buffers</dfn>是存放数据的通用对象，你无法直接访问它们。若要访问它们。你需要先创建一个 view。",
        "<blockquote>i8View[0] = 42;<br>console.log(i8View); // 输出 [42, 0, 0]</blockquote>",
        "<strong>注意：</strong><br>Typed Arrays 没有<code>.pop()</code>或<code>.push()</code>这些传统数组拥有的方法。使用<code>Array.isArray()</code>方法对 Typed Arrays 做判断返回的是<code>false</code>，而非<code>true</code>。因为 Typed Arrays 的接口相对简洁，因此对 JavaScript 引擎来说，实现这类数组会更加容易。",
        "<hr>",
        "请先创建一个 64 个字节的<code>buffer</code>，再创建一个类型是<code>Int32Array</code>名称叫做<code>i32View</code>的视图。"
      ],
      "tests": [
        {
          "text": "<code>buffer</code>应该有 64 个字节的大小。",
          "testString": "assert(buffer.byteLength === 64, '<code>buffer</code>应该有 64 个字节的大小。');"
        },
        {
          "text": "<code>i32View</code>视图应该有 64 个字节的大小。",
          "testString": "assert(i32View.byteLength === 64, '<code>i32View</code>视图应该有 64 个字节的大小。');"
        },
        {
          "text": "<code>i32View</code>视图应该能容纳 16 个元素。",
          "testString": "assert(i32View.length === 16, '<code>i32View</code>视图应该能容纳 16 个元素。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "var buffer = new ArrayBuffer(64);\nvar i32View = new Int32Array(buffer);"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var buffer;",
            "var i32View;"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8250367417b2b2512c5e",
      "title": "Learn how a Stack Works",
      "description": [
        "你肯定见过桌上摆着一摞书的场景；也应该使用过文本编辑器的撤销功能；同样，你肯定也点击过手机应用里面的返回键来回到上一个操作页面。",
        "这些场景有什么共同之处呢？他们都以一种特定的方式存储数据，让我们可以通过一些操作返回到之前的状态。",
        "最上层的书总是最后放上去的。如果我们拿走了最上面的书，我们看到的总是倒数第二本放上去的书。",
        "我们会发现上述例子都遵循 <dfn>Last-In-First-Out</dfn>（后进先出）的原则。接下来我们会尝试着用代码去实现这一原则。",
        "我们将这种类型的数据存储方式称为 <dfn>Stack</dfn>（栈）。需要特别注意的是我们通常使用<code>push()</code>方法将 JavaScript 对象压入栈中，同时使用<code>pop()</code>方法将 JavaScript 对象弹出栈。",
        "<hr>",
        "现在我们有一个存储着作业信息的栈（以数组表示）：<code>\"BIO12\"</code>位于栈底，而<code>\"PSY44\"</code>则处于栈顶。",
        "请使用上文提到的 JavaScript 方法来对这个数组做栈操作。你需要移除栈顶元素<code>\"PSY44\"</code>，然后再往栈顶添加<code>\"CS50\"</code>元素。"
      ],
      "tests": [
        {
          "text": "<code>homeworkStack</code>应该包含 4 个元素。",
          "testString": "assert(homeworkStack.length === 4, '<code>homeworkStack</code>应该包含 4 个元素。');"
        },
        {
          "text": "<code>homeworkStack</code>中最后一个元素应该是<code>\"CS50\"</code>。",
          "testString": "assert(homeworkStack[3] === 'CS50', '<code>homeworkStack</code>中最后一个元素应该是<code>\"CS50\"</code>。');"
        },
        {
          "text": "<code>homeworkStack</code>中不应存在<code>\"PSY44\"</code>元素。",
          "testString": "assert(homeworkStack.indexOf('PSY44') === -1, '<code>homeworkStack</code>中不应存在<code>\"PSY44\"</code>元素。');"
        },
        {
          "text": "不应更改<code>homeworkStack</code>的初始声明。",
          "testString": "assert(code.match(/=/g).length === 1 && /homeworkStack\\s*=\\s*\\[\"BIO12\"\\s*,\\s*\"HIS80\"\\s*,\\s*\"MAT122\"\\s*,\\s*\"PSY44\"\\]/.test(code), '不应更改<code>homeworkStack</code>的初始声明。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var homeworkStack = [\"BIO12\",\"HIS80\",\"MAT122\",\"PSY44\"];",
            "// 请把你的代码写在这条注释以下",
            ""
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8250367417b2b2512c5f",
      "title": "Create a Stack Class",
      "description": [
        "在上一节，我们讨论了什么是栈以及如何用数组来表示栈。在本节，我们将构造自己的栈。",
        "虽然我们可以使用数组来表示栈，但如果我们可以更完备地定义栈拥有的方法，就可以在开发中更好地使用它。",
        "除了<code>push</code>和<code>pop</code>两个方法，栈还应有一些其他方法。现在我们来给栈添加<code>peek</code>、<code>isEmpty</code>以及<code>clear</code>方法。",
        "挑战说明：",
        "请编写能够将元素压入栈顶的<code>push</code>方法、移除栈顶元素的<code>pop</code>方法、查看栈中第一个元素的<code>peek</code>方法、判断栈是否为空的<code>isEmpty</code>方法、以及清空栈内所有元素的<code>clear</code>方法。",
        "顺便，我们在右侧代码区为栈添加了一个<code>print</code>方法，该方法会打印出集合。不过一般来说，栈是没有这个方法的。"
      ],
      "tests": [
        {
          "text": "<code>Stack</code>应该有<code>push</code>方法。",
          "testString": "assert((function(){var test = new Stack(); return (typeof test.push === 'function')}()), '<code>Stack</code>应该有<code>push</code>方法。');"
        },
        {
          "text": "<code>Stack</code>应该有<code>pop</code>方法。",
          "testString": "assert((function(){var test = new Stack(); return (typeof test.pop === 'function')}()), '<code>Stack</code>应该有<code>pop</code>方法。');"
        },
        {
          "text": "<code>Stack</code>应该有<code>peek</code>方法。",
          "testString": "assert((function(){var test = new Stack(); return (typeof test.peek === 'function')}()), '<code>Stack</code>应该有<code>peek</code>方法。');"
        },
        {
          "text": "<code>Stack</code>应该有<code>isEmpty</code>方法。",
          "testString": "assert((function(){var test = new Stack(); return (typeof test.isEmpty === 'function')}()), '<code>Stack</code>应该有<code>isEmpty</code>方法。');"
        },
        {
          "text": "<code>Stack</code>应该有<code>clear</code>方法。",
          "testString": "assert((function(){var test = new Stack(); return (typeof test.clear === 'function')}()), '<code>Stack</code>应该有<code>clear</code>方法。');"
        },
        {
          "text": "<code>peek</code>方法应该返回栈顶元素。",
          "testString": "assert((function(){var test = new Stack();  test.push('CS50'); return (test.peek() === 'CS50')}()), '<code>peek</code>方法应该返回栈顶元素。');"
        },
        {
          "text": "<code>pop</code>方法应该移除栈顶元素并返回该元素。",
          "testString": "assert((function(){var test = new Stack(); test.push('CS50'); return (test.pop() === 'CS50');}()), '<code>pop</code>方法应该移除栈顶元素并返回该元素。');"
        },
        {
          "text": "当栈内没有元素时，<code>isEmpty</code>方法应该返回<code>true</code>。",
          "testString": "assert((function(){var test = new Stack(); return test.isEmpty()}()), '当栈内没有元素时，<code>isEmpty</code>方法应该返回<code>true</code>。');"
        },
        {
          "text": "<code>clear</code>应该移除栈内所有元素。",
          "testString": "assert((function(){var test = new Stack();  test.push('CS50'); test.clear(); return (test.isEmpty())}()), '<code>clear</code>应该移除栈内所有元素。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Stack() { ",
            "    var collection = [];",
            "    this.print = function() {",
            "        console.log(collection);",
            "    };",
            "    // 请把你的代码写在这条注释以下",
            "",
            "    // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8250367417b2b2512c60",
      "title": "Create a Queue Class",
      "description": [
        "如同栈一样，队列也是一系列元素的集合。但是与栈不同的是队列遵循 FIFO（First-In First-Out，先进先出）原则。新增元素会被添加进队列尾部，删除元素则是删除队列头部的元素。",
        "我们可以使用数组像创建栈那样来创建队列，同时我们也希望控制队列拥有哪些操作方法。",
        "<code>enqueue</code>和<code>dequeue</code>是队列中两个最主要的方法。<code>enqueue</code>方法将元素添加至队尾，而<code>dequeue</code>方法将队首元素移除并返回该元素。其它比较实用的方法有<code>front</code>、<code>size</code>和<code>isEmpty</code>等。",
        "挑战说明：",
        "请编写<code>enqueue</code>方法，该方法将新元素推入队尾；编写<code>dequeue</code>方法，该方法移除并返回队首元素；编写<code>front</code>方法，该方法返回队首元素；编写<code>size</code>方法，该方法返回队列长度；编写<code>isEmpty</code>方法，该方法判断队列是否为空。"
      ],
      "tests": [
        {
          "text": "<code>Queue</code>应该有<code>enqueue</code>方法。",
          "testString": "assert((function(){var test = new Queue();  return (typeof test.enqueue === 'function')}()), '<code>Queue</code>应该有<code>enqueue</code>方法。');"
        },
        {
          "text": "<code>Queue</code>应该有<code>dequeue</code>方法。",
          "testString": "assert((function(){var test = new Queue();  return (typeof test.dequeue === 'function')}()), '<code>Queue</code>应该有<code>dequeue</code>方法。');"
        },
        {
          "text": "<code>Queue</code>应该有<code>front</code>方法。",
          "testString": "assert((function(){var test = new Queue();  return (typeof test.front === 'function')}()), '<code>Queue</code>应该有<code>front</code>方法。');"
        },
        {
          "text": "<code>Queue</code>应该有<code>size</code>方法。",
          "testString": "assert((function(){var test = new Queue();  return (typeof test.size === 'function')}()), '<code>Queue</code>应该有<code>size</code>方法。');"
        },
        {
          "text": "<code>Queue</code>应该有<code>isEmpty</code>方法。",
          "testString": "assert((function(){var test = new Queue();  return (typeof test.isEmpty === 'function')}()), '<code>Queue</code>应该有<code>isEmpty</code>方法。');"
        },
        {
          "text": "<code>dequeue</code>方法应该移除并返回队首元素。",
          "testString": "assert((function(){var test = new Queue();  test.enqueue('Smith'); return (test.dequeue() === 'Smith')}()), '<code>dequeue</code>方法应该移除并返回队首元素。');"
        },
        {
          "text": "<code>front</code>方法应该返回队首元素。",
          "testString": "assert((function(){var test = new Queue();  test.enqueue('Smith'); test.enqueue('John'); return (test.front() === 'Smith')}()), '<code>front</code>方法应该返回队首元素。');"
        },
        {
          "text": "<code>size</code>方法应该返回队列长度。",
          "testString": "assert((function(){var test = new Queue();  test.enqueue('Smith'); return (test.size() === 1)}()), '<code>size</code>方法应该返回队列长度。');"
        },
        {
          "text": "当队列中有元素时，<code>isEmpty</code>方法应该返回<code>false</code>。",
          "testString": "assert((function(){var test = new Queue();  test.enqueue('Smith'); return !(test.isEmpty())}()), '当队列当中有元素时，<code>isEmpty</code>方法应该返回<code>false</code>。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Queue () { ",
            "    var collection = [];",
            "    this.print = function() {",
            "        console.log(collection);",
            "    };",
            "    // 请把你的代码写在这条注释以下",
            "",
            "    // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8255367417b2b2512c74",
      "title": "Create a Priority Queue Class",
      "description": [
        "在这次挑战中我们来创建 Priority Queue（优先队列）。优先队列是一种特殊的队列类型，这种队列中会有额外的信息来说明队列中元素的优先顺序，这种优先顺序可以用整数来表示，元素的优先级会直接影响元素的出队顺序。就算较高优先级的元素比较低优先级的元素后入队，在出队的时候，较高优先级的元素还是会先出队。",
        "举个例子，对于一个拥有 3 个元素的优先队列：",
        "<code>[['kitten', 2], ['dog', 2], ['rabbit', 2]]</code>",
        "元素中的第二个值（一个整数）代表这个元素的优先级，数字越小则优先级越高。如果我们让优先级为<code>1</code>的元素<code>['human', 1]</code>入队，那么这个元素在本优先队列中会第一个出队。添加该元素后，新的队列如下：",
        "<code>[['human', 1], ['kitten', 2], ['dog', 2], ['rabbit', 2]]</code>",
        "我们已经在右侧的代码编辑器中编写了<code>PriorityQueue</code>。你需要添加一个<code>enqueue</code>方法，使用该方法入队的元素都带有优先级；添加一个移除元素的<code>dequeue</code>方法；添加能够返回队列中元素总数的<code>size</code>方法；添加能够返回队列头部元素的<code>front</code>方法；添加<code>isEmpty</code>方法，当队列为空时<code>isEmpty</code>方法返回<code>true</code>，否则返回<code>false</code>。",
        "<code>enqueue</code>方法接收类似于<code>['human', 1]</code>的元素作为参数，其中数字<code>1</code>表示元素优先级。<code>dequeue</code>方法应该返回元素内容，无需返回它的优先级。"
      ],
      "tests": [
        {
          "text": "<code>Queue</code>应该有<code>enqueue</code>方法。",
          "testString": "assert((function(){var test = new PriorityQueue();  return (typeof test.enqueue === 'function')}()), '<code>Queue</code>应该有<code>enqueue</code>方法。');"
        },
        {
          "text": "<code>Queue</code>应该有<code>dequeue</code>方法。",
          "testString": "assert((function(){var test = new PriorityQueue();  return (typeof test.dequeue === 'function')}()), '<code>Queue</code>应该有<code>dequeue</code>方法。');"
        },
        {
          "text": "<code>Queue</code>应该有<code>size</code>方法。",
          "testString": "assert((function(){var test = new PriorityQueue();  return (typeof test.size === 'function')}()), '<code>Queue</code>应该有<code>size</code>方法。');"
        },
        {
          "text": "<code>Queue</code>应该有<code>isEmpty</code>方法。",
          "testString": "assert((function(){var test = new PriorityQueue();  return (typeof test.isEmpty === 'function')}()), '<code>Queue</code>应该有<code>isEmpty</code>方法。');"
        },
        {
          "text": "当元素出队和入队时，你的优先队列应该可以使用<code>size</code>方法实时获取队列中元素的数量。",
          "testString": "assert((function(){var test = new PriorityQueue(); test.enqueue(['David Brown', 2]); test.enqueue(['Jon Snow', 1]); var size1 = test.size(); test.dequeue(); var size2 = test.size(); test.enqueue(['A', 3]); test.enqueue(['B', 3]); test.enqueue(['C', 3]); return (size1 === 2 && size2 === 1 && test.size() === 4)}()), '当元素出队和入队时，你的优先队列应该可以使用<code>size</code>方法实时获取队列中元素的数量。');"
        },
        {
          "text": "当队列为空时，<code>isEmpty</code>方法应该返回<code>true</code>。",
          "testString": "assert((function(){var test = new PriorityQueue(); test.enqueue(['A', 1]); test.enqueue(['B', 1]); test.dequeue(); var first = test.isEmpty(); test.dequeue(); return (!first && test.isEmpty()); }()), '当队列为空时，<code>isEmpty</code>方法应该返回<code>true</code>。');"
        },
        {
          "text": "优先队列中高优先级的元素应该先于低优先级的元素出队，同一优先级的元素则遵循先进先出的原则。",
          "testString": "assert((function(){var test = new PriorityQueue(); test.enqueue(['A', 5]); test.enqueue(['B', 5]); test.enqueue(['C', 5]); test.enqueue(['D', 3]); test.enqueue(['E', 1]); test.enqueue(['F', 7]); var result = []; result.push(test.dequeue()); result.push(test.dequeue()); result.push(test.dequeue()); result.push(test.dequeue()); result.push(test.dequeue()); result.push(test.dequeue()); return result.join('') === 'EDABCF';}()), '优先队列中高优先级的元素应该先于低优先级的元素出队，同一优先级的元素则遵循先进先出的原则。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function PriorityQueue () { \n this.collection = []; \n this.printCollection = function(){ \n console.log(this.collection); \n }; \n this.size = function() { \n return this.collection.length; \n }; \n this.isEmpty = function() { \n return this.size() > 0 ? false : true; \n }; \n this.enqueue = function (newitem) {\n  if (this.isEmpty()) {\n    return this.collection.push(newitem);\n  }\n\n  this.collection = this.collection.reverse();\n  var found_index = this.collection.findIndex(function (item) {\n    return newitem[1] >= item[1];\n  });\n  if (found_index === -1) {\n    this.collection.push(newitem);\n  } else {\n    this.collection.splice(found_index, 0, newitem);\n  }\n  this.collection = this.collection.reverse();\n}; \n this.dequeue = function() { \n if (!this.isEmpty()) { \n return this.collection.shift()[0]; \n } else { \n return 'The queue is empty.' \n } \n }; \n }"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function PriorityQueue () {",
            "    this.collection = [];",
            "    this.printCollection = function() {",
            "      console.log(this.collection);",
            "    };",
            "    // 请把你的代码写在这条注释以下",
            "",
            "    // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8255367417b2b2512c75",
      "title": "Create a Circular Queue",
      "description": [
        "在本次挑战中我们来创建一个 Circular Queue（循环队列），与普通队列的不同之处在于循环队列的末尾是指向开头的。添加数据时，新元素还是会出现在末尾；但如果队列中的元素已经达到了尽头，则会把新元素添加到开头。这种数据结构在一些特定的场合会比较有用。比如流媒体服务，当队列满了以后新的媒体数据会从头部开始直接覆盖历史数据。",
        "下面我们用数组来举例说明循环队列的概念：",
        "<blockquote>[1, 2, 3, 4, 5]<br> ^Read @ 0<br> ^Write @ 0</blockquote>",
        "读和写两个操作都从<code>0</code>这个位置开始。现在队列添加了<code>a</code>、<code>b</code>和<code>c</code>3 个数据。新队列如下：",
        "<blockquote>[a, b, c, 4, 5]<br> ^Read @ 0<br>       ^Write @ 3</blockquote>",
        "读取数据时，我们可以选择移除或者保留数据：",
        "<blockquote>[null, null, null, 4, 5]<br>                   ^Read @ 3<br>                   ^Write @ 3</blockquote>",
        "一旦写入操作达队列末尾，就会从队列头开始继续写入数据：",
        "<blockquote>[f, null, null, d, e]<br>                ^Read @ 3<br> ^Write @ 1</blockquote>",
        "虽然这种数据结构有着固定的内存空间，但它可以用于处理占内存较大的文件。",
        "挑战说明：",
        "在本次挑战中我们来实现一个循环队列。该循环队列应该有<code>enqueue</code>和<code>dequeue</code>这两个方法，我们可以通过这两个方法从队列中读取和写入数据。这个类的构造器应该接收一个整数为参数，因为我们需要通过它来定义队列的长度。我们已经在右边的编辑器中为你写好了这个循环队列的初始版本。循环队列中存在两个指针（在这里，指针就是一个用于表示数组中元素位置的整数），分别是 read pointer（读指针）与 write pointer（写指针），它们分别用于表示数据的开始和结尾。在往循环队列中插入数据时，写指针需要向后移动一个位置，而如果写指针已经到达队列的末尾，则需要回到队列头部继续进行写入操作。类似地，在进行出队操作时，读指针也应该向后移动。写指针的位置不应越过读指针（我们的类当中不允许发生一个数据未经读取就已经被覆盖的情况发生），同时读指针也不应越过已经写入的数据。",
        "此外，<code>enqueue</code>方法应该返回成功入队的元素，否则需要返回<code>null</code>；类似地，<code>dequeue</code>方法应该返回成功出队的元素，否则需要返回<code>null</code>。"
      ],
      "tests": [
        {
          "text": "<code>enqueue</code>方法应该能够将元素添加进循环队列。",
          "testString": "assert((function(){ var test = new CircularQueue(3); test.enqueue(17); test.enqueue(32); test.enqueue(591); var print = test.print(); return print[0] === 17 && print[1] === 32 && print[2] === 591; })(), '<code>enqueue</code>方法应该能够将元素添加进循环队列。');"
        },
        {
          "text": "入队元素不能越过读指针。",
          "testString": "assert((function(){ var test = new CircularQueue(3); test.enqueue(17); test.enqueue(32); test.enqueue(591); test.enqueue(13); test.enqueue(25); test.enqueue(59); var print = test.print(); return print[0] === 17 && print[1] === 32 && print[2] === 591; })(), '入队元素不能越过读指针。');"
        },
        {
          "text": "<code>dequeue</code>方法应该能够让元素出队。",
          "testString": "assert((function(){ var test = new CircularQueue(3); test.enqueue(17); test.enqueue(32); test.enqueue(591); return test.dequeue() === 17 && test.dequeue() === 32 && test.dequeue() === 591; })(), '<code>dequeue</code>方法应该能够让元素出队。');"
        },
        {
          "text": "元素出队之后，该位置应该被设置为<code>null</code>。",
          "testString": "assert((function(){ var test = new CircularQueue(3); test.enqueue(17); test.enqueue(32); test.enqueue(672); test.dequeue(); test.dequeue(); var print = test.print(); return print[0] === null && print[1] === null && print[2] === 672; })(), '元素出队之后，该位置应该被设置为<code>null</code>。');"
        },
        {
          "text": "如果越过写指针让元素出队，则应返回<code>null</code>。在这之后，读指针的位置也不应越过写指针。",
          "testString": "assert((function(){ var test = new CircularQueue(3); test.enqueue(17); test.enqueue(32); test.enqueue(591); return test.dequeue() === 17 && test.dequeue() === 32 && test.dequeue() === 591 && test.dequeue() === null && test.dequeue() === null && test.dequeue() === null && test.dequeue() === null && test.enqueue(100) === 100 && test.dequeue() === 100; })(), '如果越过写指针让元素出队，则应返回<code>null</code>。在这之后，读指针的位置也不应越过写指针。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "class CircularQueue { \n constructor(size) { \n this.queue = []; \n this.read = 0; \n this.write = 0; \n this.max = size - 1; \n while (size > 0) { \n this.queue.push(null); \n size--; \n } \n } \n print() { \n return this.queue; \n } \n enqueue(item) { \n if (this.queue[this.write] === null) { \n this.queue[this.write] = item; \n if (this.write === this.max) { \n this.write = 0; \n } else { \n this.write++; \n } \n return item; \n } \n return null; \n } \n dequeue() { \n if (this.queue[this.read] !== null) { \n var item = this.queue[this.read]; \n this.queue[this.read] = null; \n if (this.read === this.max) { \n this.read = 0; \n } else { \n this.read++; \n } \n return item; \n } else { \n return null; \n } \n } \n }"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "class CircularQueue {",
            "   constructor(size) {",
            "",
            "     this.queue = [];",
            "     this.read = 0;",
            "     this.write = 0;",
            "     this.max = size - 1;",
            "",
            "     while (size > 0) {",
            "        this.queue.push(null);",
            "        size--;",
            "     }",
            "",
            "   }",
            "",
            "   print() {",
            "     return this.queue;",
            "   }",
            "",
            "",
            "   enqueue(item) {",
            "    // 请把你的代码写在这条注释以下",
            "",
            "    // 请把你的代码写在这条注释以上",
            "   }",
            "",
            "   dequeue() {",
            "    // 请把你的代码写在这条注释以下",
            "",
            "    // 请把你的代码写在这条注释以上",
            "   }",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "8d1323c8c441eddfaeb5bdef",
      "title": "Create a Set Class",
      "description": [
        "在接下来的几个章节里面我们会通过创建一个函数来模拟 \"Set\"（集合）数据结构。集合跟数组很类似，但是集合中元素具有唯一性。集合的典型应用是检查其中是否存在某个数据。在 JavaScript 中，我们可以通过对象实现，举例如下：",
        "<blockquote>var set = new Object();<br>set.foo = true;<br>// 检查 foo 是否存在：<br>console.log(set.foo) // 输出 true</blockquote>",
        "在接下来的几个练习中，我们会从零开始创建一个拥有完整功能的集合。",
        "在本次练习中，你需要创建一个<code>add</code>方法。它的作用是添加集合中不存的元素：",
        "<blockquote>this.add = function(element) {<br>  // 将元素添加进集合的代码<br>}</blockquote>",
        "如果元素成功添加进集合，<code>add</code>方法应返回<code>true</code>，否则应返回<code>false</code>。"
      ],
      "tests": [
        {
          "text": "<code>Set</code>应该有<code>add</code>方法。",
          "testString": "assert((function(){var test = new Set(); return (typeof test.add === 'function')}()), '<code>Set</code>应该有<code>add</code>方法。');"
        },
        {
          "text": "<code>add</code>方法不应添加重复值。",
          "testString": "assert((function(){var test = new Set(); test.add('a'); test.add('b'); test.add('a'); var vals = test.values(); return (vals[0] === 'a' && vals[1] === 'b' && vals.length === 2)}()), '<code>add</code>方法不应添加重复值。');"
        },
        {
          "text": "成功添加元素时，<code>add</code>方法应该返回<code>true</code>。",
          "testString": "assert((function(){var test = new Set(); var result = test.add('a'); return (result != undefined) && (result === true);}()), '成功添加元素时，<code>add</code>方法应该返回<code>true</code>。');"
        },
        {
          "text": "尝试添加重复元素时，<code>add</code>方法应该返回<code>false</code>。",
          "testString": "assert((function(){var test = new Set(); test.add('a'); var result = test.add('a'); return (result != undefined) && (result === false);}()), '尝试添加重复元素时，<code>add</code>方法应该返回<code>false</code>。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function Set() {var collection = []; this.has = function(e){return(collection.indexOf(e) !== -1);};this.values = function() {return collection;};this.add = function(element) {if (!this.has(element)) {collection.push(element);return true;} else {return false;}};}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Set() {",
            "    // collection 变量用来存储集合中的元素",
            "    var collection = [];",
            "    // 当集合中存在 element 元素时返回 true 否则返回 false",
            "    this.has = function(element) {",
            "        return (collection.indexOf(element) !== -1);",
            "    };",
            "    // 该方法会返回集合内所有元素",
            "    this.values = function() {",
            "        return collection;",
            "    };",
            "    // 请把你的代码写在这条注释以下",
            "    // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8253367417b2b2512c6b",
      "title": "Remove from a Set",
      "description": [
        "在本次练习当中我们来为集合创建一个删除方法，该方法命名为<code>this.remove</code>。它接收一个值并判断该值在集合中是否存在，如何存在就从集合中移除该元素并返回<code>true</code>，否则返回<code>false</code>。"
      ],
      "tests": [
        {
          "text": "<code>Set</code>应该有<code>remove</code>方法。",
          "testString": "assert((function(){var test = new Set(); return (typeof test.remove === 'function')}()), '<code>Set</code>应该有<code>remove</code>方法。');"
        },
        {
          "text": "<code>remove</code>方法应该只移除集合中存在的元素。",
          "testString": "assert.deepEqual((function(){var test = new Set(); test.add('a');test.add('b');test.remove('c'); return test.values(); })(), ['a', 'b'], '<code>remove</code>方法应该只移除集合中存在的元素。');"
        },
        {
          "text": "<code>remove</code>方法应该移除集合中的指定元素。",
          "testString": "assert((function(){var test = new Set(); test.add('a');test.add('b');test.remove('a'); var vals = test.values(); return (vals[0] === 'b' && vals.length === 1)}()), '<code>remove</code>方法应该移除集合中的指定元素。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function Set() {var collection = []; this.has = function(e){return(collection.indexOf(e) !== -1);};this.values = function() {return collection;};this.add = function(element) {if (!this.has(element)) {collection.push(element);return true;} else {return false;}};this.remove = function(element) {if(this.has(element)) {var i = collection.indexOf(element);collection.splice(i, 1);return true;}return false;};}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Set() {",
            "    // collection 变量用来存储集合中的元素",
            "    var collection = [];",
            "    // 当集合中存在 element 元素时返回 true 否则返回 false ",
            "    this.has = function(element) {",
            "        return (collection.indexOf(element) !== -1);",
            "    };",
            "    // 该方法会返回集合内所有元素",
            "    this.values = function() {",
            "        return collection;",
            "    };",
            "    // 该方法会把 element 添加到集合中",
            "    this.add = function(element) {",
            "        if(!this.has(element)){",
            "            collection.push(element);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 请把你的代码写在这条注释以下",
            "    // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "8d1923c8c441eddfaeb5bdef",
      "title": "Size of the Set",
      "description": [
        "在本次练习中，我们需要为集合创建一个<code>size</code>方法，该方法名为<code>this.size</code>，调用该方法时会返回集合的长度。"
      ],
      "tests": [
        {
          "text": "<code>Set</code>应该有<code>size</code>方法。",
          "testString": "assert((function(){var test = new Set(); return (typeof test.size === 'function')}()), '<code>Set</code>应该有<code>size</code>方法。');"
        },
        {
          "text": "<code>size</code>应该返回集合中元素的个数。",
          "testString": "assert((function(){var test = new Set(); test.add('a');test.add('b');test.remove('a');return (test.size() === 1)}()), '<code>size</code>应该返回集合中元素的个数。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function Set() {var collection = []; this.has = function(e){return(collection.indexOf(e) !== -1);};this.values = function() {return collection;};this.add = function(element) {if (!this.has(element)) {collection.push(element);return true;} else {return false;}};this.remove = function(element) {if(this.has(element)) {var i = collection.indexOf(element);collection.splice(i, 1);return true;}return false;};this.size = function() {return collection.length;};}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Set() {",
            "    // collection 变量用来存储集合中的元素",
            "    var collection = [];",
            "    // 当集合中存在 element 元素时返回 true 否则返回 false ",
            "    this.has = function(element) {",
            "        return (collection.indexOf(element) !== -1);",
            "    };",
            "    // 该方法会返回集合内所有元素",
            "    this.values = function() {",
            "        return collection;",
            "    };",
            "    // 该方法会把 element 添加到集合中",
            "    this.add = function(element) {",
            "        if(!this.has(element)){",
            "            collection.push(element);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 该方法用于从集合中移除 element 元素",
            "    this.remove = function(element) {",
            "        if(this.has(element)){",
            "           var index = collection.indexOf(element);",
            "            collection.splice(index,1);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 请把你的代码写在这条注释以下",
            "    // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8253367417b2b2512c6c",
      "title": "Perform a Union on Two Sets",
      "description": [
        "在本次练习中，我们来写一个合并两个集合中元素的方法。我们需要在<code>Set</code>数据结构中创建<code>union</code>方法，该方法接收另一个<code>Set</code>为参数并返回两个集合中，非重复元素的合集。",
        "举个例子，集合<code>setA = ['a','b','c']</code>和集合<code>setB = ['a','b','d','e']</code>合并之后的集合为：<code>setA.union(setB) = ['a', 'b', 'c', 'd', 'e']</code>。"
      ],
      "tests": [
        {
          "text": "<code>Set</code>应该有<code>union</code>方法。",
          "testString": "assert((function(){var test = new Set(); return (typeof test.union === 'function')})(), '<code>Set</code>应该有<code>union</code>方法。');"
        },
        {
          "text": "<code>union</code>方法应返回正确的集合结果。",
          "testString": "assert((function(){var setA = new Set();  var setB = new Set();  setA.add('a');  setA.add('b');  setA.add('c');  setB.add('c');  setB.add('d');  var unionSetAB = setA.union(setB); var final = unionSetAB.values(); return (final.indexOf('a') !== -1 && final.indexOf('b') !== -1 && final.indexOf('c') !== -1 && final.indexOf('d') !== -1 && final.length === 4)})(), '<code>union</code>方法应返回正确的集合结果。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function Set() {var collection = []; this.has = function(e){return(collection.indexOf(e) !== -1);};this.values = function() {return collection;};this.add = function(element) {if (!this.has(element)) {collection.push(element);return true;} else {return false;}};this.remove = function(element) {if(this.has(element)) {var i = collection.indexOf(element);collection.splice(i, 1);return true;}return false;};this.size = function() {return collection.length;};this.union = function(set) {var u = new Set();var c = this.values();var s = set.values();c.forEach(function(element){u.add(element);});s.forEach(function(element){u.add(element);});return u;};}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Set() {",
            "    // collection 变量用来存储集合中的元素",
            "    var collection = [];",
            "    // 当集合中存在 element 元素时返回 true 否则返回 false",
            "    this.has = function(element) {",
            "        return (collection.indexOf(element) !== -1);",
            "    };",
            "    // 该方法会返回集合内所有元素",
            "    this.values = function() {",
            "        return collection;",
            "    };",
            "    // 该方法会把 element 添加到集合中",
            "    this.add = function(element) {",
            "        if(!this.has(element)){",
            "            collection.push(element);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 该方法用于从集合中移除 element 元素",
            "    this.remove = function(element) {",
            "        if(this.has(element)){",
            "           var index = collection.indexOf(element);",
            "            collection.splice(index,1);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 该方法返回集合长度",
            "    this.size = function() {",
            "        return collection.length;",
            "    };",
            "    // 请把你的代码写在这条注释以下",
            "",
            "    // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8253367417b2b2512c6d",
      "title": "Perform an Intersection on Two Sets of Data",
      "description": [
        "在本次练习当中，我们需要在<code>Set</code>数据结构中写一个用于计算两集合交集的方法<code>intersection</code>。交集的意思是是两个或者多个集合共同拥有的元素组成的集合。该方法应该接收<code>Set</code>为参数并返回两个集合的交集。",
        "举个例子，集合<code>setA = ['a','b','c']</code>和集合<code>setB = ['a','b','d','e']</code>的交集计算结果为：<code>setA.intersection(setB) = ['a', 'b']</code>。"
      ],
      "tests": [
        {
          "text": "<code>Set</code>应该有<code>intersection</code>方法。",
          "testString": "assert(function(){var test = new Set(); return (typeof test.intersection === 'function')}, '<code>Set</code>应该有<code>intersection</code>方法。');"
        },
        {
          "text": "<code>intersection</code>方法应返回正确的集合结果。",
          "testString": "assert(function(){  var setA = new Set();  var setB = new Set();  setA.add('a');  setA.add('b');  setA.add('c');  setB.add('c');  setB.add('d');  var intersectionSetAB = setA.intersection(setB); return (intersectionSetAB.size() === 1 && intersectionSetAB.values()[0] === 'c')}, '<code>intersection</code>方法应返回正确的集合结果。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function Set() {var collection = []; this.has = function(e){return(collection.indexOf(e) !== -1);};this.values = function() {return collection;};this.add = function(element) {if (!this.has(element)) {collection.push(element);return true;} else {return false;}};this.remove = function(element) {if(this.has(element)) {var i = collection.indexOf(element);collection.splice(i, 1);return true;}return false;};this.size = function() {return collection.length;};this.union = function(set) {var u = new Set();var c = this.values();var s = set.values();c.forEach(function(element){u.add(element);});s.forEach(function(element){u.add(element);});return u;};this.intersection = function(set) {var i = new Set();var c = this.values();c.forEach(function(element){if(s.has(element)) i.add(element);});};}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Set() {",
            "    // collection 变量用来存储集合中的元素",
            "    var collection = [];",
            "    // 当集合中存在 element 元素时返回 true 否则返回 false",
            "    this.has = function(element) {",
            "        return (collection.indexOf(element) !== -1);",
            "    };",
            "    // 该方法会返回集合内所有元素",
            "    this.values = function() {",
            "        return collection;",
            "    };",
            "    // 该方法会把 element 添加到集合中",
            "    this.add = function(element) {",
            "        if(!this.has(element)){",
            "            collection.push(element);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 该方法用于从集合中移除 element 元素",
            "    this.remove = function(element) {",
            "        if(this.has(element)){",
            "           var index = collection.indexOf(element);",
            "            collection.splice(index,1);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 该方法返回集合长度",
            "    this.size = function() {",
            "        return collection.length;",
            "    };",
            "    // 该方法返回两个集合的交集",
            "    this.union = function(otherSet) {",
            "        var unionSet = new Set();",
            "        var firstSet = this.values();",
            "        var secondSet = otherSet.values();",
            "        firstSet.forEach(function(e){",
            "            unionSet.add(e);",
            "        });",
            "        secondSet.forEach(function(e){",
            "            unionSet.add(e);",
            "        });",
            "        return unionSet;",
            "    };",
            "    // 请把你的代码写在这条注释以下",
            "    // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8254367417b2b2512c6e",
      "title": "Perform a Difference on Two Sets of Data",
      "description": [
        "在本次练习中，我们需要在<code>Set</code>数据结构中创建一个计算两集合差集的<code>difference</code>方法。两个集合差集的概念为：由第一个集合中存在且第二个集合中不存在的元素组成的集合。该方法应该接收另一个<code>Set</code>作为参数并且返回两个集合的差集。",
        "举个例子，集合<code>setA = ['a','b','c']</code>与<code>setB = ['a','b','d','e']</code>的差集比较结果为：<code>setA.difference(setB) = ['c']</code>。"
      ],
      "tests": [
        {
          "text": "<code>Set</code>应该有<code>difference</code>方法。",
          "testString": "assert(function(){var test = new Set(); return (typeof test.difference === 'function')}, '<code>Set</code>应该有<code>difference</code>方法。');"
        },
        {
          "text": "<code>difference</code>方法应返回正确的集合结果。",
          "testString": "assert(function(){var setA = new Set(); var setB = new Set(); setA.add('a'); setA.add('b'); setA.add('c'); setB.add('c'); setB.add('d'); var differenceSetAB = setA.difference(setB); return (differenceSetAB.size() === 2) && (differenceSetAB.values() === [ 'a', 'b' ])}, '<code>difference</code>方法应返回正确的集合结果。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function Set() {var collection = []; this.has = function(e){return(collection.indexOf(e) !== -1);};this.values = function() {return collection;};this.add = function(element) {if (!this.has(element)) {collection.push(element);return true;} else {return false;}};this.remove = function(element) {if(this.has(element)) {var i = collection.indexOf(element);collection.splice(i, 1);return true;}return false;};this.size = function() {return collection.length;};this.union = function(set) {var u = new Set();var c = this.values();var s = set.values();c.forEach(function(element){u.add(element);});s.forEach(function(element){u.add(element);});return u;};this.intersection = function(set) {var i = new Set();var c = this.values();c.forEach(function(element){if(s.has(element)) i.add(element);});};this.difference = function(set) {var d = new Set();var c = this.values();c.forEach(function(e){if(!set.has(e)) d.add(e);});};}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Set() {",
            "    // collection 变量用来存储集合中的元素",
            "    var collection = [];",
            "    // 当集合中存在 element 元素时返回 true 否则返回 false",
            "    this.has = function(element) {",
            "        return (collection.indexOf(element) !== -1);",
            "    };",
            "    // 该方法会返回集合内所有元素",
            "    this.values = function() {",
            "        return collection;",
            "    };",
            "    // 该方法会把 element 添加到集合中",
            "    this.add = function(element) {",
            "        if(!this.has(element)){",
            "            collection.push(element);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 该方法用于从集合中移除 element 元素",
            "    this.remove = function(element) {",
            "        if(this.has(element)){",
            "           var index = collection.indexOf(element);",
            "            collection.splice(index,1);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 该方法返回集合长度",
            "    this.size = function() {",
            "        return collection.length;",
            "    };",
            "    // 该方法会返回两个集合的交集",
            "    this.union = function(otherSet) {",
            "        var unionSet = new Set();",
            "        var firstSet = this.values();",
            "        var secondSet = otherSet.values();",
            "        firstSet.forEach(function(e){",
            "            unionSet.add(e);",
            "        });",
            "        secondSet.forEach(function(e){",
            "            unionSet.add(e);",
            "        });",
            "        return unionSet;",
            "    };",
            "    // 该方法会返回两个集合的差集",
            "    this.intersection = function(otherSet) {",
            "        var intersectionSet = new Set();",
            "        var firstSet = this.values();",
            "        firstSet.forEach(function(e){",
            "            if(otherSet.has(e)){",
            "                intersectionSet.add(e);",
            "            }",
            "        });",
            "        return intersectionSet;",
            "    };",
            "    // 请把你的代码写在这条注释以下",
            "    // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8254367417b2b2512c6f",
      "title": "Perform a Subset Check on Two Sets of Data",
      "description": [
        "在本次练习中我们将对两个集合元素做子集测试。我们会为<code>Set</code>数据结构创建<code>subset</code>方法。第一个集合会与第二个集合做对比，如果第二个集合完全包含第一个集合内的所有元素，则该方法返回 true 。",
        "举个例子，假设有集合<code>setA = ['a','b']</code>与<code>setB = ['a','b','c','d']</code>，那么<code>setA.subset(setB)</code>的运算结果应该为<code>true</code>。"
      ],
      "tests": [
        {
          "text": "<code>Set</code>应该有<code>union</code>方法。",
          "testString": "assert(function(){var test = new Set(); return (typeof test.subset === 'function')}, '<code>Set</code>应该有<code>union</code>方法。');"
        },
        {
          "text": "如果第二个集合完全包含第一个集合，则<code>union</code>方法应返回<code>true</code>。",
          "testString": "assert(function(){var setA = new Set(); var setB = new Set(); setA.add('a'); setB.add('b'); setB.add('c'); setB.add('a'); setB.add('d'); var subsetSetAB = setA.subset(setB);return (subsetSetAB === true)}, '如果第二个集合完全包含第一个集合，则<code>union</code>方法应返回<code>true</code>。');"
        },
        {
          "text": "<code>['a', 'b'].subset(['a', 'b', 'c', 'd'])</code>应返回<code>true</code>。",
          "testString": "assert(function(){var setA = new Set(); var setB = new Set(); setA.add('a'); setA.add('b'); setB.add('a'); setB.add('b'); setB.add('c'); setB.add('d'); var subsetSetAB = setA.subset(setB); return (subsetSetAB === true)}, \"<code>['a', 'b'].subset(['a', 'b', 'c', 'd'])</code>应返回<code>true</code>。\");"
        },
        {
          "text": "<code>['a', 'b', 'c'].subset(['a', 'b'])</code>应返回<code>false</code>。",
          "testString": "assert(function(){var setA = new Set(); var setB = new Set(); setA.add('a'); setA.add('b'); setA.add('c'); setB.add('a'); setB.add('b'); var subsetSetAB = setA.subset(setB); return (subsetSetAB === false)}, \"<code>['a', 'b', 'c'].subset(['a', 'b'])</code>应返回<code>false</code>。\");"
        },
        {
          "text": "<code>[].subset([])</code>应该返回<code>true</code>。",
          "testString": "assert(function(){var setA = new Set(); var setB = new Set(); var subsetSetAB = setA.subset(setB); return (subsetSetAB === true)}, '<code>[].subset([])</code>应该返回<code>true</code>。');"
        },
        {
          "text": "<code>['a', 'b'].subset(['c', 'd'])</code>应返回<code>false</code>。",
          "testString": "assert(function(){var setA = new Set(); var setB = new Set(); setA.add('a'); setA.add('b'); setB.add('c'); setB.add('d'); var subsetSetAB = setA.subset(setB); return (subsetSetAB === false)}, \"<code>['a', 'b'].subset(['c', 'd'])</code>应返回<code>false</code>。\");"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function Set() {var collection = []; this.has = function(e){return(collection.indexOf(e) !== -1);};this.values = function() {return collection;};this.add = function(element) {if (!this.has(element)) {collection.push(element);return true;} else {return false;}};this.remove = function(element) {if(this.has(element)) {var i = collection.indexOf(element);collection.splice(i, 1);return true;}return false;};this.size = function() {return collection.length;};this.union = function(set) {var u = new Set();var c = this.values();var s = set.values();c.forEach(function(element){u.add(element);});s.forEach(function(element){u.add(element);});return u;};this.intersection = function(set) {var i = new Set();var c = this.values();c.forEach(function(element){if(s.has(element)) i.add(element);});};this.difference = function(set) {var d = new Set();var c = this.values();c.forEach(function(e){if(!set.has(e)) d.add(e);});};this.subset = function(set) {var isSubset = true;var c = this.values();c.forEach(function(e){if(!set.has(e)) isSubset = false;});return isSubset;};}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function Set() {",
            "    // collection 变量用来存储集合中的元素",
            "    var collection = [];",
            "    // 当集合中存在 element 元素时返回 true 否则返回 false",
            "    this.has = function(element) {",
            "        return (collection.indexOf(element) !== -1);",
            "    };",
            "    // 该方法会返回集合内所有元素",
            "    this.values = function() {",
            "        return collection;",
            "    };",
            "    // 该方法会把 element 添加到集合中",
            "    this.add = function(element) {",
            "        if(!this.has(element)){",
            "            collection.push(element);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 该方法用于从集合中移除 element 元素",
            "    this.remove = function(element) {",
            "        if(this.has(element)){",
            "           var index = collection.indexOf(element);",
            "            collection.splice(index,1);",
            "            return true;",
            "        }",
            "        return false;",
            "    };",
            "    // 该方法返回集合长度",
            "    this.size = function() {",
            "        return collection.length;",
            "    };",
            "    // 该方法会返回两个集合的交集",
            "    this.union = function(otherSet) {",
            "        var unionSet = new Set();",
            "        var firstSet = this.values();",
            "        var secondSet = otherSet.values();",
            "        firstSet.forEach(function(e){",
            "            unionSet.add(e);",
            "        });",
            "        secondSet.forEach(function(e){",
            "            unionSet.add(e);",
            "        });",
            "        return unionSet;",
            "    };",
            "    // 该方法会返回两个集合的交集",
            "    this.intersection = function(otherSet) {",
            "        var intersectionSet = new Set();",
            "        var firstSet = this.values();",
            "        firstSet.forEach(function(e){",
            "            if(otherSet.has(e)){",
            "                intersectionSet.add(e);",
            "            }",
            "        });",
            "        return intersectionSet;",
            "    };",
            "    // 该方法会返回两个集合的差集",
            "    this.difference = function(otherSet) {",
            "        var differenceSet = new Set();",
            "        var firstSet = this.values();",
            "        firstSet.forEach(function(e){",
            "            if(!otherSet.has(e)){",
            "                differenceSet.add(e);",
            "            }",
            "        });",
            "        return differenceSet;",
            "    };",
            "    // 请把你的代码写在这条注释以下",
            "    // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8254367417b2b2512c70",
      "title": "Create and Add to Sets in ES6",
      "description": [
        "在上面的练习中，我们用 ES5 实现了集合，现在我们来用 ES6 实现。在 ES6 中，这些操作会更加简单。我们可以通过 ES6 的内建<code>Set</code>数据结构，它也包含了很多上面我们自己写的方法。我们先来一起来看看这些方法：",
        "创建一个空 set：",
        "<code>var set = new Set();</code>",
        "创建带有一个值的 set：",
        "<code>var set = new Set(1);</code>",
        "基于数组创建 set：",
        "<code>var set = new Set([1, 2, 3]);</code>",
        "创建好 set 之后，我们可以通过<code>add</code>方法添加元素：",
        "<blockquote>var set = new Set([1, 2, 3]);<br>set.add([4, 5, 6]);</blockquote>",
        "提醒一下，set 数据结构中不允许出现重复元素：",
        "<blockquote>var set = new Set([1, 2, 3, 1, 2, 3]);<br>// set 只包含 [1, 2, 3]</blockquote>",
        "<hr>",
        "请修改<code>checkSet</code>函数，让它的返回<code>1, 2, 3, 'Taco', 'Cat', 'Awesome'</code>。"
      ],
      "tests": [
        {
          "text": "<code>Set</code>应该只包含<code>1, 2, 3, Taco, Cat, Awesome</code>这些元素。",
          "testString": "assert(function(){var test = checkSet(); return (test.size == 6) && test.has(1) && test.has(2) && test.has(3) && test.has('Taco') && test.has('Cat') && test.has('Awesome');}, '<code>Set</code>应该只包含<code>1, 2, 3, Taco, Cat, Awesome</code>这些元素。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function checkSet(){var set = new Set([1,2,3,'Taco','Cat','Awesome']);\nreturn set;}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function checkSet() {",
            "  var set = new Set([1, 2, 3, 3, 2, 1, 2, 3, 1]);",
            "  // 请把你的代码写在这条注释以下",
            "  ",
            "  // 请把你的代码写在这条注释以上",
            "  console.log(set);",
            "  return set;",
            "}",
            "",
            "checkSet();"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8254367417b2b2512c71",
      "title": "Remove items from a set in ES6",
      "description": [
        "现在让我们使用<code>delete</code>方法从 ES6 Set 中移除元素。",
        "首先，创建一个 ES6 Set：",
        "<code>var set = new Set([1,2,3]);</code>",
        "使用<code>delete</code>方法从 Set 中移除一个元素：",
        "<blockquote>set.delete(1);<br>console.log([...set]) // 输出 [ 2, 3 ]<blockquote>",
        "<hr>",
        "请修改<code>checkSet</code>函数，先创建一个包含 1、2、3、4、5 这些整数的 set，然后移除元素 2 和 5，并返回移除元素后的 set。"
      ],
      "tests": [
        {
          "text": "<code>checkSet()</code>应该返回 1、3、4。",
          "testString": "assert(function(){var test = checkSet(); return test.has(1) && test.has(3) && test.has(4) && test.size === 3}, '<code>checkSet()</code>应该返回 1、3、4。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function checkSet(){\nvar set = new Set([1,2,3,4,5]);\nset.delete(2);\nset.delete(5);\nreturn set;}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function checkSet(){",
            "   var set = // 创建包含 1、2、3、4、5 这 5 个整数的 set",
            "   // 移除 2",
            "   // 移除 5",
            "   // 返回 set",
            "   return set;",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8255367417b2b2512c72",
      "title": "Use .has and .size on an ES6 Set",
      "description": [
        "现在我们来学习 ES6 Set 对象的<code>has</code>和<code>size</code>方法。",
        "首先，创建一个 ES6 Set：",
        "<code>var set = new Set([1,2,3]);</code>",
        "<code>has</code>方法会检查 set 中是否有某个值：",
        "<code>var hasTwo = set.has(2);</code>",
        "<code>size</code>会返回 Set 的长度：",
        "<code>var howBig = set.size;</code>",
        "<hr>",
        "在本次练习当中我们会给<code>checkSet</code>函数传入一个数组和一个值作为参数，该函数需要根据传入的数组参数创建一个 ES6 set，并检查该 set 中是否存在该第二个参数值。这个函数的返回值为一个数组，第一个元素为<code>true</code>或<code>false</code>，用于表示 set 中是否存在第二个参数值；第二个元素为 set 的长度。"
      ],
      "tests": [
        {
          "text": "<code>checkSet([4, 5, 6], 3)</code>应该返回 [ false, 3 ]",
          "testString": "assert(function(){var test = checkSet([4,5,6], 3); test === [ false, 3 ]}, '<code>checkSet([4, 5, 6], 3)</code>应该返回 [ false, 3 ]');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function checkSet(arrToBeSet, checkValue){\nvar set = new Set(arrToBeSet);\nvar result = [\nset.has(checkValue),\nset.size\n];\nreturn result;\n}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function checkSet(arrToBeSet, checkValue){",
            "",
            "   // 请把你的代码写在这条注释以下",
            "",
            "   // 请把你的代码写在这条注释以上",
            "",
            "}",
            "",
            "checkSet([ 1, 2, 3], 2); // 应该返回 [ true, 3 ]"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8255367417b2b2512c73",
      "title": "Use Spread and Notes for ES5 Set() Integration",
      "description": [
        "你是否还记得 ES6 中的<code>...</code>操作符？",
        "<code>...</code>接收 ES6 中的可迭代对象，并将其转换为数组。",
        "现在我们来创建一个 Set 并检验<code>...</code>操作符：",
        "<blockquote>var set = new Set([1,2,3]);<br>var setToArr = [...set]<br>console.log(setToArr) // 返回 [ 1, 2, 3 ]</blockquote>",
        "<hr>",
        "在本次练习中我们给<code>checkSet</code>传递一个 set 对象。函数返回一个数组，该数组应包含 Set 集合中所有的值。",
        "至此，你已经完全掌握了 ES6<code>Set()</code>对象，继续加油！"
      ],
      "tests": [
        {
          "text": "应返回 Set 内的所有值。",
          "testString": "assert(function(){var test = checkSet(new Set([1,2,3,4,5,6,7])); test === [ 1, 2, 3, 4, 5, 6, 7 ]}, '应返回 Set 内的所有值。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function checkSet(set){\nreturn [...set];}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function checkSet(set){",
            "   // 请把你的代码写在这条注释以下",
            "",
            "   // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "8d5823c8c441eddfaeb5bdef",
      "title": "Create a Map Data Structure",
      "description": [
        "接下来的几个挑战会涉及到 Map（映射）和 Hash Table（哈希表）这些知识点。Map 是一种存储键值对的数据结构。在 JavaScript 中，对象就是 Map 的一种表现形式。Map 是一种十分通用和高效的数据查询结构，我们可以在 Map 中通过 key（键）快速地获取对应的 value（值）。",
        "挑战说明：现在我们需要创建 Map。鉴于 JavaScript 的对象已经为我们提供了十分高效的 Map 数据结构，我们在本次挑战中写的一些方法只是出于熟悉 Map 的目的。然而 JavaScript 对象本身只为我们提供了少量的操作方法，如果我们想要添加一些自定义方法该怎么办呢？",
        "现在我们使用 JavaScript 对象来模拟<code>Map</code>数据结构，我们需要在 Map 对象中创建如下方法：",
        "<code>add</code>方法接收<code>key</code>和<code>value</code>作为参数，并把键值对添加到 Map 中；",
        "<code>remove</code>方法接收一个<code>key</code>值并移除对应的键值对；",
        "<code>get</code>方法接收<code>key</code>值，并返回对应的<code>value</code>值；",
        "<code>has</code>方法根据值的存在情况返回相应的<code>boolean</code>值；",
        "<code>values</code>方法以数组形式返回 Map 中所有的 value；",
        "<code>size</code>方法返回 Map 中元素的个数；",
        "<code>clear</code>清空 Map。"
      ],
      "tests": [
        {
          "text": "应存在 Map 数据结构。",
          "testString": "assert((function() { var test = false; if (typeof Map !== 'undefined') { test = new Map() }; return (typeof test == 'object')})(), '应存在 Map 数据结构。');"
        },
        {
          "text": "Map 对象应该有 add、remove、get、has、values、clear、size 这些方法。",
          "testString": "assert((function() { var test = false; if (typeof Map !== 'undefined') { test = new Map() }; return (typeof test.add == 'function' && typeof test.remove == 'function' && typeof test.get == 'function' && typeof test.has == 'function' && typeof test.values == 'function' && typeof test.clear == 'function' && typeof test.size == 'function')})(), 'Map 对象应该有 add、remove、get、has、values、clear、size 这些方法。');"
        },
        {
          "text": "add 方法应添加元素到 map 中。",
          "testString": "assert((function() { var test = false; if (typeof Map !== 'undefined') { test = new Map() }; test.add(5,6); test.add(2,3); test.add(2,5); return (test.size() == 2)})(), 'add 方法应添加元素到 map 中。');"
        },
        {
          "text": "当指定元素存在时，has 方法应返回 true，否则返回 false。",
          "testString": "assert((function() { var test = false; if (typeof Map !== 'undefined') { test = new Map() }; test.add('test','value'); return (test.has('test') && !test.has('false'))})(), '当指定元素存在时，has 方法应返回 true，否则返回 false。');"
        },
        {
          "text": "get 方法接收 key 作为参数，并应该返回对应的 value。",
          "testString": "assert((function() { var test = false; if (typeof Map !== 'undefined') { test = new Map() }; test.add('abc','def'); return (test.get('abc') == 'def')})(), 'get 方法接收 key 作为参数，并应该返回对应的 value。');"
        },
        {
          "text": "values 方法应该以数组形式返回 map 中所有的 value 值。",
          "testString": "assert((function() { var test = false; if (typeof Map !== 'undefined') { test = new Map() }; test.add('a','b'); test.add('c','d'); test.add('e','f'); var vals = test.values(); return (vals.indexOf('b') != -1 && vals.indexOf('d') != -1 && vals.indexOf('f') != -1)})(), 'values 方法应该以数组形式返回 map 中所有的 value 值。');"
        },
        {
          "text": "clear 方法应清空 map 中的所有元素，size 方法应返回 map 中元素的个数。",
          "testString": "assert((function() { var test = false; if (typeof Map !== 'undefined') { test = new Map() }; test.add('b','b'); test.add('c','d'); test.remove('asdfas'); var init = test.size(); test.clear(); return (init == 2 && test.size() == 0)})(), 'clear 方法应清空 map 中的所有元素，size 方法应返回 map 中元素的个数。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var Map = function() {",
            "  this.collection = {};",
            "  // 请把你的代码写在这条注释以下",
            "  // 请把你的代码写在这条注释以上",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d825b367417b2b2512c8d",
      "title": "Create an ES6 JavaScript Map",
      "description": [
        "新版 JavaScript 为我们提供了内置的 Map 对象，该 Map 对象提供了上一次挑战中我们手写的大部分方法。但是 Map 对象相比一般的 JavaScript 对象提供了更多的方法。例如，ES6 的 Map 可以追溯元素添加进 Map 的顺序。下面是 Map 内置方法的概览：",
        "<code>.has(key)</code>根据 key 值存在与否返回 true 或 false；",
        "<code>.get(key)</code>返回 key 值对应的 value 值；",
        "<code>.set(key, value)</code>添加一组新的键值对；",
        "<code>.delete(key)</code>移除一个键值对；",
        "<code>.clear()</code>移除所有的键值对；",
        "<code>.entries()</code>以数组形式返回所有 key 值，顺序以插入时的顺序为准；",
        "<code>.values()</code>以数组形式返回所有 value 值，顺序以插入时的顺序为准。",
        "任务：定义一个 Map 对象并将其赋值给一个名为 myMap 的变量。你还需要给 Map 对象添加键值对<code>freeCodeCamp</code>,<code>Awesome!</code>。"
      ],
      "tests": [
        {
          "text": "myMap 对象应存在。",
          "testString": "assert(typeof myMap === 'object', 'myMap 对象应存在。');"
        },
        {
          "text": "myMap 应包含键值对<code>freeCodeCamp: 'Awesome!'</code>。",
          "testString": "assert(myMap.get('freeCodeCamp') === 'Awesome!', 'myMap 应包含键值对<code>freeCodeCamp</code>,<code>Awesome!</code>。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "// 请把你的代码写在这条注释以下"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d825b367417b2b2512c8e",
      "title": "Create a Hash Table",
      "description": [
        "在本次挑战中我们会学习哈希表。与对象和 Map 类似，hash 也可以用来实现关联数组或者匹配的键值对。在 JavaScript 中，我们可以用对象来实现哈希表（具体实现方式依赖于运行环境）。哈希表接收一个 key 作为参数，并以特定的方式把 key 转换为一串数字。该数字串会与 value 值建立对应关系，并存储到表中。如果你想获取该 key 值，hashing 函数会接收 key 作为参数，并经过计算后得到与存储时的 key 相同的数字串，然后通过该数字串获取对应的 value。这种查询方式非常高效，平均时间复杂度为 O(n)。",
        "我们还可以用数组来实现哈希表，该数组拥有一个 hash 方法，用于在指定区间内生成一系列索引。在此方法中，数组的长度和 hash 函数的选择都很关键。试想一下，假如两个不同的 key 值通过同一个 hash 函数产生了相同的值怎么办？我们称这种情况为 collision（冲突）。解决冲突的一种方式是将键值对存入该 index 中。在查询时，你需要遍历一下这个 index 上存储的所有数据，找出你需要的那一条。一个好的 hash 函数应维持较低的冲突发生率，以保证查询效率。",
        "本课程我们不关注 hash 函数或者哈希表的实现细节，熟悉一下他们是如何运作的即可。",
        "挑战说明：现在我们来创建一个拥有基本功能的哈希表。我们已经为你写好了一个简单的 hash 函数，当你传递一个值给该函数时，它会返回一个经过 hash 运算的值；你需要用这个值作为 key，将元素存储到 this.collection 对象中。然后，你需要其中创建 add、remove、lookup 这三个方法。add 方法接收一个键值对参数并把它存储到哈希表中；remove 方法接收一个 key 为参数并移除对应的键值对；lookup 方法接收一个 key 为参数并返回对应的 value 值，如果 key 值不存在就返回 null。",
        "请确保你的代码能处理发生冲突的情况。"
      ],
      "tests": [
        {
          "text": "应该存在哈希表数据结构。",
          "testString": "assert((function() { var test = false; if (typeof HashTable !== 'undefined') { test = new HashTable() }; return (typeof test === 'object')})(), '应该存在哈希表数据结构。');"
        },
        {
          "text": "哈希表应该有 add 方法。",
          "testString": "assert((function() { var test = false; if (typeof HashTable !== 'undefined') { test = new HashTable() }; return ((typeof test.add) === 'function')})(), '哈希表应该有 add 方法。');"
        },
        {
          "text": "哈希表应该有 remove 方法。",
          "testString": "assert((function() { var test = false; if (typeof HashTable !== 'undefined') { test = new HashTable() }; return ((typeof test.remove) === 'function')})(), '哈希表应该有 remove 方法。');"
        },
        {
          "text": "哈希表应该有 lookup 方法。",
          "testString": "assert((function() { var test = false; if (typeof HashTable !== 'undefined') { test = new HashTable() }; return ((typeof test.lookup) === 'function')})(), '哈希表应该有 lookup 方法。');"
        },
        {
          "text": "add 方法应在哈希表中添加键值对；lookup 方法应根据传入的 key 返回对应的 value 值。",
          "testString": "assert((function() { var test = false; if (typeof HashTable !== 'undefined') { test = new HashTable() }; test.add('key', 'value'); return (test.lookup('key') === 'value')})(), 'add 方法应在哈希表中添加键值对；lookup 方法应根据传入的 key 返回对应的 value 值。');"
        },
        {
          "text": "remove 方法应接收 key 值为参数并删除对应的键值对。",
          "testString": "assert((function() { var test = false; if (typeof HashTable !== 'undefined') { test = new HashTable() }; test.add('key', 'value'); test.remove('key'); return (test.lookup('key') === null)})(), 'remove 方法应接收 key 值为参数并删除对应的键值对。');"
        },
        {
          "text": "应该使用 hash 函数把元素添加进哈希表。",
          "testString": "assert((function() { var test = false; if (typeof HashTable !== 'undefined') { test = new HashTable() }; called = 0; test.add('key1','value1'); test.add('key2','value2'); test.add('key3','value3'); return (called === 3)})(), '应该使用 hash 函数把元素添加进哈希表。');"
        },
        {
          "text": "你的哈希表应该可以处理冲突。",
          "testString": "assert((function() { var test = false; if (typeof HashTable !== 'undefined') { test = new HashTable() }; called = 0; test.add('key1','value1'); test.add('1key','value2'); test.add('ke1y','value3'); return (test.lookup('key1') === 'value1' && test.lookup('1key') == 'value2' && test.lookup('ke1y') == 'value3')})(), '你的哈希表应该可以处理冲突。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var called = 0;",
            "var hash = (string) => {",
            "  called++;",
            "  var hash = 0;",
            "  for (var i = 0; i < string.length; i++) { hash += string.charCodeAt(i); }",
            "  return hash;",
            "};",
            "var HashTable = function() {",
            "  this.collection = {};",
            "  // 请把你的代码写在这条注释以下",
            "  // 请把你的代码写在这条注释以上",
            "};"
          ],
          "head": [
            "  var called = 0;",
            "    var hash = (string) => {",
            "     called++;",
            "      var hash = 0;",
            "      for (var i = 0; i < string.length; i++) { hash += string.charCodeAt(i); };",
            "      return hash;",
            "    };"
          ],
          "tail": []
        }
      }
    },
    {
      "id": "587d8251367417b2b2512c61",
      "title": "Work with Nodes in a Linked List",
      "description": [
        "计算机科学中，另一个比较常见的数据结构是链表。链表是一系列数据元素的线性集合，每个元素称为节点（nodes）；且每个节点都有指向下一个节点的指针。因此，链表中的每个节点由元素本身和指向下一个节点的引用组成。",
        "这种数据结构可以类比老鹰捉小鸡的游戏，游戏中所有扮演鸡仔的人需要躲在母鸡身后，手要搭在前一个人的肩上。你可以看到你前面的人是谁，但是看不到再前面的人。一个节点就如同一个扮演鸡仔中的一个人：这个人知道自己是谁，也只能看到前面的一个人，但他无法看到其他人。",
        "<hr>",
        "在代码编辑器中，我们已经创建了<code>Kitten</code>和<code>Puppy</code>两个节点，而且我们已经将<code>Kitten</code>节点和<code>Puppy</code>节点连接起来。",
        "请创建<code>Cat</code>和<code>Dog</code>两个节点，并把他们添加到<code>Kitten</code>和<code>Puppy</code>之后。"
      ],
      "tests": [
        {
          "text": "<code>Puppy</code>节点应该有指向<code>Cat</code>节点的引用。",
          "testString": "assert(Puppy.next.element === \"Cat\", '<code>Puppy</code>节点应该有指向<code>Cat</code>节点的引用。');"
        },
        {
          "text": "<code>Cat</code>节点应该有指向<code>Dog</code>节点的引用。",
          "testString": "assert(Cat.next.element === \"Dog\", '<code>Cat</code>节点应该有指向<code>Dog</code>节点的引用。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var Node = function(element){",
            "    this.element = element; ",
            "    this.next = null; ",
            "};",
            "var Kitten = new Node(\"Kitten\");",
            "var Puppy = new Node(\"Puppy\");",
            "",
            "Kitten.next = Puppy;",
            "// 请把你的代码写在这条注释以下",
            "",
            "// 你可以修改这行代码来进行测试",
            "console.log(Kitten.next);"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8251367417b2b2512c62",
      "title": "Create a Linked List Class",
      "description": [
        "现在我们来创建一个<code>链表</code>类。每个链表实例都应该有<code>head</code>（表中第一个元素）和<code>length</code>（表中元素的个数）这样的基本属性。有些链表会用<code>tail</code>属性表示表中最后一个元素，但是本次练习我们只关注 head 和 length 这两个属性。只要我们往链表中添加了元素，<code>length</code>属性的数值就会加一。",
        "首先，我们需要创建一个<code>add</code>方法，这个方法可以把元素添加进链表。",
        "如果链表为空，那我们只需用<code>Node</code>类来创建一个节点，同时让链表的<code>head</code>指向该元素即可。",
        "但如果链表中已经存在一些元素，我们该如何添加呢？回想一下，链表中的每个元素都有<code>next</code>属性。而且，链表中最后一个节点的<code>next</code>是指向<code>null</code>的。为了添加新节点，我们首先需要找到链表的最后一个节点，并让该节点的<code>next</code>指针指向我们添加的新节点。",
        "<hr>",
        "请写一个<code>add</code>方法，当添加第一个元素时让<code>head</code>指针指向该元素；之后添加的新元素，前一个节点的<code>next</code>属性都应该指向这个新添加的元素。",
        "注意：",
        "每当有新元素添加进链表，<code>length</code>的数值都应该加一。"
      ],
      "tests": [
        {
          "text": "<code>LinkedList</code>应该有<code>add</code>方法。",
          "testString": "assert((function(){var test = new LinkedList(); return (typeof test.add === 'function')}()), '<code>LinkedList</code>应该有<code>add</code>方法。');"
        },
        {
          "text": "<code>LinkedList</code>中的<code>head</code>指针应该指向链表的第一个元素。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); return test.head().element === 'cat'}()), '<code>LinkedList</code>中的<code>head</code>指针应该指向链表的第一个元素。');"
        },
        {
          "text": "<code>LinkedList</code>中的节点应该有指针指向最新创建的节点。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); return test.head().next.element === 'dog'}()), '<code>LinkedList</code>中的节点应该有指针指向最新创建的节点。');"
        },
        {
          "text": "<code>LinkedList</code>中的<code>size</code>属性应表示节点的总数。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); return test.size() === 2}()), '<code>LinkedList</code>中的<code>size</code>属性应表示节点的总数。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function LinkedList() { ",
            "  var length = 0; ",
            "  var head = null; ",
            "",
            "  var Node = function(element){",
            "    this.element = element; ",
            "    this.next = null; ",
            "  }; ",
            "",
            "  this.head = function(){",
            "    return head;",
            "  };",
            "",
            "  this.size = function(){",
            "    return length;",
            "  };",
            "",
            "  this.add = function(element){",
            "    // 请把你的代码写在这条注释以下",
            "",
            "    // 请把你的代码写在这条注释以上",
            "  };",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8251367417b2b2512c63",
      "title": "Remove Elements from a Linked List",
      "description": [
        "链表中一个重要的方法是<code>remove</code>。该方法接收一个元素作为参数，然后在链表中找到并移除该元素。",
        "在链表中移除节点并不只是从仅仅删除掉一个元素那么简单。在链表中，每个节点的<code>next</code>指针都会指向表中的下一个节点。因此，在移除节点时，我们需要确保这个被移除节点的前一个节点的<code>next</code>指针指向被移除节点的下一个节点。",
        "这样解释可能比较抽象，因此我们再来回想一下上面提到的老鹰捉小鸡。想象一下，在扮演鸡仔的队伍中，你正前方的人离开了队伍。这个离队的人也就不再会把手搭在他前一个人的肩上，同时你的手也不可能继续搭在离队的那个人肩上。接下来你需要向前走一步，把你的手搭在他前面的那个人肩上。",
        "如果我们移除的是头部元素，那么我们需要让<code>head</code>指针指向链表中的下一个元素（即移除前的第二个元素）。",
        "<hr>",
        "请编写<code>remove</code>方法，该方法接收一个元素作为参数并从链表中移除该元素。",
        "注意：",
        "每当有元素从链表中移除，<code>length</code>的数值都应该减一。"
      ],
      "tests": [
        {
          "text": "<code>LinkedList</code>应该有<code>remove</code>方法。",
          "testString": "assert((function(){var test = new LinkedList(); return (typeof test.remove === 'function')}()), '<code>LinkedList</code>应该有<code>remove</code>方法。');"
        },
        {
          "text": "当链表头部元素被移除时，<code>remove</code>方法应该让<code>head</code>指针指向表中的第二个元素。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.remove('cat'); return test.head().element === 'dog'}()), '当链表头部元素被移除时，<code>remove</code>方法应该让<code>head</code>指针指向表中的第二个元素。');"
        },
        {
          "text": "当元素被移除时，<code>remove</code>方法应该让<code>length</code>减 1 。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.remove('cat'); return test.size() === 1})(), '当元素被移除时，<code>remove</code>方法应该让<code>length</code>减 1 。');"
        },
        {
          "text": "当元素被移除时，<code>remove</code>方法应该让被移除元素的前一个元素的<code>next</code>指针指向被移除元素的下一个元素。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog');test.add('kitten'); test.remove('dog'); return test.head().next.element === 'kitten'})(), '当元素被移除时，<code>remove</code>方法应该让被移除元素的前一个元素的<code>next</code>指针指向被移除元素的下一个元素。');"
        }
      ],
      "solutions": [
        "class Node {\n  constructor (element) {\n    this.element = element;\n    this.next = null;\n  }\n}\n\nclass LinkedList {\n  constructor () {\n    this._length = 0;\n    this._head = null;\n  }\n\n  head () {\n    return this._head;\n  }\n\n  size () {\n    return this._length;\n  }\n\n  add (element) {\n    const node = new Node(element);\n\n    if (this._head === null) {\n      this._head = node;\n    } else {\n      let current = this._head;\n\n      while (current.next !== null) {\n        current = current.next;\n      }\n\n      current.next = node; \n    }\n    \n    ++this._length;\n  }\n  \n  remove (element) {\n    if (this._head === null) return;\n    \n    let previous;\n    let current = this._head;\n    \n    while (current.next !== null && current.element !== element) {\n      previous = current;\n      current = current.next;\n    }\n    \n    if (previous) {\n      previous.next = current.next;\n    } else {\n      this._head = current.next;\n    }\n    \n    --this._length;\n  }\n}"
      ],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function LinkedList() { ",
            "  var length = 0; ",
            "  var head = null; ",
            "",
            "  var Node = function(element){ ",
            "    this.element = element; ",
            "    this.next = null; ",
            "  }; ",
            "",
            "  this.size = function(){",
            "    return length;",
            "  };",
            "",
            "  this.head = function(){",
            "    return head;",
            "  };",
            "",
            "  this.add = function(element){",
            "    var node = new Node(element);",
            "    if(head === null){",
            "        head = node;",
            "    } else {",
            "        currentNode = head;",
            "",
            "        while(currentNode.next){",
            "            currentNode  = currentNode.next;",
            "        }",
            "",
            "        currentNode.next = node;",
            "    }",
            "",
            "    length++;",
            "  }; ",
            "",
            "  this.remove = function(element){",
            "    // 请把你的代码写在这条注释以下",
            "",
            "    // 请把你的代码写在这条注释以上",
            "  };",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8251367417b2b2512c64",
      "title": "Search within a Linked List",
      "description": [
        "现在我们来为链表添加一些更加实用的方法。例如我们可以加一个判断链表是否为空的方法，就像之前我们给<code>Stack</code>和<code>Queue</code>添加的一样。",
        "我们还应该有一个在链表中找某一个具体的元素的方法。对于任何一种数据结构，你都应该在学习时了解它们的遍历方式。现在我们来创建一个<code>indexOf</code>方法，该方法接收一个<code>element</code>作为参数并返回该元素在链表中的索引值。如果该元素不存在就返回<code>-1</code>。",
        "除此之外，我们再来写一个实现相反功能的方法：<code>elementAt</code>，该方法接收一个<code>index</code>为参数，返回对应位置的<code>element</code>。如果<code>element</code>没找到就返回<code>undefined</code>。",
        "<hr>",
        "请编写<code>isEmpty</code>方法来判断链表是否为空，<code>indexOf</code>方法返回给定元素的<code>index</code>，<code>elementAt</code>方法返回给定位置的<code>element</code>值。"
      ],
      "tests": [
        {
          "text": "<code>LinkedList</code>应该有<code>indexOf</code>方法。",
          "testString": "assert((function(){var test = new LinkedList(); return (typeof test.indexOf === 'function')}()), '<code>LinkedList</code>应该有<code>indexOf</code>方法。');"
        },
        {
          "text": "<code>LinkedList</code>应该有<code>elementAt</code>方法。",
          "testString": "assert((function(){var test = new LinkedList(); return (typeof test.elementAt === 'function')}()), '<code>LinkedList</code>应该有<code>elementAt</code>方法。');"
        },
        {
          "text": "<code>size</code>方法应该返回链表的长度。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten'); return test.size() === 3}()), '<code>size</code>方法应该返回链表的长度。');"
        },
        {
          "text": "<code>indexOf</code>方法应该返回给定元素的索引值。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten'); return test.indexOf('kitten') === 2}()), '<code>indexOf</code>方法应该返回给定元素的索引值。');"
        },
        {
          "text": "<code>elementAt</code>方法应该返回对应位置的元素值。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten'); return test.elementAt(1) === 'dog'}()), '<code>elementAt</code>方法应该返回对应位置的元素值。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function LinkedList() { ",
            "  var length = 0; ",
            "  var head = null; ",
            "",
            "  var Node = function(element){ // {1} ",
            "    this.element = element; ",
            "    this.next = null; ",
            "  }; ",
            "",
            "  this.size = function() {",
            "    return length;",
            "  };",
            "",
            "  this.head = function(){",
            "    return head;",
            "  };",
            "",
            "  this.add = function(element){",
            "    var node = new Node(element);",
            "    if(head === null){",
            "        head = node;",
            "    } else {",
            "        currentNode = head;",
            "",
            "        while(currentNode.next){",
            "            currentNode  = currentNode.next;",
            "        }",
            "",
            "        currentNode.next = node;",
            "    }",
            "",
            "    length++;",
            "  }; ",
            "",
            "  this.remove = function(element){",
            "    var currentNode = head;",
            "    var previousNode;",
            "    if(currentNode.element === element){",
            "        head = currentNode.next;",
            "    } else {",
            "        while(currentNode.element !== element) {",
            "            previousNode = currentNode;",
            "            currentNode = currentNode.next;",
            "        }",
            "",
            "        previousNode.next = currentNode.next;",
            "    }",
            "",
            "    length --;",
            "  };",
            "",
            "  // 请把你的代码写在这条注释以下",
            "",
            "  // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8251367417b2b2512c65",
      "title": "Remove Elements from a Linked List by Index",
      "description": [
        "在学习其他数据结构之前，我们再来做两个与链表相关的练习。",
        "首先，我们来写一个<code>removeAt</code>方法，该方法根据给定的<code>index</code>删除对应位置上的<code>element</code>。我们把这个方法命名为<code>removeAt(index)</code>。为了移除给定位置上的<code>element</code>，我们需要用一个变量（也可以叫指针）来记录我们遍历到的位置。",
        "在遍历链表中元素时，我们通常需要一个指向代码中当前遍历到的元素的指针。在本例中，我们从表的头部开始，设置<code>currentIndex</code>的初始值为<code>0</code>。每 “经过” 一个元素，我们都需要让<code>currentIndex</code>加一。",
        "就像<code>remove(element)</code>方法一样，删除的时候不仅仅是移除元素那么简单，我们需要保证被移除节点的前一个节点的<code>next</code>指针指向被移除节点的下一个节点。",
        "<hr>",
        "请编写<code>removeAt(index)</code>方法，移除指定位置的节点，同时该方法需要返回被移除的节点。如果<code>index</code>的值为负数或者大于等于链表的长度，该方法应该返回<code>null</code>。",
        "注意：",
        "记得及时更新<code>currentIndex</code>的数值。"
      ],
      "tests": [
        {
          "text": "链表应该有<code>removeAt</code>方法。",
          "testString": "assert((function(){var test = new LinkedList(); return (typeof test.removeAt === 'function')}()), '链表应该有<code>removeAt</code>方法。');"
        },
        {
          "text": "使用<code>removeAt</code>方法之后，链表的长度应该缩短。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten'); test.removeAt(1); return test.size() === 2}()), '使用<code>removeAt</code>方法之后，链表的长度应该缩短。');"
        },
        {
          "text": "<code>removeAt</code>应该返回被移除的那个节点。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten');  return test.removeAt(1) === 'dog'}()), '<code>removeAt</code>应该返回被移除的那个节点。');"
        },
        {
          "text": "如果 index 的值小于<code>0</code>，<code>removeAt</code>方法应该返回<code>null</code>。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten');  return (test.removeAt(-1) === null)}()), '如果 index 的值小于<code>0</code>，<code>removeAt</code>方法应该返回<code>null</code>。');"
        },
        {
          "text": "如果 index 的值大于等于链表长度，<code>removeAt</code>方法应该返回<code>null</code>。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.add('kitten');  return (test.removeAt(3) === null)}()), '如果 index 的值大于等于链表长度，<code>removeAt</code>方法应该返回<code>null</code>。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function LinkedList() { ",
            "  var length = 0; ",
            "  var head = null; ",
            "",
            "  var Node = function(element){ // {1} ",
            "    this.element = element; ",
            "    this.next = null; ",
            "  }; ",
            "",
            "  this.size = function(){",
            "    return length;",
            "  };",
            "",
            "  this.head = function(){",
            "    return head;",
            "  };",
            "",
            "  this.add = function(element){",
            "    var node = new Node(element);",
            "    if(head === null){",
            "        head = node;",
            "    } else {",
            "        currentNode = head;",
            "",
            "        while(currentNode.next){",
            "            currentNode  = currentNode.next;",
            "        }",
            "",
            "        currentNode.next = node;",
            "    }",
            "",
            "    length++;",
            "  }; ",
            "",
            "  this.remove = function(element){",
            "    var currentNode = head;",
            "    var previousNode;",
            "    if(currentNode.element === element){",
            "        head = currentNode.next;",
            "    } else {",
            "        while(currentNode.element !== element) {",
            "            previousNode = currentNode;",
            "            currentNode = currentNode.next;",
            "        }",
            "",
            "        previousNode.next = currentNode.next;",
            "    }",
            "",
            "    length --;",
            "  };",
            "",
            "  // 请把你的代码写在这条注释以下",
            "",
            "  // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8252367417b2b2512c67",
      "title": "Add Elements at a Specific Index in a Linked List",
      "description": [
        "现在我们来创建一个<code>addAt(index, element)</code>方法，该方法在指定的位置添加一个元素。",
        "就像我们移除指定位置的元素一样，在遍历链表时需要及时更新 currentIndex 的数值。当 currentIndex 与给定的 index 值相等时，我们需要让这个节点的前一个节点指向新添加的节点，以及让新添加的节点指向这个节点。",
        "再来回想一下老鹰捉小鸡的例子，有一个新队员想加入扮演鸡仔的队伍的中间位置，而你就在队伍中间。因此你需要将手从前一个人的肩上拿开，而新加入的人则将他的手搭到了你刚才搭的那个人的肩上，最后你需要将你的手搭在新加入队伍的这个人肩上。",
        "挑战说明：",
        "创建一个<code>addAt(index, element)</code>方法，该方法可以为链表在指定位置添加元素。如果元素未能成功添加则返回 false。",
        "注意：",
        "记得检查 index 的值是否小于 0 或大于等于链表长度。"
      ],
      "tests": [
        {
          "text": "当传入的 index 的值为 0 时，<code>addAt</code>方法应该让<code>head</code>指针指向新加入的节点。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.addAt(0,'cat'); return test.head().element === 'cat'}()), '当传入的 index 的值为 0 时，<code>addAt</code>方法应该让<code>head</code>指针指向新加入的节点。');"
        },
        {
          "text": "每添加一个元素到链表中时，<code>addAt</code>方法应该让链表的长度加 1。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); test.addAt(0,'cat'); return test.size() === 3}()), '每添加一个元素到链表中时，<code>addAt</code>方法应该让链表的长度加 1。');"
        },
        {
          "text": "如果节点未能成功添加到链表中，<code>addAt</code>方法应该返回<code>false</code>。",
          "testString": "assert((function(){var test = new LinkedList(); test.add('cat'); test.add('dog'); return (test.addAt(4,'cat') === false); }()), '如果节点未能成功添加到链表中，<code>addAt</code>方法应该返回<code>false</code>。');"
        }
      ],
      "solutions": [],
      "hints": [],
      "releasedOn": "Feb 17, 2017",
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function LinkedList() { ",
            "  var length = 0; ",
            "  var head = null; ",
            "",
            "  var Node = function(element){",
            "    this.element = element; ",
            "    this.next = null; ",
            "  }; ",
            "",
            "  this.size = function(){",
            "    return length;",
            "  };",
            "",
            "  this.head = function(){",
            "    return head;",
            "  };",
            "",
            "  this.add = function(element){",
            "    var node = new Node(element);",
            "    if(head === null){",
            "        head = node;",
            "    } else {",
            "        currentNode = head;",
            "",
            "        while(currentNode.next){",
            "            currentNode  = currentNode.next;",
            "        }",
            "",
            "        currentNode.next = node;",
            "    }",
            "",
            "    length++;",
            "  }; ",
            "",
            "  // 请把你的代码写在这条注释以下",
            "",
            "  // 请把你的代码写在这条注释以上",
            "",
            "}"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d825a367417b2b2512c87",
      "title": "Create a Doubly Linked List",
      "description": [
        "之前我们创建的都是单向链表，现在我们来创建双向链表。顾名思义，双向链表拥有两个指针，一个指向前一个节点，一个指向后一个节点。",
        "对于这种链表，我们可以从两个方向遍历元素，但因为每个节点都有两个指针，因此这种链表会占据更多的内存空间。",
        "<hr>",
        "在右边的编辑器中，我们已经为你写好了一个<code>Node</code>和<code>DoublyLinkedList</code>。现在我们来给双向链表添加<code>add</code>和<code>remove</code>方法。<code>add</code>方法应该把指定的元素添加到双向链表中，而<code>remove</code>方法应该移除双向链表中的指定元素。",
        "对于双向链表中边界元素的操作，比如移除移除头部或尾部元素时需要谨慎。以及，如果尝试从空链表中移除元素，则应该返回<code>null</code>。"
      ],
      "tests": [
        {
          "text": "应该存在双向链表。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; return (typeof test == 'object')})(), '应该存在双向链表。');"
        },
        {
          "text": "双向链表应该有 add 方法。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; if (test.add == undefined) { return false; }; return (typeof test.add == 'function')})(), '双向链表应该有 add 方法。');"
        },
        {
          "text": "双向链表应该有 remove 方法。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; if (test.remove == undefined) { return false; }; return (typeof test.remove == 'function')})(), '双向链表应该有 remove 方法。');"
        },
        {
          "text": "试图从空表中移除元素时应该返回 null。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; return (test.remove(100) == null); })(), '试图从空表中移除元素时应该返回 null。');"
        },
        {
          "text": "add 方法应可以把元素添加到链表中。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; test.add(5); test.add(6); test.add(723); return (test.print().join('') == '56723'); })(), 'add 方法应可以把元素添加到链表中。');"
        },
        {
          "text": "每个节点应该有指向前一个节点的指针。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; test.add(50); test.add(68); test.add(73); return (test.printReverse().join('') == '736850'); })(), '每个节点应该有指向前一个节点的指针。');"
        },
        {
          "text": "表中第一个元素应可以被移除。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; test.add(25); test.add(35); test.add(60); test.remove(25); return ( test.print().join('') == '3560' ) })(), '表中第一个元素应可以被移除。');"
        },
        {
          "text": "表中最后一个元素应可以被移除。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; test.add(25); test.add(35); test.add(60); test.remove(60); return ( test.print().join('') == '2535' ) })(), '表中最后一个元素应可以被移除。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var Node = function(data, prev) {",
            "  this.data = data;",
            "  this.prev = prev;",
            "  this.next = null;",
            "};",
            "var DoublyLinkedList = function() {",
            "  this.head = null;",
            "  this.tail = null;",
            "  // 请把你的代码写在这条注释以下",
            "  // 请把你的代码写在这条注释以上",
            "};"
          ],
          "head": [],
          "tail": [
            "DoublyLinkedList.prototype = {",
            "  print() {",
            "    if (this.head == null) {",
            "      return null;",
            "    } else {",
            "      var result = new Array();",
            "      var node = this.head;",
            "      while (node.next != null) {",
            "        result.push(node.data);",
            "        node = node.next;",
            "      };",
            "      result.push(node.data);",
            "      return result;",
            "    };",
            "  },",
            "  printReverse() {",
            "    if (this.tail == null) {",
            "      return null;",
            "    } else {",
            "      var result = new Array();",
            "      var node = this.tail;",
            "      while (node.prev != null) {",
            "        result.push(node.data);",
            "        node = node.prev;",
            "      };",
            "      result.push(node.data);",
            "      return result;",
            "    };",
            "  } ",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d825a367417b2b2512c88",
      "title": "Reverse a Doubly Linked List",
      "description": [
        "现在我们来为双向链表创建一个<code>reverse</code>方法，该方法可以反转链表中的元素。在该方法执行后，head 指针应该指向链表尾部，tail 指针则应指向链表头部。此时，如果我们从头到尾遍历链表，则新的链表中节点顺序应与原链表中节点顺序相反。当试图反转一个空链表时，该方法应该返回 null。"
      ],
      "tests": [
        {
          "text": "应该存在双向链表。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; return (typeof test == 'object')})(), '应该存在双向链表。');"
        },
        {
          "text": "双向链表应该有 add 方法。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; if (test.add == undefined) { return false; }; return (typeof test.add == 'function')})(), '该双向链表应该有 add 方法。');"
        },
        {
          "text": "双向链表应该有 reverse 方法。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; if (test.reverse == undefined) { return false; }; return (typeof test.reverse == 'function')})(), '该双向链表应该有 reverse 方法。');"
        },
        {
          "text": "试图反转一个空链表时应返回 null。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; return (test.reverse() == null); })(), '试图反转一个空链表时应返回 null。');"
        },
        {
          "text": "reverse 方法应反转整个链表。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; test.add(58); test.add(61); test.add(32); test.reverse(); return (test.print().join('') == '326158'); })(), 'reverse 方法应反转整个链表。');"
        },
        {
          "text": "在整个表被反转后，表中每个元素的 next 和 previous 指针都应该存在。",
          "testString": "assert((function() { var test = false; if (typeof DoublyLinkedList !== 'undefined') { test = new DoublyLinkedList() }; test.add(11); test.add(22); test.add(33); test.reverse(); return (test.printReverse().join('') == '112233'); })(), '在整个表被反转后，表中每个元素的 next 和 previous 指针都应该存在。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var Node = function(data, prev) {",
            "  this.data = data;",
            "  this.prev = prev;",
            "  this.next = null;",
            "};",
            "var DoublyLinkedList = function() {",
            "  this.head = null;",
            "  this.tail = null;",
            "  // 请把你的代码写在这条注释以下",
            "  // 请把你的代码写在这条注释以上",
            "};"
          ],
          "head": [],
          "tail": [
            "DoublyLinkedList.prototype = {",
            "  add(data) {",
            "    if (this.head == null) {",
            "      this.head = new Node(data, null);",
            "      this.tail = this.head;",
            "    } else {",
            "      var node = this.head;",
            "      var prev = null;",
            "      while (node.next != null) {",
            "        prev = node;",
            "        node = node.next;",
            "      };",
            "      var newNode = new Node(data, node);",
            "      node.next = newNode;",
            "      this.tail = newNode;",
            "    };",
            "  },",
            "  print() {",
            "    if (this.head == null) {",
            "      return null;",
            "    } else {",
            "      var result = new Array();",
            "      var node = this.head;",
            "      while (node.next != null) {",
            "        result.push(node.data);",
            "        node = node.next;",
            "      };",
            "      result.push(node.data);",
            "      return result;",
            "    };",
            "  },",
            "  printReverse() {",
            "    if (this.tail == null) {",
            "      return null;",
            "    } else {",
            "      var result = new Array();",
            "      var node = this.tail;",
            "      while (node.prev != null) {",
            "        result.push(node.data);",
            "        node = node.prev;",
            "      };",
            "      result.push(node.data);",
            "      return result;",
            "    };",
            "  }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8256367417b2b2512c7a",
      "title": "Find the Minimum and Maximum Value in a Binary Search Tree",
      "description": [
        "在接下来的挑战中，我们来学习 tree（树）这种数据结构。在计算机科学中，树是一种很重要且常用的数据结构。之所以将这种数据结构称为树，是因为其结构很像真实生活中的树。树有一个叫做根节点（root node，可以类比树根）的初始节点，从根节点开始，通过分支（branch，可以类比树枝）链接其子节点，子节点又可以有其他的子节点，以此类推。如果要把这种数据结构画出来，一般会在最上面画根节点，就好象把真实世界中的树倒置过来。",
        "首先，我们介绍几个树这种数据结构中的常见概念。根节点是树中最顶端的节点，即树的开始；树中的每个数据称为节点（node）；指向其他节点的节点称为父级节点（parent node），被指向的节点称为子节点（child node）。还有一些概念，你应该可以望文生义。子树指的是一个节点下所有的子级节点（注意，包含子级的子级，等等）；分支也可以叫做边缘（edges），叶子节点（leaf node）是指没有子节点的节点。其实，树本身是一种递归性的数据结构。也就是说，任何一个的子节点都是它们子树的父节点。在我们为树的操作设计算法时，一定要注意树的递归特性。",
        "首先，我们来学习一种特殊的树——二叉树（binary tree）。更准确地说，我们现在要学的是二叉树中的一种特殊的类型——二叉查找树（binary search tree），我们先来解释一些概念。通常的树形数据结构中，一个节点可以有任意数量的分支。但二叉树中，每个节点最多只能有两个分支。此外，二叉查找树的子树会按一定规则排列，即每个节点左子树上的数值都小于等于该节点的数值；而每个节点右子树上的数值都大于等于该节点的数值。下面的图就代表一个二叉查找树，应该会对你理解这种数据类型有帮助：",
        "<div style='width: 100%; display: flex; justify-content: center; align-items: center;'><img style='width: 100%; max-width: 350px;' src='https://user-images.githubusercontent.com/18563015/32136009-1e665d98-bbd6-11e7-9133-63184f9f9182.png'></div>",
        "子树的排列方式已经很直观了。你可以注意到根节点 8 左边的子树节点值都小于 8，而右边的值则都大于 8。而且，这种数值间的关系对于任何节点的子树都是成立的。例如，8 的左子树的根节点数值为 3，该节点有两个子节点——根据二叉查找树的规则，我们无需查看便可以知道左子树的各节点数值都小于 3，而右子树的各节点数值都大于 3，以此类推。",
        "二叉查找树之所以有用且高效，是因为常用的操作比如查找元素、插入元素、删除元素等，需要的时间为对数级。如果你不理解这样的优势，可以与数组做个对比。对于一个长度为 n 的数组，找到元素的时间在 1（即第一个元素就是要找的）到 n（即最后一个元素才是要找的）之间。在寻找期间，我们没法跳过任何一个元素，只能一直往下，单向地寻找。因此我们说，在数组中找元素这个操作所需时间是与数组长度 n 线性相关的，它的时间复杂度我们记为 O(n)。而对于二叉查找树，我们只要比较当前节点与要找的数的大小，就可以知道该往左还是往右继续寻找。因此，在寻找元素的过程中，每一步都可以排除掉当前数据量的一半，我们可以用 0.5（代表一半）的 k（代表找到元素需要的步数）次方来表示。所以，对于总节点数为 n 的二叉查找树，找到一个元素所需步数 k 就是 log(2)n，即以 2 为底，n 的对数，排除一些不相干的因素（电脑性能，温度之类的），所需步数越多，时间也就越长，且两者线性相关。于是，它的时间复杂度我们可以记为 O(log(n))。注意，在 big O notation 中，常数是可以忽略的。至于 O(n) 到 O(log(n)) 是多大的提升，请你在纸上画出 y = x 和 y = log(2)x 的函数图像，然后你就懂了。如果看不明白上面的内容，请先去了解一下 big O notation 这种表示方式，在学习数据结构和算法时会经常提及。",
        "挑战说明：我们先来做一个简单任务。我们已经在右边写好了二叉查找树的基本结构，其中我们定义了用来创建树中节点的函数。注意，每个节点都可能有左节点和右节点，而且我们可以给这些节点赋一个子树。现在我们需要在二叉查找树中定义<code>findMin</code>和<code>findMax</code>两个方法，它们应分别返回树中的最小值和最大值。你现在不需要考虑如何往树中添加节点，我们已经在后台为你实现了。如果你写不出，请回忆下二叉查找树的这一规律：左子树上的数值总是小于等于父节点的数值，而右子树上的数值总是大于等于父节点的数值。我们同时需要注意的是树中只会存储整数值。还有，如果树为空的话，所有方法都应该返回<code>null</code>。"
      ],
      "tests": [
        {
          "text": "<code>BinarySearchTree</code>数据结构应该存在。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');"
        },
        {
          "text": "<code>BinarySearchTree</code>应该有<code>findMin</code>方法。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.findMin == 'function')})(), '<code>BinarySearchTree</code>应该有<code>findMin</code>方法。');"
        },
        {
          "text": "<code>BinarySearchTree</code>应该有<code>findMax</code>方法。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.findMax == 'function')})(), '<code>BinarySearchTree</code>应该有<code>findMax</code>方法。');"
        },
        {
          "text": "<code>findMin</code>方法应该返回二叉查找树中的最小值。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMin !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return test.findMin() == 1; })(), '<code>findMin</code>方法返回二叉查找树中的最小值。');"
        },
        {
          "text": "<code>findMax</code>方法应该返回二叉查找树中的最大值。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMax !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return test.findMax() == 87; })(), '<code>findMax</code>方法返回二叉查找树中的最大值。');"
        },
        {
          "text": "当树为空时，<code>findMin</code>和<code>findMax</code>方法应该返回<code>null</code>。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMin !== 'function') { return false; }; if (typeof test.findMax !== 'function') { return false; }; return (test.findMin() == null && test.findMax() == null) })(), '当树为空时，<code>findMin</code>和<code>findMax</code>方法应该返回<code>null</code>。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "    this.value = value;",
            "    this.left = null;",
            "    this.right = null;",
            "}",
            "function BinarySearchTree() {",
            "    this.root = null;",
            "    // 请把你的代码写在这条注释以下",
            "    // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    add: function(value) {",
            "        var node = this.root;",
            "        if (node == null) {",
            "          this.root = new Node(value);",
            "          return;",
            "        } else {",
            "            function searchTree(node) {",
            "                if (value < node.value) {",
            "                    if (node.left == null) {",
            "                        node.left = new Node(value);",
            "                        return;",
            "                    } else if (node.left != null) {",
            "                        return searchTree(node.left)",
            "                    };",
            "                } else if (value > node.value) {",
            "                    if (node.right == null) {",
            "                        node.right = new Node(value);",
            "                        return;",
            "                    } else if (node.right != null) {",
            "                        return searchTree(node.right);",
            "                    };",
            "                } else {",
            "                    return null;",
            "                };",
            "            };",
            "            return searchTree(node);",
            "        };",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8257367417b2b2512c7b",
      "title": "Add a New Element to a Binary Search Tree",
      "description": [
        "相信你现在已经对二叉树有了基本的了解，我们来试着写一个稍复杂的方法。",
        "在本次挑战中，我们需要创建一个方法<code>add</code>，该方法可以把新节点添加到二叉查找树中。注意二叉查找树的原则：左子树上的数值应该小于等于父节点数值，而右子树上的数值应该大于等于父节点数值。同时，我们应保证树中的所有数值唯一，即不存在重复值。如果试图往树中添加已经存在的值，add 方法应该返回<code>null</code>。反之，如果成功添加元素，add 方法应返回<code>undefined</code>。",
        "提示：树天然就是一种递归型的数据结构！"
      ],
      "tests": [
        {
          "text": "<code>BinarySearchTree</code>数据结构应该存在。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');"
        },
        {
          "text": "<code>BinarySearchTree</code>应该有<code>add</code>方法。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.add == 'function')})(), '<code>BinarySearchTree</code>应该有<code>add</code>方法。');"
        },
        {
          "text": " add 方法应在遵循二叉查找树原则的前提下添加元素。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.add !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return (test.isBinarySearchTree()); })(), ' add 方法应在遵循二叉查找树原则的前提下添加元素。');"
        },
        {
          "text": "如果添加已经存在的元素，add 方法应该返回<code>null</code>。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.add !== 'function') { return false; }; test.add(4); return test.add(4) == null; })(), '如果添加已经存在的元素，add 方法应该返回<code>null</code>。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "    this.value = value;",
            "    this.left = null;",
            "    this.right = null;",
            "}",
            "function BinarySearchTree() {",
            "    this.root = null;",
            "    // 请把你的代码写在这条注释以下",
            "    // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    isBinarySearchTree() {",
            "        if (this.root == null) {",
            "            return null;",
            "        } else {",
            "            var check = true;",
            "            function checkTree(node) {",
            "                if (node.left != null) {",
            "                    var left = node.left;",
            "                    if (left.value > node.value) {",
            "                        check = false;",
            "                    } else {",
            "                        checkTree(left);",
            "                    }",
            "                }",
            "                if (node.right != null) {",
            "                    var right = node.right;",
            "                    if (right.value < node.value) {",
            "                        check = false;",
            "                    } else {",
            "                        checkTree(right);",
            "                    };",
            "                };",
            "            };",
            "            checkTree(this.root);",
            "            return check;",
            "        };",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8257367417b2b2512c7c",
      "title": "Check if an Element is Present in a Binary Search Tree",
      "description": [
        "现在我们来进一步学习二叉树。对于查找、插入和删除这些操作，二叉查找树的平均时间复杂度是对数级的，这一点我们已经在前面的挑战中提到了。然而极端的情况下，它也可以消耗线性级的时间。",
        "那么极端的情况是什么样子的呢？试想一个由<code>10</code>、<code>12</code>、<code>17</code>、<code>25</code>这些值组成的二叉查找树。根据二叉查找树的定义，<code>12</code>会添加到<code>10</code>的右边，<code>17</code>会添加到<code>12</code>的右边，而<code>25</code>也会添加到<code>17</code>的右边，现在我们的树结构就像链表一样。那么，为了找到<code>25</code>这个值，我们就需要遍历完所有的元素，这就是最坏的情况。问题的症结在于该树结构是不平衡的。我们会在接下来的挑战逐步说明这意味着什么。",
        "挑战说明：在本次挑战中，我们来为二叉查找树添加一个功能。请编写一个<code>isPresent</code>方法，该方法接收一个整数为参数，并返回一个布尔值，用来表示这个数值是否在该二叉查找树中存在。"
      ],
      "tests": [
        {
          "text": "<code>BinarySearchTree</code>数据结构应该存在。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');"
        },
        {
          "text": "<code>BinarySearchTree</code>应该有<code>isPresent</code>方法。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.isPresent == 'function')})(), '<code>BinarySearchTree</code>应该有<code>isPresent</code>方法。');"
        },
        {
          "text": "<code>isPresent</code>方法应该可以检查某个元素在树结构中是否存在。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.isPresent !== 'function') { return false; }; test.add(4); test.add(7); test.add(411); test.add(452); return ( test.isPresent(452) && test.isPresent(411) && test.isPresent(7) && !test.isPresent(100) ); })(), '<code>isPresent</code>方法应该可以检查某个元素在树结构中是否存在。');"
        },
        {
          "text": "<code>isPresent</code>方法应该可以处理树结构为空的情况。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.isPresent !== 'function') { return false; }; return test.isPresent(5) == false; })(), '<code>isPresent</code>方法应该可以处理树结构为空的情况。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "    this.value = value;",
            "    this.left = null;",
            "    this.right = null;",
            "}",
            "function BinarySearchTree() {    ",
            "    this.root = null;",
            "    // 请把你的代码写在这条注释以下",
            "    // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    add: function(value) {",
            "        var node = this.root;",
            "        if (node == null) {",
            "          this.root = new Node(value);",
            "          return;",
            "        } else {",
            "            function searchTree(node) {",
            "                if (value < node.value) {",
            "                    if (node.left == null) {",
            "                        node.left = new Node(value);",
            "                        return;",
            "                    } else if (node.left != null) {",
            "                        return searchTree(node.left)",
            "                    };",
            "                } else if (value > node.value) {",
            "                    if (node.right == null) {",
            "                        node.right = new Node(value);",
            "                        return;",
            "                    } else if (node.right != null) {",
            "                        return searchTree(node.right);",
            "                    };",
            "                } else {",
            "                    return null;",
            "                };",
            "            };",
            "            return searchTree(node);",
            "        };",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8257367417b2b2512c7d",
      "title": "Find the Minimum and Maximum Height of a Binary Search Tree",
      "description": [
        "在上一个挑战中我们提到了树结构不平衡的情况。为了理解平衡的概念，我们来了解一下树的另一个概念：高度（height）。树的高度表示从根节点到叶子结点的距离。如果一个树有很多分支，那么不同的路径（即从根节点到一个子节点的线路）就会有不同的高度。然而，对于一个给定的树，高度一定会有确切的最大值和最小值。如果树是平衡的，最大值和最小值的差值不会超过 1。这意味着在平衡树中，所有的叶子结点都处在同一层级，或者至多只相差一个层级。",
        "树的平衡性这个概念十分重要，因为它直接决定树操作的效率高低。例如在上一节挑战当中，我们提到了不平衡树的最坏情况，此时时间复杂度也会达到最高。自平衡树通常用在拥有动态数据集的树结构当中。常见的平衡树有 AVL 树，红黑树以及 B-trees。当因为插入或删除数据导致这些树结构不平衡时，它们都有内部逻辑处理，让树变得平衡。",
        "注意：深度（depth）是一个与高度类似的概念，它指的是某一个节点（注意，不一定是叶子节点）和根节点之间的距离。",
        "挑战说明：请给二叉树编写两个方法：<code>findMinHeight</code>和<code>findMaxHeight</code>。这两个方法应该分别返回二叉树的最小高度和最大高度。如果树为空，则两个方法都应返回 -1。最后，为树结构添加<code>isBalanced</code>方法，该方法根据树结构是否平衡返回<code>true</code>或<code>false</code>。你可以使用前两个方法来编写<code>isBalanced</code>方法。"
      ],
      "tests": [
        {
          "text": "<code>BinarySearchTree</code>数据结构应该存在。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');"
        },
        {
          "text": "<code>BinarySearchTree</code>应该有<code>findMinHeight</code>方法。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.findMinHeight == 'function')})(), '<code>BinarySearchTree</code>应该有<code>findMinHeight</code>方法。');"
        },
        {
          "text": "<code>BinarySearchTree</code>应该有<code>findMaxHeight</code>方法。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.findMaxHeight == 'function')})(), '<code>BinarySearchTree</code>应该有<code>findMaxHeight</code>方法。');"
        },
        {
          "text": "<code>BinarySearchTree</code>应该有<code>isBalanced</code>方法。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.isBalanced == 'function')})(), '<code>BinarySearchTree</code>应该有<code>isBalanced</code>方法。');"
        },
        {
          "text": "<code>findMinHeight</code>方法应返回树的最小高度值。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMinHeight !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return (test.findMinHeight() == 1); })(), '<code>findMinHeight</code>方法应返回树的最小高度值。');"
        },
        {
          "text": "<code>findMaxHeight</code>方法应返回树的最大高度值。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMaxHeight !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return (test.findMaxHeight() == 5); })(), '<code>findMaxHeight</code>方法应返回树的最大高度值。');"
        },
        {
          "text": "当树为空时，<code>findMaxHeight</code>和<code>findMinHeight</code>方法应返回<code>-1</code>。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.findMaxHeight !== 'function') { return false; }; return (test.findMaxHeight() == -1); })(), '当树为空时，<code>findMaxHeight</code>和<code>findMinHeight</code>方法应返回<code>-1</code>。');"
        },
        {
          "text": "当树是平衡状态时，<code>isBalanced</code>方法应返回<code>true</code>。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.isBalanced !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); return test.isBalanced(); })(), '当树是平衡状态时，<code>isBalanced</code>方法应返回<code>true</code>。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "    this.value = value;",
            "    this.left = null;",
            "    this.right = null;",
            "}",
            "function BinarySearchTree() {",
            "    this.root = null;",
            "    // 请把你的代码写在这条注释以下",
            "    // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    add: function(value) {",
            "        var node = this.root;",
            "        if (node == null) {",
            "          this.root = new Node(value);",
            "          return;",
            "        } else {",
            "            function searchTree(node) {",
            "                if (value < node.value) {",
            "                    if (node.left == null) {",
            "                        node.left = new Node(value);",
            "                        return;",
            "                    } else if (node.left != null) {",
            "                        return searchTree(node.left)",
            "                    };",
            "                } else if (value > node.value) {",
            "                    if (node.right == null) {",
            "                        node.right = new Node(value);",
            "                        return;",
            "                    } else if (node.right != null) {",
            "                        return searchTree(node.right);",
            "                    };",
            "                } else {",
            "                    return null;",
            "                };",
            "            };",
            "            return searchTree(node);",
            "        };",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8257367417b2b2512c7e",
      "title": "Use Depth First Search in a Binary Search Tree",
      "description": [
        "我们已经了解了如何在二叉查找树当中找到一个值。但是如果我们只想遍历整棵树呢？或者我们想在一个乱序的树结构中找到一个值又该如何操作呢？接下来我们就介绍一些树的遍历算法。第一个方法就是深度优先（depth-first）查找方法。在深度优先查找当中，需要先走完（遍历完）当前子树，再去遍历下一个子树。我们有三种方式可以实现深度优先查找：",
        "中序（in-order）：先访问最左端节点，然后访问根节点，最后访问最右端节点。",
        "前序（pre-order）：先访问根节点，然后访问子树。",
        "后序（post-order）：先访问子树，最后访问根节点。",
        "我们应该根据树结构中存储数据的类型以及所要查找的值来选择不同的查找方法。对于二叉查找树，中序遍历会按大小顺序返回所有的节点值。",
        "挑战说明：我们需要为二叉查找树添加这三个查找方法。深度优先查找本身就是一种递归操作，只要当前节点存在子节点，遍历就会一直进行到底。只要你能理解这个基本概念，你就可以调整遍历过程中节点的访问顺序，也就可以写出这三种查找方法。例如，在后序遍历中，我们在访问任何父级节点之前需要递归地遍历完它的所有子节点；然而在前序遍历中，遍历完节点的一个分支之后，我们需要先回到父节点，再递归地遍历它的另一个分支。",
        "在树中定义<code>inorder</code>、<code>preorder</code>、<code>postorder</code>方法。三个方法都应该返回一个数组，该数组用于表示树的遍历结果。每个节点返回的都应该是整数值，而非节点本身。以及，如果树为空，那么三个方法都应该返回<code>null</code>。"
      ],
      "tests": [
        {
          "text": "<code>BinarySearchTree</code>数据结构应该存在。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');"
        },
        {
          "text": "<code>BinarySearchTree</code>应该有<code>inorder</code>方法。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.inorder == 'function')})(), '<code>BinarySearchTree</code>应该有<code>inorder</code>方法。');"
        },
        {
          "text": "<code>BinarySearchTree</code>应该有<code>preorder</code>方法。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.preorder == 'function')})(), '<code>BinarySearchTree</code>应该有<code>preorder</code>方法。');"
        },
        {
          "text": "<code>BinarySearchTree</code>应该有<code>postorder</code>方法。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.postorder == 'function')})(), '<code>BinarySearchTree</code>应该有<code>postorder</code>方法。');"
        },
        {
          "text": "<code>inorder</code>方法应返回一个数组，该数组的元素值应是以中序遍历的方式存储进去的。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.inorder !== 'function') { return false; }; test.add(7); test.add(1); test.add(9); test.add(0); test.add(3); test.add(8); test.add(10); test.add(2); test.add(5); test.add(4); test.add(6); return (test.inorder().join('') == '012345678910'); })(), '<code>inorder</code>方法应返回一个数组，该数组的元素值应是以中序遍历的方式存储进去的。');"
        },
        {
          "text": "<code>preorder</code>方法应返回一个数组，该数组的元素值应是以前序遍历的方式存储进去的。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.preorder !== 'function') { return false; }; test.add(7); test.add(1); test.add(9); test.add(0); test.add(3); test.add(8); test.add(10); test.add(2); test.add(5); test.add(4); test.add(6); return (test.preorder().join('') == '710325469810'); })(), '<code>preorder</code>方法应返回一个数组，该数组的元素值应是以前序遍历的方式存储进去的。');"
        },
        {
          "text": "<code>postorder</code>方法应返回一个数组，该数组的元素值应是以后序遍历的方式存储进去的。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.postorder !== 'function') { return false; }; test.add(7); test.add(1); test.add(9); test.add(0); test.add(3); test.add(8); test.add(10); test.add(2); test.add(5); test.add(4); test.add(6); return (test.postorder().join('') == '024653181097'); })(), '<code>postorder</code>方法应返回一个数组，该数组的元素值应是以后序遍历的方式存储进去的。');"
        },
        {
          "text": "当树为空时，<code>inorder</code>方法应返回<code>null</code>。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.inorder !== 'function') { return false; }; return (test.inorder() == null); })(), '当树为空时，<code>inorder</code>方法应返回<code>null</code>。');"
        },
        {
          "text": "当树为空时，<code>preorder</code>方法应返回<code>null</code>。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.preorder !== 'function') { return false; }; return (test.preorder() == null); })(), '当树为空时，<code>preorder</code>方法应返回<code>null</code>。');"
        },
        {
          "text": "当树为空时，<code>postorder</code>方法应返回<code>null</code>。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.postorder !== 'function') { return false; }; return (test.postorder() == null); })(), '当树为空时，<code>postorder</code>方法应返回<code>null</code>。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "    this.value = value;",
            "    this.left = null;",
            "    this.right = null;",
            "}",
            "function BinarySearchTree() {",
            "    this.root = null;",
            "    // 请把你的代码写在这条注释以下",
            "    // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    add: function(value) {",
            "        var node = this.root;",
            "        if (node == null) {",
            "          this.root = new Node(value);",
            "          return;",
            "        } else {",
            "            function searchTree(node) {",
            "                if (value < node.value) {",
            "                    if (node.left == null) {",
            "                        node.left = new Node(value);",
            "                        return;",
            "                    } else if (node.left != null) {",
            "                        return searchTree(node.left)",
            "                    };",
            "                } else if (value > node.value) {",
            "                    if (node.right == null) {",
            "                        node.right = new Node(value);",
            "                        return;",
            "                    } else if (node.right != null) {",
            "                        return searchTree(node.right);",
            "                    };",
            "                } else {",
            "                    return null;",
            "                };",
            "            };",
            "            return searchTree(node);",
            "        };",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8258367417b2b2512c7f",
      "title": "Use Breadth First Search in a Binary Search Tree",
      "description": [
        "现在我们来介绍另一种树结构遍历方法：广度优先（breadth-first）查找。相较于前一节挑战中的深度优先查找方法，在访问下一层之前，广度优先查找方法会先遍历完上一层。通常，广度优先查找算法可以通过队列（queue）来实现。",
        "这种遍历方式的核心思路是发生在根节点入队后的一个循环：首先我们让队列头元素出队并把该出队元素添加到结果中。之后，我们检查这个出队的元素对应的节点是否有子节点。如果有，就把它的子节点都添加到队列。然后，回到开头的出队并添加到结果这一操作。这个过程一直持续到队列为空。因此，一开始我们需要先让树的根节点入队，这样队列才有头元素可以出队。",
        "挑战说明：请为树结构添加一个名为<code>levelOrder</code>的广度优先查找方法。该方法应该通过广度优先查找方式遍历树中的所有数据值。我们需要确保数组中的元素是节点的数值而非节点本身。对于同一层级，子节点应从左至右的顺序遍历。然后，我们再来写一个叫做<code>reverseLevelOrder</code>的方法，该方法以从右至左的顺序遍历同一层级的子节点。"
      ],
      "tests": [
        {
          "text": "<code>BinarySearchTree</code>数据结构应该存在。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');"
        },
        {
          "text": "<code>BinarySearchTree</code>应该有<code>levelOrder</code>方法。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.levelOrder == 'function')})(), '<code>BinarySearchTree</code>应该有<code>levelOrder</code>方法。');"
        },
        {
          "text": "<code>BinarySearchTree</code>应该有<code>reverseLevelOrder</code>方法。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.reverseLevelOrder == 'function')})(), '<code>BinarySearchTree</code>应该有<code>reverseLevelOrder</code>方法。');"
        },
        {
          "text": "<code>levelOrder</code>方法应该以数组形式返回树中所有的数据值，且同一层级的数据顺序应为从左至右。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.levelOrder !== 'function') { return false; }; test.add(7); test.add(1); test.add(9); test.add(0); test.add(3); test.add(8); test.add(10); test.add(2); test.add(5); test.add(4); test.add(6); return (test.levelOrder().join('') == '719038102546'); })(), '<code>levelOrder</code>方法应该以数组形式返回树中所有的数据值，且同一层级的数据顺序应为从左至右。');"
        },
        {
          "text": "<code>reverseLevelOrder</code>方法应该以数组形式返回树中所有的数据值，且同一层级的数据顺序应为从右至左。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.reverseLevelOrder !== 'function') { return false; }; test.add(7); test.add(1); test.add(9); test.add(0); test.add(3); test.add(8); test.add(10); test.add(2); test.add(5); test.add(4); test.add(6); return (test.reverseLevelOrder().join('') == '791108305264'); })(), '<code>reverseLevelOrder</code>方法应该以数组形式返回树中所有的数据值，且同一层级的数据顺序应为从右至左。');"
        },
        {
          "text": "当树为空时，<code>levelOrder</code>方法应返回<code>null</code>。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.levelOrder !== 'function') { return false; }; return (test.levelOrder() == null); })(), '当树为空时，<code>levelOrder</code>方法应返回<code>null</code>。');"
        },
        {
          "text": "当树为空时，<code>reverseLevelOrder</code>方法应返回<code>null</code>。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.reverseLevelOrder !== 'function') { return false; }; return (test.reverseLevelOrder() == null); })(), '当树为空时，<code>reverseLevelOrder</code>方法应返回<code>null</code>。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "    this.value = value;",
            "    this.left = null;",
            "    this.right = null;",
            "}",
            "function BinarySearchTree() {",
            "    this.root = null;",
            "    // 请把你的代码写在这条注释以下",
            "    // 请把你的代码写在这条注释以上",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    add: function(value) {",
            "        var node = this.root;",
            "        if (node == null) {",
            "          this.root = new Node(value);",
            "          return;",
            "        } else {",
            "            function searchTree(node) {",
            "                if (value < node.value) {",
            "                    if (node.left == null) {",
            "                        node.left = new Node(value);",
            "                        return;",
            "                    } else if (node.left != null) {",
            "                        return searchTree(node.left)",
            "                    };",
            "                } else if (value > node.value) {",
            "                    if (node.right == null) {",
            "                        node.right = new Node(value);",
            "                        return;",
            "                    } else if (node.right != null) {",
            "                        return searchTree(node.right);",
            "                    };",
            "                } else {",
            "                    return null;",
            "                };",
            "            };",
            "            return searchTree(node);",
            "        };",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8258367417b2b2512c80",
      "title": "Delete a Leaf Node in a Binary Search Tree",
      "description": [
        "在接下来的三个挑战中，我们实现二叉查找树中更为复杂的操作——删除。之所以说删除操作很复杂，是因为移除节点会破坏树中已经建立好的连接。为了保证树结构的完整性，这些连接必须周密地重新建立，某些删除操作甚至可能导致树的所有节点都需要重排。对于删除树中的节点，我们可以根据要删除的节点类型，来分以下三种情况讨论：",
        "叶子节点：要删除的节点没有子节点。",
        "一个子节点：要删除的节点只有一个子节点。",
        "两个子节点：要删除的节点有两个子节点。",
        "移除叶子节点很简单，直接删除即可。删除拥有一个子节点的节点也相对简单，我们直接移除该节点，并让其父节点指向这个被删除节点的子节点即可。移除拥有两个子节点的节点就比较困难，因为我们需要让被移除节点的两个子节点重新连上被移除节点的父节点，我们会在第三节挑战当中学习如何处理这种情况。此外，在执行删除操作时，我们需要考虑一些极端情况。如果树为空该怎么处理？如果删除的是根节点又该如何处理？如果树结构中只有两个元素该怎么办？现在我们就来熟悉一下第一种情况，如何删除一个叶子节点。",
        "挑战说明：在二叉树中创建<code>remove</code>方法，我们需要为删除操作设计内部逻辑。首先，我们在<code>remove</code>方法中需要创建一个函数，来从树中找出我们想要删除的那个节点。如果树结构当中不存在该节点，则<code>remove</code>方法应返回<code>null</code>；如果要删除的目标节点是叶子结点（无子节点），其父节点就应该指向<code>null</code>。这样做可以很高效地从树结构中删除节点。我们还需要一个方法检测某一个节点的子节点数量，因为我们需要据此决定采取哪种删除策略。",
        "我们会在之后的两个挑战中处理后面的两个情况。一起加油！"
      ],
      "tests": [
        {
          "text": "<code>BinarySearchTree</code>数据结构应该存在。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');"
        },
        {
          "text": "<code>BinarySearchTree</code>应该有<code>remove</code>方法。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.remove == 'function')})(), '<code>BinarySearchTree</code>应该有<code>remove</code>方法。');"
        },
        {
          "text": "试图移除不存在的元素时，<code>remove</code>方法应返回<code>null</code>。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; return (test.remove(100) == null); })(), '试图移除不存在的元素时，<code>remove</code>方法应返回<code>null</code>。');"
        },
        {
          "text": "如果根节点无子节点，那么删除此节点之后应将该根节点设置为<code>null</code>。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(500); test.remove(500); return (test.inorder() == null); })(), '如果根节点无子节点，那么删除此节点之后应将该根节点设置为<code>null</code>。');"
        },
        {
          "text": "<code>remove</code>方法应可以从树结构中删除叶子节点。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(5); test.add(3); test.add(7); test.add(6); test.add(10); test.add(12); test.remove(3); test.remove(12); test.remove(10); return (test.inorder().join('') == '567'); })(), '<code>remove</code>方法应可以从树结构中删除叶子节点。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "    this.value = value;",
            "    this.left = null;",
            "    this.right = null;",
            "}",
            "",
            "function BinarySearchTree() {",
            "    this.root = null;",
            "    // 情况 1：要删除的节点没有子节点。请把你的代码写在这条注释以下",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    add: function(value) {",
            "        var node = this.root;",
            "        if (node == null) {",
            "          this.root = new Node(value);",
            "          return;",
            "        } else {",
            "            function searchTree(node) {",
            "                if (value < node.value) {",
            "                    if (node.left == null) {",
            "                        node.left = new Node(value);",
            "                        return;",
            "                    } else if (node.left != null) {",
            "                        return searchTree(node.left)",
            "                    };",
            "                } else if (value > node.value) {",
            "                    if (node.right == null) {",
            "                        node.right = new Node(value);",
            "                        return;",
            "                    } else if (node.right != null) {",
            "                        return searchTree(node.right);",
            "                    };",
            "                } else {",
            "                    return null;",
            "                };",
            "            };",
            "            return searchTree(node);",
            "        };",
            "    },",
            "    inorder: function() {",
            "        if (this.root == null) {",
            "          return null;",
            "        } else {",
            "          var result = new Array();",
            "          function traverseInOrder(node) {",
            "              if (node.left != null) {",
            "                  traverseInOrder(node.left);",
            "              };",
            "              result.push(node.value);",
            "              if (node.right != null) {",
            "                  traverseInOrder(node.right);",
            "              };",
            "          }",
            "          traverseInOrder(this.root);",
            "          return result;",
            "        };",
            "    },    ",
            "    isBinarySearchTree() {",
            "        if (this.root == null) {",
            "            return null;",
            "        } else {",
            "            var check = true;",
            "            function checkTree(node) {",
            "                if (node.left != null) {",
            "                    var left = node.left;",
            "                    if (left.value > node.value) {",
            "                        check = false;",
            "                    } else {",
            "                        checkTree(left);",
            "                    }",
            "                }",
            "                if (node.right != null) {",
            "                    var right = node.right;",
            "                    if (right.value < node.value) {",
            "                        check = false;",
            "                    } else {",
            "                        checkTree(right);",
            "                    };",
            "                };",
            "            };",
            "            checkTree(this.root);",
            "            return check;",
            "        }",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8258367417b2b2512c81",
      "title": "Delete a Node with One Child in a Binary Search Tree",
      "description": [
        "现在我们已经知道如何删除一个叶子结点了。在这个挑战中，我们来接着尝试删除有一个子节点的节点。比如，对于一个结构为 1 - 2 - 3 的树，它有三个节点：其中 1 是根节点。现在如果我们要删除节点 2，那直接让节点 1 指向节点 3 即可。通常，删除只有一个子节点的节点时，我们只需要让该节点的父节点指向该节点的子节点即可。",
        "挑战说明：我们已经在右边为你写好了<code>remove</code>方法，其中还包含了上一个挑战的实现。与之前的题目描述一样，我们找到需要删除的节点以及其父节点，然后用定义好的方法判断出该节点拥有的子节点数量。现在我们来处理删除仅有一个子节点的节点的情况。首先，我们需要知道这一个子节点是左分支还是右分支，然后才能让被删除节点的父节点的合适分支来指向该节点的子节点。此外，我们需要考虑当删除的节点为根节点的情况，这意味着父节点的值是<code>null</code>。当然，如果你觉得提供给你的代码不够好，也可以用你自己写的版本。"
      ],
      "tests": [
        {
          "text": "<code>BinarySearchTree</code>数据结构应该存在。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');"
        },
        {
          "text": "<code>BinarySearchTree</code>应该有<code>remove</code>方法。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.remove == 'function')})(), '<code>BinarySearchTree</code>应该有<code>remove</code>方法。');"
        },
        {
          "text": "当试图移除一个不存在的元素时，方法应返回<code>null</code>。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; return (test.remove(100) == null); })(), '当试图移除一个不存在的元素时，方法应返回<code>null</code>。');"
        },
        {
          "text": "如果根节点无子节点，那么删除此节点之后应将该根节点设置为<code>null</code>。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(500); test.remove(500); return (test.inorder() == null); })(), '如果根节点无子节点，那么删除此节点之后应将该根节点设置为<code>null</code>。');"
        },
        {
          "text": "<code>remove</code>方法应可以移除树结构中的叶子结点。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(5); test.add(3); test.add(7); test.add(6); test.add(10); test.add(12); test.remove(3); test.remove(12); test.remove(10); return (test.inorder().join('') == '567'); })(), '<code>remove</code>方法应可以移除树结构中的叶子结点。');"
        },
        {
          "text": "<code>remove</code>方法应可以移除拥有一个子节点的节点。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(-1); test.add(3); test.add(7); test.add(16); test.remove(16); test.remove(7); test.remove(3); return (test.inorder().join('') == '-1'); })(), '<code>remove</code>方法应可以移除拥有一个子节点的节点。');"
        },
        {
          "text": "移除树结构中拥有两个子节点的根节之后，另一个子节点应成为树的根节点。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(15); test.add(27); test.remove(15); return (test.inorder().join('') == '27'); })(), '移除树结构中拥有两个子节点的根节之后，另一个子节点应成为树的根节点。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "  this.value = value;",
            "  this.left = null;",
            "  this.right = null;",
            "}",
            "",
            "function BinarySearchTree() {",
            "  this.root = null;",
            "  this.remove = function(value) {",
            "    if (this.root === null) {",
            "      return null;",
            "    }",
            "    var target;",
            "    var parent = null;",
            "    // 找出要删除的节点及其父节点",
            "    (function findValue(node = this.root) {",
            "      if (value == node.value) {",
            "        target = node;",
            "      } else if (value < node.value && node.left !== null) {",
            "        parent = node;",
            "        return findValue(node.left);",
            "      } else if (value < node.value && node.left === null) {",
            "        return null;",
            "      } else if (value > node.value && node.right !== null) {",
            "        parent = node;",
            "        return findValue(node.right);",
            "      } else {",
            "        return null;",
            "      }",
            "    }).bind(this)();",
            "    if (target === null) {",
            "      return null;",
            "    }",
            "    // 获取要删除节点的子节点数量",
            "    var children = (target.left !== null ? 1 : 0) + (target.right !== null ? 1 : 0);",
            "    // 情况 1：要删除的节点没有子节点",
            "    if (children === 0) {",
            "      if (target == this.root) {",
            "        this.root = null;",
            "      }",
            "      else {",
            "        if (parent.left == target) {",
            "          parent.left = null;",
            "        } else {",
            "          parent.right = null;",
            "        }",
            "      }",
            "    }",
            "    // 情况 2：要删除的节点只有一个子节点，请把你的代码写在这条注释以下",
            "  };",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    add: function(value) {",
            "        var node = this.root;",
            "        if (node == null) {",
            "          this.root = new Node(value);",
            "          return;",
            "        } else {",
            "            function searchTree(node) {",
            "                if (value < node.value) {",
            "                    if (node.left == null) {",
            "                        node.left = new Node(value);",
            "                        return;",
            "                    } else if (node.left != null) {",
            "                        return searchTree(node.left)",
            "                    };",
            "                } else if (value > node.value) {",
            "                    if (node.right == null) {",
            "                        node.right = new Node(value);",
            "                        return;",
            "                    } else if (node.right != null) {",
            "                        return searchTree(node.right);",
            "                    };",
            "                } else {",
            "                    return null;",
            "                };",
            "            };",
            "            return searchTree(node);",
            "        };",
            "    },",
            "    inorder: function() {",
            "        if (this.root == null) {",
            "          return null;",
            "        } else {",
            "          var result = new Array();",
            "          function traverseInOrder(node) {",
            "              if (node.left != null) {",
            "                  traverseInOrder(node.left);",
            "              };",
            "              result.push(node.value);",
            "              if (node.right != null) {",
            "                  traverseInOrder(node.right);",
            "              };",
            "          }",
            "          traverseInOrder(this.root);",
            "          return result;",
            "        };",
            "    },    ",
            "    isBinarySearchTree() {",
            "        if (this.root == null) {",
            "            return null;",
            "        } else {",
            "            var check = true;",
            "            function checkTree(node) {",
            "                if (node.left != null) {",
            "                    var left = node.left;",
            "                    if (left.value > node.value) {",
            "                        check = false;",
            "                    } else {",
            "                        checkTree(left);",
            "                    }",
            "                }",
            "                if (node.right != null) {",
            "                    var right = node.right;",
            "                    if (right.value < node.value) {",
            "                        check = false;",
            "                    } else {",
            "                        checkTree(right);",
            "                    };",
            "                };",
            "            };",
            "            checkTree(this.root);",
            "            return check;",
            "        }",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8258367417b2b2512c82",
      "title": "Delete a Node with Two Children in a Binary Search Tree",
      "description": [
        "移除拥有两个子节点的节点是最难处理的情况，因为移除这种节点会让它的两个子树独立。我们该如何重连这两个子树呢？一种方法是找到需要删除节点的右子树中的最小值，并把这个最小值复制到被删除的那个节点。以这种方式选择的新节点，它的值一定会大于它左子树中所有节点的值；同时这个新节点的值也一定会小于它右子树中所有节点的值。",
        "在复制操作之后，我们还需要把它从右子树移除。需要注意的是，我们现在要删除的这个节点可能是右子树的叶子节点，也可能是这个节点本身还存在子树。如果这个节点是叶子结点，那我们就只须移除其父节点和它的连接。否则，我们就需要让这个节点的父节点指向这个节点的右子树。如果你不明白这个逻辑，请自己尝试画一个图。",
        "挑战说明：现在我们要处理第三种情况以完善<code>remove</code>方法。我们已经为你写好了之前两种情况的代码，现在请你来编写删除拥有两个子节点的节点的代码。同时，别忘了考虑极端情况，比如树结构中只有三个节点的情况。解决了这种情况也就意味着我们彻底完成了二叉查找树中的删除操作。这是一个很难的问题，解决它是一个不小的成就。"
      ],
      "tests": [
        {
          "text": "<code>BinarySearchTree</code>数据结构应该存在。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), '<code>BinarySearchTree</code>数据结构应该存在。');"
        },
        {
          "text": "<code>BinarySearchTree</code>应该有<code>remove</code>方法。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.remove == 'function')})(), '<code>BinarySearchTree</code>应该有<code>remove</code>方法。');"
        },
        {
          "text": "试图移除一个不存在的元素，方法应返回<code>null</code>。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.remove == 'function') ? (test.remove(100) == null) : false})(), '试图移除一个不存在的元素，方法应返回<code>null</code>。');"
        },
        {
          "text": "如果根节点是树中唯一的节点，则删除时应将其设置为<code>null</code>。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; test.add(500); test.remove(500); return (typeof test.remove == 'function') ? (test.inorder() == null) : false})(), '如果根节点是树中唯一的节点，则删除时应将其设置为<code>null</code>。');"
        },
        {
          "text": "<code>remove</code>方法应可以从树中移除叶子节点。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; test.add(5); test.add(3); test.add(7); test.add(6); test.add(10); test.add(12); test.remove(3); test.remove(12); test.remove(10); return (typeof test.remove == 'function') ? (test.inorder().join('') == '567') : false})(), '<code>remove</code>方法应可以从树中移除叶子节点。');"
        },
        {
          "text": "<code>remove</code>方法应可以移除有一个子节点的节点。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(-1); test.add(3); test.add(7); test.add(16); test.remove(16); test.remove(7); test.remove(3); return (test.inorder().join('') == '-1'); })(), '<code>remove</code>方法应可以移除有一个子节点的节点。');"
        },
        {
          "text": "移除根节点应会让另一个节点成为根节点。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(15); test.add(27); test.remove(15); return (test.inorder().join('') == '27'); })(), '移除根节点应会让另一个节点成为根节点。');"
        },
        {
          "text": "<code>remove</code>方法应可以在不破坏二叉查找树结构的前提下，移除拥有两个子节点的节点。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(1); test.add(4); test.add(3); test.add(7); test.add(9); test.add(11); test.add(14); test.add(15); test.add(19); test.add(50); test.remove(9); if (!test.isBinarySearchTree()) { return false; }; test.remove(11); if (!test.isBinarySearchTree()) { return false; }; test.remove(14); if (!test.isBinarySearchTree()) { return false; }; test.remove(19); if (!test.isBinarySearchTree()) { return false; }; test.remove(3); if (!test.isBinarySearchTree()) { return false; }; test.remove(50); if (!test.isBinarySearchTree()) { return false; }; test.remove(15); if (!test.isBinarySearchTree()) { return false; }; return (test.inorder().join('') == '147'); })(), '<code>remove</code>方法应可以在不破坏二叉查找树结构的前提下，移除拥有两个子节点的节点。');"
        },
        {
          "text": "只有三个节点的树结构的根节点也应可以被移除。",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.remove !== 'function') { return false; }; test.add(100); test.add(50); test.add(300); test.remove(100); return (test.inorder().join('') == 50300); })(), '只有三个节点的树结构的根节点也应可以被移除。');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "  this.value = value;",
            "  this.left = null;",
            "  this.right = null;",
            "}",
            "",
            "function BinarySearchTree() {",
            "  this.root = null;",
            "  this.remove = function(value) {",
            "    if (this.root === null) {",
            "      return null;",
            "    }",
            "    var target;",
            "    var parent = null;",
            "    // 找出要删除的节点及其父节点",
            "    (function findValue(node = this.root) {",
            "      if (value == node.value) {",
            "        target = node;",
            "      } else if (value < node.value && node.left !== null) {",
            "        parent = node;",
            "        return findValue(node.left);",
            "      } else if (value < node.value && node.left === null) {",
            "        return null;",
            "      } else if (value > node.value && node.right !== null) {",
            "        parent = node;",
            "        return findValue(node.right);",
            "      } else {",
            "        return null;",
            "      }",
            "    }).bind(this)();",
            "    if (target === null) {",
            "      return null;",
            "    }",
            "    // 获取要删除节点的子节点数量",
            "    var children = (target.left !== null ? 1 : 0) + (target.right !== null ? 1 : 0);",
            "    // 情况 1：要删除的节点没有子节点",
            "    if (children === 0) {",
            "      if (target == this.root) {",
            "        this.root = null;",
            "      }",
            "      else {",
            "        if (parent.left == target) {",
            "          parent.left = null;",
            "        } else {",
            "          parent.right = null;",
            "        }",
            "      }",
            "    }",
            "    // 情况 2：要删除的节点只有一个子节点",
            "    else if (children == 1) {",
            "      var newChild = (target.left !== null) ? target.left : target.right;",
            "      if (parent === null) {",
            "        target.value = newChild.value;",
            "        target.left = null;",
            "        target.right = null;",
            "      } else if (newChild.value < parent.value) {",
            "        parent.left = newChild;",
            "      } else {",
            "        parent.right = newChild;",
            "      }",
            "      target = null;",
            "    }",
            "    // 情况 3：要删除的节点有两个子节点，请把你的代码写在这条注释以下",
            "  };",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    add: function(value) {",
            "        var node = this.root;",
            "        if (node == null) {",
            "          this.root = new Node(value);",
            "          return;",
            "        } else {",
            "            function searchTree(node) {",
            "                if (value < node.value) {",
            "                    if (node.left == null) {",
            "                        node.left = new Node(value);",
            "                        return;",
            "                    } else if (node.left != null) {",
            "                        return searchTree(node.left)",
            "                    };",
            "                } else if (value > node.value) {",
            "                    if (node.right == null) {",
            "                        node.right = new Node(value);",
            "                        return;",
            "                    } else if (node.right != null) {",
            "                        return searchTree(node.right);",
            "                    };",
            "                } else {",
            "                    return null;",
            "                };",
            "            };",
            "            return searchTree(node);",
            "        };",
            "    },",
            "    inorder: function() {",
            "        if (this.root == null) {",
            "          return null;",
            "        } else {",
            "          var result = new Array();",
            "          function traverseInOrder(node) {",
            "              if (node.left != null) {",
            "                  traverseInOrder(node.left);",
            "              };",
            "              result.push(node.value);",
            "              if (node.right != null) {",
            "                  traverseInOrder(node.right);",
            "              };",
            "          }",
            "          traverseInOrder(this.root);",
            "          return result;",
            "        };",
            "    },    ",
            "    isBinarySearchTree() {",
            "        if (this.root == null) {",
            "            return null;",
            "        } else {",
            "            var check = true;",
            "            function checkTree(node) {",
            "                if (node.left != null) {",
            "                    var left = node.left;",
            "                    if (left.value > node.value) {",
            "                        check = false;",
            "                    } else {",
            "                        checkTree(left);",
            "                    }",
            "                }",
            "                if (node.right != null) {",
            "                    var right = node.right;",
            "                    if (right.value < node.value) {",
            "                        check = false;",
            "                    } else {",
            "                        checkTree(right);",
            "                    };",
            "                };",
            "            };",
            "            checkTree(this.root);",
            "            return check;",
            "        }",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8259367417b2b2512c83",
      "title": "Invert a Binary Tree",
      "description": [
        "Here will we create a function to invert a binary tree. Given a binary tree, we want to produce a new tree that is equivalently the mirror image of this tree. Running an inorder traversal on an inverted tree will explore the nodes in reverse order when compared to the inorder traversal of the original tree. Write a method to do this called <code>invert</code> on our binary tree. Calling this method should invert the current tree structure. Ideally, we would like to do this in-place in linear time. That is, we only visit each node once and we modify the existing tree structure as we go, without using any additional memory. Good luck!"
      ],
      "tests": [
        {
          "text": "The <code>BinarySearchTree</code> data structure exists.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() }; return (typeof test == 'object')})(), 'The <code>BinarySearchTree</code> data structure exists.');"
        },
        {
          "text": "The binary search tree has a method called <code>invert</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; return (typeof test.invert == 'function')})(), 'The binary search tree has a method called <code>invert</code>.');"
        },
        {
          "text": "The <code>invert</code> method correctly inverts the tree structure.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.invert !== 'function') { return false; }; test.add(4); test.add(1); test.add(7); test.add(87); test.add(34); test.add(45); test.add(73); test.add(8); test.invert(); return test.inorder().join('') == '877345348741'; })(), 'The <code>invert</code> method correctly inverts the tree structure.');"
        },
        {
          "text": "Inverting an empty tree returns <code>null</code>.",
          "testString": "assert((function() { var test = false; if (typeof BinarySearchTree !== 'undefined') { test = new BinarySearchTree() } else { return false; }; if (typeof test.invert !== 'function') { return false; }; return (test.invert() == null); })(), 'Inverting an empty tree returns <code>null</code>.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "function Node(value) {",
            "    this.value = value;",
            "    this.left = null;",
            "    this.right = null;",
            "}",
            "function BinarySearchTree() {",
            "    this.root = null;",
            "    // 请在本行下方输入代码",
            "    // 请在本行上方输入代码",
            "}"
          ],
          "head": [],
          "tail": [
            "BinarySearchTree.prototype = {",
            "    add: function(value) {",
            "        var node = this.root;",
            "        if (node == null) {",
            "          this.root = new Node(value);",
            "          return;",
            "        } else {",
            "            function searchTree(node) {",
            "                if (value < node.value) {",
            "                    if (node.left == null) {",
            "                        node.left = new Node(value);",
            "                        return;",
            "                    } else if (node.left != null) {",
            "                        return searchTree(node.left)",
            "                    };",
            "                } else if (value > node.value) {",
            "                    if (node.right == null) {",
            "                        node.right = new Node(value);",
            "                        return;",
            "                    } else if (node.right != null) {",
            "                        return searchTree(node.right);",
            "                    };",
            "                } else {",
            "                    return null;",
            "                };",
            "            };",
            "            return searchTree(node);",
            "        };",
            "    },",
            "    inorder: function() {",
            "        if (this.root == null) {",
            "          return null;",
            "        } else {",
            "          var result = new Array();",
            "          function traverseInOrder(node) {",
            "              if (node.left != null) {",
            "                  traverseInOrder(node.left);",
            "              };",
            "              result.push(node.value);",
            "              if (node.right != null) {",
            "                  traverseInOrder(node.right);",
            "              };",
            "          }",
            "          traverseInOrder(this.root);",
            "          return result;",
            "        };",
            "    }",
            "};"
          ]
        }
      }
    },
    {
      "id": "587d8259367417b2b2512c84",
      "title": "Create a Trie Search Tree",
      "description": [
        "Here we will move on from binary search trees and take a look at another type of tree structure called a trie. A trie is an ordered search tree commonly used to hold strings, or more generically associative arrays or dynamic datasets in which the keys are strings. They are very good at storing sets of data when many keys will have overlapping prefixes, for example, all the words in a dictionary.",
        "Unlike a binary tree, nodes are not associated with actual values. Instead, the path to a node represents a specific key. For instance, if we wanted to store the string code in a trie, we would have four nodes, one for each letter: c — o — d — e. Following that path through all these nodes will then create code as a string — that path is the key we stored. Then, if we wanted to add the string coding, it would share the first three nodes of code before branching away after the d. In this way, large datasets can be stored very compactly. In addition, search can be very quick because it is effectively limited to the length of the string you are storing. Furthermore, unlike binary trees a node can store any number of child nodes.",
        "As you might have guessed from the above example, some metadata is commonly stored at nodes that hold the end of a key so that on later traversals that key can still be retrieved. For instance, if we added codes in our example above we would need some way to know that the e in code represents the end of a key that was previously entered. Otherwise, this information would effectively be lost when we add codes.",
        "Instructions: Let's create a trie to store words. It will accept words through an add method and store these in a trie data structure. It will also allow us to query if a given string is a word with an isWord method, and retrieve all the words entered into the trie with a print method. isWord should return a boolean value and print should return an array of all these words as string values.",
        "In order for us to verify that this data structure is implemented correctly, we've provided a Node structure for each node in the tree. Each node will be an object with a keys property which is a JavaScript Map object. This will hold the individual letters that are valid keys of each node. We've also created an end property on the nodes that can be set to true if the node represents the termination of a word."
      ],
      "tests": [
        {
          "text": "The Trie has an add method.",
          "testString": "assert((function testTrie() { var test = false; if (typeof Trie !== 'undefined') { test = new Trie() } else { return false; }; return (typeof test.add == 'function') }()), 'The Trie has an add method.');"
        },
        {
          "text": "The Trie has a print method.",
          "testString": "assert((function testTrie() { var test = false; if (typeof Trie !== 'undefined') { test = new Trie() } else { return false; }; return (typeof test.print == 'function') }()), 'The Trie has a print method.');"
        },
        {
          "text": "The Trie has an isWord method.",
          "testString": "assert((function testTrie() { var test = false; if (typeof Trie !== 'undefined') { test = new Trie() } else { return false; }; return (typeof test.isWord == 'function') }()), 'The Trie has an isWord method.');"
        },
        {
          "text": "The print method returns all items added to the trie as strings in an array.",
          "testString": "assert((function testTrie() { var test = false; if (typeof Trie !== 'undefined') { test = new Trie() } else { return false; }; test.add('jump'); test.add('jumps'); test.add('jumped'); test.add('house'); test.add('mouse'); var added = test.print(); return (added.indexOf('jump') != -1 && added.indexOf('jumps') != -1 && added.indexOf('jumped') != -1 && added.indexOf('house') != -1 && added.indexOf('mouse') != -1 && added.length == 5); }()), 'The print method returns all items added to the trie as strings in an array.');"
        },
        {
          "text": "The isWord method returns true only for words added to the trie and false for all other words.",
          "testString": "assert((function testTrie() { var test = false; if (typeof Trie !== 'undefined') { test = new Trie() } else { return false; }; test.add('hop'); test.add('hops'); test.add('hopped'); test.add('hoppy'); test.add('hope'); return (test.isWord('hop') && !test.isWord('ho') && test.isWord('hopped') && !test.isWord('hopp') && test.isWord('hoppy') && !test.isWord('hoping')); }()), 'The isWord method returns true only for words added to the trie and false for all other words.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));",
            "var Node = function() {",
            "  this.keys = new Map();",
            "  this.end = false;",
            "  this.setEnd = function() {",
            "    this.end = true;",
            "  };",
            "  this.isEnd = function() {",
            "    return this.end;",
            "  };",
            "};",
            "var Trie = function() {",
            "  // 请在本行下方输入代码",
            "  // 请在本行上方输入代码",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d825a367417b2b2512c8a",
      "title": "Insert an Element into a Max Heap",
      "description": [
        "Now we will move on to another tree data structure, the binary heap. A binary heap is a partially ordered binary tree which satisfies the heap property. The heap property specifies a relationship between parent and child nodes. You may have a max heap, in which all parent nodes are greater than or equal to their child nodes, or a min heap, in which the reverse is true. Binary heaps are also complete binary trees. This means that all levels of the tree are fully filled and if the last level is partially filled it is filled from left to right.",
        "While binary heaps may be implemented as tree structures with nodes that contain left and right references, the partial ordering according to the heap property allows us to represent the heap with an array. The parent-children relationship is what we're interested in and with simple arithmetic we can compute the children of any parent and the parent of any child node.",
        "For instance, consider this array representation of a binary min heap:",
        "<code>[ 6, 22, 30, 37, 63, 48, 42, 76 ]</code>",
        "The root node is the first element, 6. Its children are 22 and 30. If we look at the relationship between the array indices of these values, for index i the children are 2 * i + 1 and 2 * i + 2. Similarly, the element at index 0 is the parent of these two children at indices 1 and 2. More generally, we can find the parent of a node at any index with the following: (i - 1) / 2. These patterns will hold true as the binary tree grows to any size. Finally, we can make a slight adjustment to make this arithmetic even easier by skipping the first element in the array. Doing this creates the following relationship for any element at a given index i:",
        "Example Array representation:",
        "<code>[ null, 6, 22, 30, 37, 63, 48, 42, 76 ]</code>",
        "An element's left child: i * 2",
        "An element's right child: i * 2 + 1",
        "An element's parent: i / 2",
        "Once you wrap your head around the math, using an array representation is very useful because node locations can be quickly determined with this arithmetic and memory usage is diminished because you don't need to maintain references to child nodes.",
        "Instructions: Here we will create a max heap. Start by just creating an insert method which adds elements to our heap. During insertion, it is important to always maintain the heap property. For a max heap this means the root element should always have the greatest value in the tree and all parent nodes should be greater than their children. For an array implementation of a heap, this is typically accomplished in three steps:",
        "Add the new element to the end of the array.",
        "If the element is larger than its parents, switch them.",
        "Continue switching until the new element is either smaller than its parent or you reach the root of the tree.",
        "Finally, add a print method which returns an array of all the items that have been added to the heap."
      ],
      "tests": [
        {
          "text": "The MaxHeap data structure exists.",
          "testString": "assert((function() { var test = false; if (typeof MaxHeap !== 'undefined') { test = new MaxHeap() }; return (typeof test == 'object')})(), 'The MaxHeap data structure exists.');"
        },
        {
          "text": "MaxHeap has a method called insert.",
          "testString": "assert((function() { var test = false; if (typeof MaxHeap !== 'undefined') { test = new MaxHeap() } else { return false; }; return (typeof test.insert == 'function')})(), 'MaxHeap has a method called insert.');"
        },
        {
          "text": "MaxHeap has a method called print.",
          "testString": "assert((function() { var test = false; if (typeof MaxHeap !== 'undefined') { test = new MaxHeap() } else { return false; }; return (typeof test.print == 'function')})(), 'MaxHeap has a method called print.');"
        },
        {
          "text": "The insert method adds elements according to the max heap property.",
          "testString": "assert((function() { var test = false; if (typeof MaxHeap !== 'undefined') { test = new MaxHeap() } else { return false; }; test.insert(50); test.insert(100); test.insert(700); test.insert(32); test.insert(51); let result = test.print(); return ((result.length == 5) ? result[0] == 700 : result[1] == 700) })(), 'The insert method adds elements according to the max heap property.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var MaxHeap = function() {",
            "  // 请在本行下方输入代码",
            "  // 请在本行上方输入代码",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d825b367417b2b2512c8b",
      "title": "Remove an Element from a Max Heap",
      "description": [
        "Now that we can add elements to our heap let's see how we can remove elements. Removing and inserting elements both require similar logic. In a max heap you will usually want to remove the greatest value, so this involves simply extracting it from the root of our tree. This will break the heap property of our tree, so we must reestablish it in some way. Typically, for a max heap this is done in the following way:",
        "Move the last element in the heap into the root position.",
        "If either child of the root is greater than it, swap the root with the child of greater value.",
        "Continue swapping until the parent is greater than both children, or you reach the last level in the tree.",
        "Instructions: Add a method to our max heap called remove. This method should return the greatest value that has been added to our max heap and remove it from the heap. It should also reorder the heap so the heap property is maintained. After removing an element, the next greatest element remaining in the heap should become the root. Add your insert method again here as well."
      ],
      "tests": [
        {
          "text": "The MaxHeap data structure exists.",
          "testString": "assert((function() { var test = false; if (typeof MaxHeap !== 'undefined') { test = new MaxHeap() }; return (typeof test == 'object')})(), 'The MaxHeap data structure exists.');"
        },
        {
          "text": "MaxHeap has a method called print.",
          "testString": "assert((function() { var test = false; if (typeof MaxHeap !== 'undefined') { test = new MaxHeap() } else { return false; }; return (typeof test.print == 'function')})(), 'MaxHeap has a method called print.');"
        },
        {
          "text": "MaxHeap has a method called insert.",
          "testString": "assert((function() { var test = false; if (typeof MaxHeap !== 'undefined') { test = new MaxHeap() } else { return false; }; return (typeof test.insert == 'function')})(), 'MaxHeap has a method called insert.');"
        },
        {
          "text": "MaxHeap has a method called remove.",
          "testString": "assert((function() { var test = false; if (typeof MaxHeap !== 'undefined') { test = new MaxHeap() } else { return false; }; return (typeof test.remove == 'function')})(), 'MaxHeap has a method called remove.');"
        },
        {
          "text": "The remove method removes the greatest element from the max heap while maintaining the max heap property.",
          "testString": "assert((function() { var test = false; if (typeof MaxHeap !== 'undefined') { test = new MaxHeap() } else { return false; }; test.insert(30); test.insert(300); test.insert(500); test.insert(10); let result = []; result.push(test.remove()); result.push(test.remove()); result.push(test.remove()); result.push(test.remove());  return (result.join('') == '5003003010') })(), 'The remove method removes the greatest element from the max heap while maintaining the max heap property.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var MaxHeap = function() {",
            "  // 请在本行下方输入代码",
            "  // 请在本行上方输入代码",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d825b367417b2b2512c8c",
      "title": "Implement Heap Sort with a Min Heap",
      "description": [
        "Now that we can add and remove elements let's see some of the applications heaps can be used for. Heaps are commonly used to implement priority queues because they always store an item of greatest or least value in first position. In addition, they are used to implement a sorting algorithm called heap sort. We'll see how to do this here. Heap sort uses a min heap, the reverse of a max heap. A min heap always stores the element of least value in the root position.",
        "Heap sort works by taking an unsorted array, adding each item in the array into a min heap, and then extracting every item out of the min heap into a new array. The min heap structure ensures that the new array will contain the original items in least to greatest order. This is one of the most efficient sorting algorithms with average and worst case performance of O(nlog(n)).",
        "Instructions: Let's implement heap sort with a min heap. Feel free to adapt your max heap code here. Create an object MinHeap with insert, remove, and sort methods. The sort method should return an array of all the elements in the min heap sorted from smallest to largest."
      ],
      "tests": [
        {
          "text": "The MinHeap data structure exists.",
          "testString": "assert((function() { var test = false; if (typeof MinHeap !== 'undefined') { test = new MinHeap() }; return (typeof test == 'object')})(), 'The MinHeap data structure exists.');"
        },
        {
          "text": "MinHeap has a method called insert.",
          "testString": "assert((function() { var test = false; if (typeof MinHeap !== 'undefined') { test = new MinHeap() } else { return false; }; return (typeof test.insert == 'function')})(), 'MinHeap has a method called insert.');"
        },
        {
          "text": "MinHeap has a method called remove.",
          "testString": "assert((function() { var test = false; if (typeof MinHeap !== 'undefined') { test = new MinHeap() } else { return false; }; return (typeof test.remove == 'function')})(), 'MinHeap has a method called remove.');"
        },
        {
          "text": "MinHeap has a method called sort.",
          "testString": "assert((function() { var test = false; if (typeof MinHeap !== 'undefined') { test = new MinHeap() } else { return false; }; return (typeof test.sort == 'function')})(), 'MinHeap has a method called sort.');"
        },
        {
          "text": "The sort method returns an array containing all items added to the min heap in sorted order.",
          "testString": "assert((function() { var test = false; if (typeof MinHeap !== 'undefined') { test = new MinHeap() } else { return false; }; test.insert(3); test.insert(12); test.insert(5); test.insert(10); test.insert(1); test.insert(27); test.insert(42); test.insert(57); test.insert(5); var result = test.sort(); return (isSorted(result)); })(), 'The sort method returns an array containing all items added to the min heap in sorted order.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "// check if array is sorted",
            "function isSorted(arr) {",
            "  var check = (i) => (i == arr.length - 1) ? true : (arr[i] > arr[i + 1]) ? false : check(i + 1);",
            "  return check(0);",
            "}",
            "// generate a randomly filled array",
            "var array = new Array();",
            "(function createArray(size = 5) {",
            "  array.push(+(Math.random() * 100).toFixed(0));",
            "  return (size > 1) ? createArray(size - 1) : undefined;",
            "})(25);",
            "var MinHeap = function() {",
            "  // 请在本行下方输入代码",
            "  // 请在本行上方输入代码",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8256367417b2b2512c77",
      "title": "Adjacency List",
      "description": [
        "Graphs can be represented in different ways. Here we describe one way, which is called an <dfn>adjacency list</dfn>.",
        "An adjacency list is essentially a bulleted list where the left side is the node and the right side lists all the other nodes it's connected to. Below is a representation of an adjacency list.",
        "<blockquote>Node1: Node2, Node3<br>Node2: Node1<br>Node3: Node1</blockquote>",
        "Above is an undirected graph because <code>Node1</code> is connected to <code>Node2</code> and <code>Node3</code>, and that information is consistent with the connections <code>Node2</code> and <code>Node3</code> show. An adjacency list for a directed graph would mean each row of the list shows direction. If the above was directed, then <code>Node2: Node1</code> would mean there the directed edge is pointing from <code>Node2</code> towards <code>Node1</code>.",
        "We can represent the undirected graph above as an adjacency list by putting it within a JavaScript object.",
        "<blockquote>var undirectedG = {<br>  Node1: [\"Node2\", \"Node3\"],<br>  Node2: [\"Node1\"],<br>  Node3: [\"Node1\"]<br>};</blockquote>",
        "This can also be more simply represented as an array where the nodes just have numbers rather than string labels.",
        "<blockquote>var undirectedGArr = [<br>  [1, 2], # Node1<br>  [0],    # Node2<br>  [0]     # Node3<br>];</blockquote>",
        "<hr>",
        "Create a social network as an undirected graph with 4 nodes/people named <code>James</code>, <code>Jill</code>, <code>Jenny</code>, and <code>Jeff</code>. There are edges/relationships between James and Jeff, Jill and Jenny, and Jeff and Jenny."
      ],
      "tests": [
        {
          "text": "<code>undirectedAdjList</code> should only contain four nodes.",
          "testString": "assert(Object.keys(undirectedAdjList).length === 4, '<code>undirectedAdjList</code> should only contain four nodes.');"
        },
        {
          "text": "There should be an edge between <code>Jeff</code> and <code>James</code>.",
          "testString": "assert(undirectedAdjList.James.indexOf(\"Jeff\") !== -1 && undirectedAdjList.Jeff.indexOf(\"James\") !== -1, 'There should be an edge between <code>Jeff</code> and <code>James</code>.');"
        },
        {
          "text": "There should be an edge between <code>Jill</code> and <code>Jenny</code>.",
          "testString": "assert(undirectedAdjList.Jill.indexOf(\"Jenny\") !== -1 && undirectedAdjList.Jill.indexOf(\"Jenny\") !== -1, 'There should be an edge between <code>Jill</code> and <code>Jenny</code>.');"
        },
        {
          "text": "There should be an edge between <code>Jeff</code> and <code>Jenny</code>.",
          "testString": "assert(undirectedAdjList.Jeff.indexOf(\"Jenny\") !== -1 && undirectedAdjList.Jenny.indexOf(\"Jeff\") !== -1, 'There should be an edge between <code>Jeff</code> and <code>Jenny</code>.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "var undirectedAdjList = {\n\"James\": [\"Jeff\"],\"Jill\": [\"Jenny\"],\"Jenny\": [\"Jill\", \"Jeff\"],\n\"Jeff\": [\"James\", \"Jenny\"]\n};"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var undirectedAdjList = {",
            "};"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8256367417b2b2512c78",
      "title": "Adjacency Matrix",
      "description": [
        "Another way to represent a graph is to put it in an <dfn>adjacency matrix</dfn>.",
        "An <dfn>adjacency matrix</dfn> is a two-dimensional (2D) array where each nested array has the same number of elements as the outer array. In other words, it is a matrix or grid of numbers, where the numbers represent the edges. Zeros mean there is no edge or relationship.",
        "<blockquote>    1 2 3<br>   ------<br>1 | 0 1 1<br>2 | 1 0 0<br>3 | 1 0 0</blockquote>",
        "Above is a very simple, undirected graph where you have three nodes, where the first node is connected to the second and third node. <strong>Note</strong>: The numbers to the top and left of the matrix are just labels for the nodes.",
        "Below is a JavaScript implementation of the same thing.",
        "<blockquote>var adjMat = [<br>  [0, 1, 1],<br>  [1, 0, 0],<br>  [1, 0, 0]<br>];</blockquote>",
        "Unlike an adjacency list, each \"row\" of the matrix has to have the same number of elements as nodes in the graph. Here we have a three by three matrix, which means we have three nodes in our graph.",
        "A directed graph would look similar. Below is a graph where the first node has an edge pointing toward the second node, and then the second node has an edge pointing to the third node.",
        "<blockquote>var adjMatDirected = [<br>  [0, 1, 0],<br>  [0, 0, 1],<br>  [0, 0, 0]<br>];</blockquote>",
        "Graphs can also have <dfn>weights</dfn> on their edges. So far, we have <dfn>unweighted</dfn> edges where just the presence and lack of edge is binary (<code>0</code> or <code>1</code>). You can have different weights depending on your application.",
        "<hr>",
        "Create an adjacency matrix of an undirected graph with five nodes. This matrix should be in a multi-dimensional array. These five nodes have relationships between the first and fourth node, the first and third node, the third and fifth node, and the fourth and fifth node. All edge weights are one."
      ],
      "tests": [
        {
          "text": "<code>undirectedAdjList</code> should only contain five nodes.",
          "testString": "assert((adjMatUndirected.length === 5) && adjMatUndirected.map(function(x) { return x.length === 5 }).reduce(function(a, b) { return a && b }) , '<code>undirectedAdjList</code> should only contain five nodes.');"
        },
        {
          "text": "There should be an edge between the first and fourth node.",
          "testString": "assert((adjMatUndirected[0][3] === 1) && (adjMatUndirected[3][0] === 1), 'There should be an edge between the first and fourth node.');"
        },
        {
          "text": "There should be an edge between the first and third node.",
          "testString": "assert((adjMatUndirected[0][2] === 1) && (adjMatUndirected[2][0] === 1), 'There should be an edge between the first and third node.');"
        },
        {
          "text": "There should be an edge between the third and fifth node.",
          "testString": "assert((adjMatUndirected[2][4] === 1) && (adjMatUndirected[4][2] === 1), 'There should be an edge between the third and fifth node.');"
        },
        {
          "text": "There should be an edge between the fourth and fifth node.",
          "testString": "assert((adjMatUndirected[3][4] === 1) && (adjMatUndirected[4][3] === 1), 'There should be an edge between the fourth and fifth node.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "var adjMatUndirected = [[0, 0, 1, 1, 0],[0, 0, 0, 0, 0],[1, 0, 0, 0, 1],[1, 0, 0, 0, 1],[0, 0, 1, 1, 0]];"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var adjMatUndirected = [",
            "];"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d8256367417b2b2512c79",
      "title": "Incidence Matrix",
      "description": [
        "Yet another way to represent a graph is to put it in an <dfn>incidence matrix.</dfn>",
        "An <dfn>incidence matrix</dfn> is a two-dimensional (2D) array. Generally speaking, an incidence matrix relates two different classes of objects between its two dimensions. This kind of matrix is similar to an adjacency matrix. However, the rows and columns mean something else here.",
        "In graphs, we have edges and nodes. These will be our \"two different classes of objects\". This matrix will have the rows be the nodes and columns be the edges. This means that we can have an uneven number of rows and columns.",
        "Each column will represent a unique edge. Also, each edge connects two nodes. To show that there is an edge between two nodes, you will put a 1 in the two rows of a particular column. Below is a 3 node graph with one edge between node 1 and node 3.",
        "<blockquote>    1<br>   ---<br>1 | 1<br>2 | 0<br>3 | 1</blockquote>",
        "Here is an example of an <code>incidence matrix</code> with 4 edges and 4 nodes. Remember, the columns are the edges and rows are the nodes themselves.",
        "<blockquote>    1 2 3 4<br>   --------<br>1 | 0 1 1 1<br>2 | 1 1 0 0<br>3 | 1 0 0 1<br>4 | 0 0 1 0</blockquote>",
        "Below is a JavaScript implementation of the same thing.",
        "<blockquote>var incMat = [<br>  [0, 1, 1, 1],<br>  [1, 1, 0, 0],<br>  [1, 0, 0, 1],<br>  [0, 0, 1, 0]<br>];</blockquote>",
        "To make a directed graph, use <code>-1</code> for an edge leaving a particular node and <code>1</code> for an edge entering a node.",
        "<blockquote>var incMatDirected = [<br>  [ 0, -1,  1, -1],<br>  [-1,  1,  0,  0],<br>  [ 1,  0,  0,  1],<br>  [ 0,  0, -1,  0]<br>];</blockquote>",
        "Graphs can also have <dfn>weights</dfn> on their edges. So far, we have <dfn>unweighted</dfn> edges where just the presence and lack of edge is binary (<code>0</code> or <code>1</code>). You can have different weights depending on your application. A different weight is represented as numbers greater than 1.",
        "<hr>",
        "Create an incidence matrix of an undirected graph with five nodes and four edges. This matrix should be in a multi-dimensional array.",
        "These five nodes have relationships following relationships. The first edge is between the first and second node. The second edge is between the second and third node. The third edge is between the third and fifth node. And four edge is between the fourth and second node. All edge weights are one and the edge order matters."
      ],
      "tests": [
        {
          "text": "<code>incMatUndirected</code> should only contain five nodes.",
          "testString": "assert((incMatUndirected.length === 5) && incMatUndirected.map(function(x) { return x.length === 4 }).reduce(function(a, b) { return a && b }) , '<code>incMatUndirected</code> should only contain five nodes.');"
        },
        {
          "text": "There should be a first edge between the first and second node.",
          "testString": "assert((incMatUndirected[0][0] === 1) && (incMatUndirected[1][0] === 1), 'There should be a first edge between the first and second node.');"
        },
        {
          "text": "There should be a second edge between the second and third node.",
          "testString": "assert((incMatUndirected[1][1] === 1) && (incMatUndirected[2][1] === 1), 'There should be a second edge between the second and third node.');"
        },
        {
          "text": "There should be a third edge between the third and fifth node.",
          "testString": "assert((incMatUndirected[2][2] === 1) && (incMatUndirected[4][2] === 1), 'There should be a third edge between the third and fifth node.');"
        },
        {
          "text": "There should be a fourth edge between the second and fourth node.",
          "testString": "assert((incMatUndirected[1][3] === 1) && (incMatUndirected[3][3] === 1), 'There should be a fourth edge between the second and fourth node.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "var incMatUndirected = [[1, 0, 0, 0],[1, 1, 0, 1],[0, 1, 1, 0],[0, 0, 0, 1],[0, 0, 1, 0]];"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "var incMatUndirected = [",
            "  ",
            "];"
          ],
          "head": [],
          "tail": []
        }
      }
    },
    {
      "id": "587d825c367417b2b2512c90",
      "title": "Breadth-First Search",
      "description": [
        "So far, we've learned different ways of creating representations of graphs. What now? One natural question to have is what are the distances between any two nodes in the graph? Enter <dfn>graph traversal algorithms</dfn>.",
        "<dfn>Traversal algorithms</dfn> are algorithms to traverse or visit nodes in a graph. One type of traversal algorithm is the breadth-first search algorithm.",
        "This algorithm starts at one node, first visits all its neighbors that are one edge away, then goes on to visiting each of their neighbors.",
        "Visually, this is what the algorithm is doing.",
        "<img class='img-responsive' src='https://camo.githubusercontent.com/2f57e6239884a1a03402912f13c49555dec76d06/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f342f34362f416e696d617465645f4246532e676966'>",
        "To implement this algorithm, you'll need to input a graph structure and a node you want to start at.",
        "First, you'll want to be aware of the distances from the start node. This you'll want to start all your distances initially some large number, like <code>Infinity</code>. This gives a reference for the case where a node may not be reachable from your start node.",
        "Next, you'll want to go from the start node to its neighbors. These neighbors are one edge away and at this point you should add one unit of distance to the distances you're keeping track of.",
        "Last, an important data structure that will help implement the breadth-first search algorithm is the queue. This is an array where you can add elements to one end and remove elements from the other end. This is also known as a <dfn>FIFO</dfn> or <dfn>First-In-First-Out</dfn> data structure.",
        "<hr>",
        "Write a function <code>bfs()</code> that takes an adjacency matrix graph (a two-dimensional array) and a node label root as parameters. The node label will just be the integer value of the node between <code>0</code> and <code>n - 1</code>, where <code>n</code> is the total number of nodes in the graph.",
        "Your function will output a JavaScript object key-value pairs with the node and its distance from the root. If the node could not be reached, it should have a distance of <code>Infinity</code>."
      ],
      "tests": [
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>1</code> should return <code>{0: 1, 1: 0, 2: 1, 3: 2}</code>",
          "testString": "assert((function() { var graph = [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]; var results = bfs(graph, 1); return isEquivalent(results, {0: 1, 1: 0, 2: 1, 3: 2})})(), 'The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>1</code> should return <code>{0: 1, 1: 0, 2: 1, 3: 2}</code>');"
        },
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]</code> with a start node of <code>1</code> should return <code>{0: 1, 1: 0, 2: 1, 3: Infinity}</code>",
          "testString": "assert((function() { var graph = [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]; var results = bfs(graph, 1); return isEquivalent(results, {0: 1, 1: 0, 2: 1, 3: Infinity})})(), 'The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]</code> with a start node of <code>1</code> should return <code>{0: 1, 1: 0, 2: 1, 3: Infinity}</code>');"
        },
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>0</code> should return <code>{0: 0, 1: 1, 2: 2, 3: 3}</code>",
          "testString": "assert((function() { var graph = [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]; var results = bfs(graph, 0); return isEquivalent(results, {0: 0, 1: 1, 2: 2, 3: 3})})(), 'The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>0</code> should return <code>{0: 0, 1: 1, 2: 2, 3: 3}</code>');"
        },
        {
          "text": "The input graph <code>[[0, 1], [1, 0]]</code> with a start node of <code>0</code> should return <code>{0: 0, 1: 1}</code>",
          "testString": "assert((function() { var graph = [[0, 1], [1, 0]]; var results = bfs(graph, 0); return isEquivalent(results, {0: 0, 1: 1})})(), 'The input graph <code>[[0, 1], [1, 0]]</code> with a start node of <code>0</code> should return <code>{0: 0, 1: 1}</code>');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function bfs(graph, root) {\n// Distance object returned\nvar nodesLen = {};\n// Set all distances to infinity\nfor (var i = 0; i < graph.length; i++) {\nnodesLen[i] = Infinity;\n}\nnodesLen[root] = 0; // ...except root node\nvar queue = [root]; // Keep track of nodes to visit\nvar current; // Current node traversing\n// Keep on going until no more nodes to traverse\nwhile (queue.length !== 0) {\ncurrent = queue.shift();\n// Get adjacent nodes from current node\nvar curConnected = graph[current]; // Get layer of edges from current\nvar neighborIdx = []; // List of nodes with edges\nvar idx = curConnected.indexOf(1); // Get first edge connection\nwhile (idx !== -1) {\nneighborIdx.push(idx); // Add to list of neighbors\nidx = curConnected.indexOf(1, idx + 1); // Keep on searching\n}\n// Loop through neighbors and get lengths\nfor (var j = 0; j < neighborIdx.length; j++) {\n// Increment distance for nodes traversed\nif (nodesLen[neighborIdx[j]] === Infinity) {\nnodesLen[neighborIdx[j]] = nodesLen[current] + 1;\nqueue.push(neighborIdx[j]); // Add new neighbors to queue\n}\n}\n}\nreturn nodesLen;}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function bfs(graph, root) {",
            "  // Distance object returned",
            "  var nodesLen = {};",
            "  ",
            "  return nodesLen;",
            "};",
            "",
            "var exBFSGraph = [",
            "  [0, 1, 0, 0],",
            "  [1, 0, 1, 0],",
            "  [0, 1, 0, 1],",
            "  [0, 0, 1, 0]",
            "];",
            "console.log(bfs(exBFSGraph, 3));"
          ],
          "head": [],
          "tail": [
            "// Source: http://adripofjavascript.com/blog/drips/object-equality-in-javascript.html",
            "function isEquivalent(a, b) {",
            "    // Create arrays of property names",
            "    var aProps = Object.getOwnPropertyNames(a);",
            "    var bProps = Object.getOwnPropertyNames(b);",
            "    // If number of properties is different,",
            "    // objects are not equivalent",
            "    if (aProps.length != bProps.length) {",
            "        return false;",
            "    }",
            "    for (var i = 0; i < aProps.length; i++) {",
            "        var propName = aProps[i];",
            "        // If values of same property are not equal,",
            "        // objects are not equivalent",
            "        if (a[propName] !== b[propName]) {",
            "            return false;",
            "        }",
            "    }",
            "    // If we made it this far, objects",
            "    // are considered equivalent",
            "    return true;",
            "}"
          ]
        }
      }
    },
    {
      "id": "587d825d367417b2b2512c96",
      "title": "Depth-First Search",
      "description": [
        "Similar to <dfn>breadth-first search</dfn>, here we will learn about another graph traversal algorithm called <dfn>depth-first search</dfn>.",
        "Whereas the breadth-first search searches incremental edge lengths away from the source node, <dfn>depth-first search</dfn> first goes down a path of edges as far as it can.",
        "Once it reaches one end of a path, the search will backtrack to the last node with an un-visited edge path and continue searching.",
        "Visually, this is what the algorithm is doing where the top node is the starting point of the search.",
        "<img class='img-responsive' src='https://camo.githubusercontent.com/aaad9e39961daf34d967c616edeb50abf3bf1235/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f372f37662f44657074682d46697273742d5365617263682e676966'>",
        "A simple output of this algorithm is a list of nodes which are reachable from a given node. So when implementing this algorithm, you'll need to keep track of the nodes you visit.",
        "<hr>",
        "Write a function <code>dfs()</code> that takes an undirected, adjacency matrix <code>graph</code> and a node label <code>root</code> as parameters. The node label will just be the numeric value of the node between <code>0</code> and <code>n - 1</code>, where <code>n</code> is the total number of nodes in the graph.",
        "Your function should output an array of all nodes reachable from <code>root</code>."
      ],
      "tests": [
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>1</code> should return an array with <code>0</code>, <code>1</code>, <code>2</code>, and <code>3</code>.",
          "testString": "assert.sameMembers((function() { var graph = [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]; return dfs(graph, 1);})(), [0, 1, 2, 3], 'The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>1</code> should return an array with <code>0</code>, <code>1</code>, <code>2</code>, and <code>3</code>.');"
        },
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>1</code> should return an array with four elements.",
          "testString": "assert((function() { var graph = [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]; return dfs(graph, 1);})().length === 4, 'The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>1</code> should return an array with four elements.');"
        },
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]</code> with a start node of <code>3</code> should return an array with <code>3</code>.",
          "testString": "assert.sameMembers((function() { var graph = [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]; return dfs(graph, 3);})(), [3], 'The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]</code> with a start node of <code>3</code> should return an array with <code>3</code>.');"
        },
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]</code> with a start node of <code>3</code> should return an array with one element.",
          "testString": "assert((function() { var graph = [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]; return dfs(graph, 3);})().length === 1, 'The input graph <code>[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]</code> with a start node of <code>3</code> should return an array with one element.');"
        },
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>3</code> should return an array with <code>2</code> and <code>3</code>.",
          "testString": "assert.sameMembers((function() { var graph = [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]; return dfs(graph, 3);})(), [2, 3], 'The input graph <code>[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>3</code> should return an array with <code>2</code> and <code>3</code>.');"
        },
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>3</code> should return an array with two elements.",
          "testString": "assert((function() { var graph = [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]; return dfs(graph, 3);})().length === 2, 'The input graph <code>[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>3</code> should return an array with two elements.');"
        },
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>0</code> should return an array with <code>0</code> and <code>1</code>.",
          "testString": "assert.sameMembers((function() { var graph = [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]; return dfs(graph, 0);})(), [0, 1], 'The input graph <code>[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>0</code> should return an array with <code>0</code> and <code>1</code>.');"
        },
        {
          "text": "The input graph <code>[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>0</code> should return an array with two elements.",
          "testString": "assert((function() { var graph = [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]; return dfs(graph, 0);})().length === 2, 'The input graph <code>[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]</code> with a start node of <code>0</code> should return an array with two elements.');"
        }
      ],
      "releasedOn": "Feb 17, 2017",
      "solutions": [
        "function dfs(graph, root) { var stack = []; var tempV; var visited = []; var tempVNeighbors = []; stack.push(root); while (stack.length > 0) { tempV = stack.pop(); if (visited.indexOf(tempV) == -1) { visited.push(tempV); tempVNeighbors = graph[tempV]; for (var i = 0; i < tempVNeighbors.length; i++) { if (tempVNeighbors[i] == 1) { stack.push(i); }}}} return visited;}"
      ],
      "challengeType": 1,
      "files": {
        "indexjs": {
          "key": "indexjs",
          "ext": "js",
          "name": "index",
          "contents": [
            "function dfs(graph, root) {",
            "  ",
            "}",
            "",
            "var exDFSGraph = [",
            "  [0, 1, 0, 0],",
            "  [1, 0, 1, 0],",
            "  [0, 1, 0, 1],",
            "  [0, 0, 1, 0]",
            "];",
            "console.log(dfs(exDFSGraph, 3));"
          ],
          "head": [],
          "tail": []
        }
      }
    }
  ]
}
